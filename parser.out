Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    BACKTICK
    BIT_NOT
    BIT_OR
    BIT_XOR
    C_ASSOCIATIVITY
    C_CONVENIENCE
    C_DID_SET
    C_DYNAMIC
    C_FINAL
    C_GET
    C_INDIRECT
    C_INFIX
    C_LAZY
    C_LEFT
    C_MUTATING
    C_NONE
    C_NONMUTATING
    C_OPTIONAL
    C_OVERRIDE
    C_POSTFIX
    C_PRECEDENCE
    C_PREFIX
    C_PROTOCOL
    C_REQUIRED
    C_RIGHT
    C_SET
    C_TYPE
    C_TYPEDEF
    C_UNOWNED
    C_WEAK
    C_WILLSET
    DIV_AS
    D_ASSOCIATED_TYPE
    D_DEINIT
    D_ENUM
    D_EXTENSION
    D_FILE_PRIVATE
    D_FUNCTION
    D_INIT
    D_INOUT
    D_LET
    D_OPERATOR
    D_PRIVATE
    D_PROTOCOL
    D_PUBLIC
    D_STATIC
    D_STRUCT
    D_SUBSCRIPT
    D_TYPE_ALIAS
    D_VAR
    E_ANY
    E_AS
    E_CATCH
    E_IS
    E_NIL
    E_RETHROWS
    E_SELF
    E_SELF_CAPITAL
    E_SUPER
    E_THROW
    E_THROWS
    E_TRY
    HASH
    HRANGE
    LSHIFT
    MINUS_AS
    MOD_AS
    MULT_AS
    N_AVAILABLE
    N_COLOR_LITERAL
    N_COLUMN
    N_ELSE
    N_ELSE_IF
    N_END_IF
    N_ERROR
    N_FILE
    N_FILE_LITERAL
    N_FUNCTION
    N_IF
    N_IMAGE_LITERAL
    N_LINE
    N_SELECTOR
    N_SOURCE_LOCATION
    N_WARNING
    P_UNDERSCORE
    QUESTION
    RSHIFT
    S_BREAK
    S_CONTINUE
    S_DEFER
    S_DO
    S_FALLTHROUGH
    S_GUARD
    S_REPEAT
    S_RETURN
    S_WHERE

Grammar

Rule 0     S' -> translation-unit
Rule 1     translation-unit -> statement-star
Rule 2     statement-star -> statement statement-star
Rule 3     statement-star -> empty
Rule 4     statement -> SEMICOLON
Rule 5     statement -> global-const-defn
Rule 6     statement -> import-stmt
Rule 7     statement -> pragma-stmt
Rule 8     statement -> func-defn
Rule 9     statement -> block
Rule 10    statement -> if-stmt
Rule 11    statement -> switch-stmt
Rule 12    statement -> wait-stmt
Rule 13    statement -> foreach-loop
Rule 14    statement -> for-loop
Rule 15    statement -> var-decl
Rule 16    statement -> while-loop
Rule 17    statement -> iterate-loop
Rule 18    statement -> stmt-chain
Rule 19    statement -> opt-else-block
Rule 20    statement -> var-name
Rule 21    statement -> assignment
Rule 22    statement -> func-call
Rule 23    statement -> update-stmt
Rule 24    global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON
Rule 25    import-stmt -> D_IMPORT module-path SEMICOLON
Rule 26    import-stmt -> D_IMPORT STR_LITERAL SEMICOLON
Rule 27    module-path -> ID path-star
Rule 28    path-star -> DOT ID path-star
Rule 29    path-star -> <empty>
Rule 30    pragma-stmt -> C_PRAGMA ID expr SEMICOLON
Rule 31    func-defn -> swift-func-defn
Rule 32    func-defn -> app-func-defn
Rule 33    func-defn -> foreign-func-defn
Rule 34    func-hdr -> type-params formal-arg-list ID empty-or-arg-list
Rule 35    empty-or-arg-list -> formal-arg-list
Rule 36    empty-or-arg-list -> empty
Rule 37    type-params -> LESS var-name comma-name-star GREATER
Rule 38    type-params -> empty
Rule 39    comma-name-star -> COMMA var-name comma-name-star
Rule 40    comma-name-star -> <empty>
Rule 41    formal-arg-list -> LPAREN opt-formal-args RPAREN
Rule 42    formal-arg-list -> empty
Rule 43    opt-formal-args -> formal-arg comma-args-star
Rule 44    opt-formal-args -> empty
Rule 45    comma-args-star -> COMMA formal-arg comma-args-star
Rule 46    comma-args-star -> empty
Rule 47    formal-arg -> type-prefix empty-or-range var-name type-suffix empty-or-ass-expr
Rule 48    empty-or-range -> RANGE
Rule 49    empty-or-range -> empty
Rule 50    empty-or-ass-expr -> formal-arg-list ASSIGN expr
Rule 51    empty-or-ass-expr -> empty
Rule 52    swift-func-defn -> func-hdr ARROW block
Rule 53    app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE
Rule 54    app-body -> app-arg-expr app-arg-expr-star app-out-star empty-or-semicolon
Rule 55    empty-or-semicolon -> SEMICOLON
Rule 56    empty-or-semicolon -> empty
Rule 57    app-out-star -> std-in-out-err ASSIGN expr app-out-star
Rule 58    app-out-star -> <empty>
Rule 59    std-in-out-err -> E_STDIN
Rule 60    std-in-out-err -> E_STDOUT
Rule 61    std-in-out-err -> E_STDERR
Rule 62    app-arg-expr-star -> app-arg-expr app-arg-expr-star
Rule 63    app-arg-expr-star -> <empty>
Rule 64    foreign-func-defn -> func-hdr foreign-func-body
Rule 65    foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals
Rule 66    empty-or-literal -> STR_LITERAL
Rule 67    empty-or-literal -> empty
Rule 68    empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET
Rule 69    empty-or-more-literals -> empty
Rule 70    single-or-multiple-literal -> STR_LITERAL
Rule 71    single-or-multiple-literal -> MUL_STR_LITERAL
Rule 72    var-decl -> type-prefix var-decl-rest
Rule 73    var-decl-rest-star -> COMMA var-decl-rest var-decl-rest-star
Rule 74    var-decl-rest-star -> <empty>
Rule 75    var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr
Rule 76    empty -> <empty>
Rule 77    empty-or-var-mapping -> var-mapping
Rule 78    empty-or-var-mapping -> empty
Rule 79    empty-or-assign-expr -> ASSIGN expr
Rule 80    empty-or-assign-expr -> empty
Rule 81    type-prefix -> type-name
Rule 82    type-prefix -> param-type
Rule 83    param-type -> type-name LESS standalone-type GREATER
Rule 84    type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix
Rule 85    type-suffix -> <empty>
Rule 86    empty-or-standalone-type -> standalone-type
Rule 87    empty-or-standalone-type -> <empty>
Rule 88    standalone-type -> type-prefix type-suffix
Rule 89    var-mapping -> LESS expr GREATER
Rule 90    block -> LBRACE translation-unit RBRACE
Rule 91    stmt-chain -> chainable-stmt semicolon-or-arrow statement
Rule 92    semicolon-or-arrow -> SEMICOLON
Rule 93    semicolon-or-arrow -> ARROW
Rule 94    chainable-stmt -> var-name
Rule 95    chainable-stmt -> func-call
Rule 96    chainable-stmt -> var-decl
Rule 97    chainable-stmt -> assignment
Rule 98    assignment -> lval-or-paren-lval assign-or-plusas expr-list
Rule 99    lval-or-lval-list -> lval-list
Rule 100   lval-or-lval-list -> LPAREN lval-list RPAREN
Rule 101   assign-or-plusas -> ASSIGN
Rule 102   assign-or-plusas -> PLUS_AS
Rule 103   lval-or-paren-lval -> lval-list
Rule 104   lval-or-paren-lval -> LPAREN lval-list RPAREN
Rule 105   update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON
Rule 106   if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block
Rule 107   opt-else-block -> S_ELSE block
Rule 108   opt-else-block -> empty
Rule 109   switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE
Rule 110   opt-default -> S_DEFAULT
Rule 111   opt-default -> empty
Rule 112   case-star -> case case-star
Rule 113   case-star -> <empty>
Rule 114   case -> S_CASE INT COLON translation-unit
Rule 115   default -> S_DEFAULT COLON translation-unit
Rule 116   wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block
Rule 117   opt-deep -> E_DEEP
Rule 118   opt-deep -> empty
Rule 119   foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block
Rule 120   opt-comma-var-name -> COMMA var-name
Rule 121   opt-comma-var-name -> empty
Rule 122   for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
Rule 123   while-loop -> S_WHILE LPAREN expr RPAREN block
Rule 124   for-init-list -> for-init for-init-star
Rule 125   for-init-star -> COMMA for-init for-init-star
Rule 126   for-init-star -> <empty>
Rule 127   for-init -> for-assignment
Rule 128   for-init -> type-prefix var-name type-suffix ASSIGN expr
Rule 129   for-update-list -> for-assignment for-assignment-star
Rule 130   for-assignment-star -> COMMA for-assignment for-assignment-star
Rule 131   for-assignment-star -> <empty>
Rule 132   for-assignment -> var-name ASSIGN expr
Rule 133   iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN
Rule 134   expr -> or-expr
Rule 135   or-expr -> and-expr
Rule 136   or-expr -> or-expr LOG_OR and-expr
Rule 137   and-expr -> eq-expr
Rule 138   and-expr -> and-expr LOG_AND eq-expr
Rule 139   eq-expr -> cmp-expr
Rule 140   eq-expr -> eq-expr eq-or-not-eq eq-expr
Rule 141   eq-or-not-eq -> EQUAL
Rule 142   eq-or-not-eq -> NOT_EQUAL
Rule 143   cmp-expr -> add-expr
Rule 144   cmp-expr -> cmp-expr cmp-sign add-expr
Rule 145   cmp-sign -> LESS
Rule 146   cmp-sign -> LESS_EQ
Rule 147   cmp-sign -> EQUAL
Rule 148   cmp-sign -> GREATER
Rule 149   cmp-sign -> GREATER_EQ
Rule 150   add-expr -> mult-expr
Rule 151   add-expr -> add-expr add-sign mult-expr
Rule 152   add-sign -> PLUS
Rule 153   add-sign -> MINUS
Rule 154   mult-expr -> unary-expr
Rule 155   mult-expr -> mult-expr mult-sign unary-expr
Rule 156   mult-sign -> MULT
Rule 157   mult-sign -> DIV
Rule 158   mult-sign -> MULTPER
Rule 159   mult-sign -> DOUBLEPER
Rule 160   mult-sign -> MOD
Rule 161   unary-expr -> postfix-expr
Rule 162   unary-expr -> minus-or-excl postfix-expr
Rule 163   minus-or-excl -> MINUS
Rule 164   minus-or-excl -> EXCLAMATION
Rule 165   postfix-expr -> base-expr
Rule 166   postfix-expr -> postfix-expr array-or-struct
Rule 167   array-or-struct -> array-subscript
Rule 168   array-or-struct -> struct-subscript
Rule 169   array-subscript -> LBRACKET expr RBRACKET
Rule 170   struct-subscript -> DOT ID
Rule 171   base-expr -> literal
Rule 172   base-expr -> func-call
Rule 173   base-expr -> var-name
Rule 174   base-expr -> LPAREN expr RPAREN
Rule 175   base-expr -> -constructor
Rule 176   base-expr -> array-constructor
Rule 177   func-call -> ID LPAREN func-call-arg-list RPAREN
Rule 178   func-call-arg-list -> expr-or-kw func-call-arg-star
Rule 179   func-call-arg-star -> COMMA expr-or-kw func-call-arg-star
Rule 180   func-call-arg-star -> empty
Rule 181   expr-or-kw -> expr
Rule 182   expr-or-kw -> kw-expr
Rule 183   expr-or-kw -> empty
Rule 184   -constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN
Rule 185   comma-expr-star -> COMMA expr comma-expr-star
Rule 186   comma-expr-star -> empty
Rule 187   array-constructor -> array-list-constructor
Rule 188   array-constructor -> array-range-constructor
Rule 189   array-constructor -> array-kv-constructor
Rule 190   array-list-constructor -> LBRACKET opt-expr-list RBRACKET
Rule 191   opt-expr-list -> expr-list
Rule 192   opt-expr-list -> empty
Rule 193   array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET
Rule 194   opt-coloned-expr -> COLON expr
Rule 195   opt-coloned-expr -> empty
Rule 196   array-kv-constructor -> LBRACE opt-array-constructor RBRACE
Rule 197   opt-array-constructor -> array-kv-elem comma-array-kv-elem-star
Rule 198   opt-array-constructor -> empty
Rule 199   comma-array-kv-elem-star -> COMMA array-kv-elem comma-array-kv-elem-star
Rule 200   comma-array-kv-elem-star -> empty
Rule 201   array-kv-elem -> expr COLON expr
Rule 202   kw-expr -> ID ASSIGN expr
Rule 203   literal -> STR_LITERAL
Rule 204   literal -> MUL_STR_LITERAL
Rule 205   literal -> INT
Rule 206   literal -> float-literal
Rule 207   literal -> bool-literal
Rule 208   float-literal -> DOUBLE
Rule 209   float-literal -> INF
Rule 210   float-literal -> NAN
Rule 211   bool-literal -> E_TRUE
Rule 212   bool-literal -> E_FALSE
Rule 213   expr-list -> expr
Rule 214   type-name -> class_INT
Rule 215   type-name -> class_DOUBLE
Rule 216   type-name -> class_FLOAT
Rule 217   type-name -> class_VOID
Rule 218   type-name -> class_UINT
Rule 219   type-name -> class_BOOL
Rule 220   type-name -> class_CHARACTER
Rule 221   type-name -> class_String
Rule 222   type-name -> collection_SET
Rule 223   type-name -> collection_ARRAY
Rule 224   type-name -> collection_DICT
Rule 225   type-name -> ID
Rule 226   const-name -> ID
Rule 227   var-name -> ID
Rule 228   lval-list -> lval-expr lval-expr-star
Rule 229   lval-expr-star -> COMMA lval-expr lval-expr-star
Rule 230   lval-expr-star -> <empty>
Rule 231   lval-expr -> var-name subscript-star
Rule 232   subscript-star -> array-subscript subscript-star
Rule 233   subscript-star -> struct-subscript subscript-star
Rule 234   subscript-star -> empty
Rule 235   app-arg-expr -> opt-at var-name
Rule 236   app-arg-expr -> literal
Rule 237   app-arg-expr -> array-constructor
Rule 238   app-arg-expr -> LPAREN expr RPAREN
Rule 239   opt-at -> AT
Rule 240   opt-at -> empty

Terminals, with rules where they appear

AMPERSAND            : 
ARROW                : 52 93
ASSIGN               : 50 57 79 101 128 132 202
AT                   : 239
BACKTICK             : 
BIT_NOT              : 
BIT_OR               : 
BIT_XOR              : 
COLON                : 114 115 193 194 201
COMMA                : 39 45 73 120 125 130 179 184 185 199 229
C_APP                : 53
C_ASSOCIATIVITY      : 
C_CONST              : 24
C_CONVENIENCE        : 
C_DID_SET            : 
C_DYNAMIC            : 
C_FINAL              : 
C_GET                : 
C_GLOBAL             : 24
C_INDIRECT           : 
C_INFIX              : 
C_LAZY               : 
C_LEFT               : 
C_MUTATING           : 
C_NONE               : 
C_NONMUTATING        : 
C_OPTIONAL           : 
C_OVERRIDE           : 
C_POSTFIX            : 
C_PRAGMA             : 30
C_PRECEDENCE         : 
C_PREFIX             : 
C_PROTOCOL           : 
C_REQUIRED           : 
C_RIGHT              : 
C_SET                : 
C_TYPE               : 
C_TYPEDEF            : 
C_UNOWNED            : 
C_WEAK               : 
C_WILLSET            : 
DIV                  : 157
DIV_AS               : 
DOT                  : 28 170
DOUBLE               : 208
DOUBLEPER            : 159
D_ASSOCIATED_TYPE    : 
D_DEINIT             : 
D_ENUM               : 
D_EXTENSION          : 
D_FILE_PRIVATE       : 
D_FUNCTION           : 
D_IMPORT             : 25 26
D_INIT               : 
D_INOUT              : 
D_LET                : 
D_OPERATOR           : 
D_PRIVATE            : 
D_PROTOCOL           : 
D_PUBLIC             : 
D_STATIC             : 
D_STRUCT             : 
D_SUBSCRIPT          : 
D_TYPE_ALIAS         : 
D_VAR                : 
EQUAL                : 141 147
EXCLAMATION          : 164
E_ANY                : 
E_AS                 : 
E_CATCH              : 
E_DEEP               : 117
E_FALSE              : 212
E_IS                 : 
E_NIL                : 
E_RETHROWS           : 
E_SELF               : 
E_SELF_CAPITAL       : 
E_STDERR             : 61
E_STDIN              : 59
E_STDOUT             : 60
E_SUPER              : 
E_THROW              : 
E_THROWS             : 
E_TRUE               : 211
E_TRY                : 
E_WAIT               : 116
GREATER              : 37 83 89 105 148
GREATER_EQ           : 149
HASH                 : 
HRANGE               : 
ID                   : 27 28 30 34 105 170 177 202 225 226 227
INF                  : 209
INT                  : 114 205
LBRACE               : 53 90 109 196
LBRACKET             : 68 84 169 190 193
LESS                 : 37 83 89 105 145
LESS_EQ              : 146
LOG_AND              : 138
LOG_OR               : 136
LPAREN               : 41 100 104 106 109 116 122 123 133 174 177 184 238
LSHIFT               : 
MINUS                : 153 163
MINUS_AS             : 
MOD                  : 160
MOD_AS               : 
MULT                 : 156
MULTPER              : 158
MULT_AS              : 
MUL_STR_LITERAL      : 71 204
NAN                  : 210
NOT_EQUAL            : 142
N_AVAILABLE          : 
N_COLOR_LITERAL      : 
N_COLUMN             : 
N_ELSE               : 
N_ELSE_IF            : 
N_END_IF             : 
N_ERROR              : 
N_FILE               : 
N_FILE_LITERAL       : 
N_FUNCTION           : 
N_IF                 : 
N_IMAGE_LITERAL      : 
N_LINE               : 
N_SELECTOR           : 
N_SOURCE_LOCATION    : 
N_WARNING            : 
PLUS                 : 152
PLUS_AS              : 102
P_UNDERSCORE         : 
QUESTION             : 
RANGE                : 48
RBRACE               : 53 90 109 196
RBRACKET             : 68 84 169 190 193
RPAREN               : 41 100 104 106 109 116 122 123 133 174 177 184 238
RSHIFT               : 
SEMICOLON            : 4 24 25 26 30 55 92 105 122 122
STR_LITERAL          : 26 65 65 66 70 203
S_BREAK              : 
S_CASE               : 114
S_CONTINUE           : 
S_DEFAULT            : 110 115
S_DEFER              : 
S_DO                 : 
S_ELSE               : 107
S_FALLTHROUGH        : 
S_FOR                : 122
S_FOREACH            : 119
S_GUARD              : 
S_IF                 : 106
S_IN                 : 119
S_ITERATE            : 133
S_REPEAT             : 
S_RETURN             : 
S_SWITCH             : 109
S_UNTIL              : 133
S_WHERE              : 
S_WHILE              : 123
UPD                  : 105
class_BOOL           : 219
class_CHARACTER      : 220
class_DOUBLE         : 215
class_FLOAT          : 216
class_INT            : 214
class_String         : 221
class_UINT           : 218
class_VOID           : 217
collection_ARRAY     : 223
collection_DICT      : 224
collection_SET       : 222
error                : 

Nonterminals, with rules where they appear

-constructor         : 175
add-expr             : 143 144 151
add-sign             : 151
and-expr             : 135 136 138
app-arg-expr         : 54 62
app-arg-expr-star    : 54 62
app-body             : 53
app-func-defn        : 32
app-out-star         : 54 57
array-constructor    : 176 237
array-kv-constructor : 189
array-kv-elem        : 197 199
array-list-constructor : 187
array-or-struct      : 166
array-range-constructor : 188
array-subscript      : 167 232
assign-or-plusas     : 98
assignment           : 21 97
base-expr            : 165
block                : 9 52 106 107 116 119 122 123 133
bool-literal         : 207
case                 : 112
case-star            : 109 112
chainable-stmt       : 91
cmp-expr             : 139 144
cmp-sign             : 144
comma-args-star      : 43 45
comma-array-kv-elem-star : 197 199
comma-expr-star      : 184 185
comma-name-star      : 37 39
const-name           : 
default              : 
empty                : 3 36 38 42 44 46 49 51 56 67 69 78 80 108 111 118 121 180 183 186 192 195 198 200 234 240
empty-or-arg-list    : 34
empty-or-ass-expr    : 47
empty-or-assign-expr : 75
empty-or-literal     : 65
empty-or-more-literals : 65
empty-or-range       : 47
empty-or-semicolon   : 54
empty-or-standalone-type : 84
empty-or-var-mapping : 75
eq-expr              : 137 138 140 140
eq-or-not-eq         : 140
expr                 : 30 50 57 79 89 105 106 109 119 122 123 128 132 133 169 174 181 184 184 185 193 193 194 201 201 202 213 238
expr-list            : 98 116 191
expr-or-kw           : 178 179
float-literal        : 206
for-assignment       : 127 129 130
for-assignment-star  : 129 130
for-init             : 124 125
for-init-list        : 122
for-init-star        : 124 125
for-loop             : 14
for-update-list      : 122
foreach-loop         : 13
foreign-func-body    : 64
foreign-func-defn    : 33
formal-arg           : 43 45
formal-arg-list      : 34 35 50
func-call            : 22 95 172
func-call-arg-list   : 177
func-call-arg-star   : 178 179
func-defn            : 8
func-hdr             : 52 53 64
global-const-defn    : 5
if-stmt              : 10
import-stmt          : 6
iterate-loop         : 17
kw-expr              : 182
literal              : 171 236
lval-expr            : 228 229
lval-expr-star       : 228 229
lval-list            : 99 100 103 104
lval-or-lval-list    : 
lval-or-paren-lval   : 98
minus-or-excl        : 162
module-path          : 25
mult-expr            : 150 151 155
mult-sign            : 155
opt-array-constructor : 196
opt-at               : 235
opt-coloned-expr     : 193
opt-comma-var-name   : 119
opt-deep             : 116
opt-default          : 109
opt-else-block       : 19 106
opt-expr-list        : 190
opt-formal-args      : 41
or-expr              : 134 136
param-type           : 82
path-star            : 27 28
postfix-expr         : 161 162 166
pragma-stmt          : 7
semicolon-or-arrow   : 91
single-or-multiple-literal : 68
standalone-type      : 83 86
statement            : 2 91
statement-star       : 1 2
std-in-out-err       : 57
stmt-chain           : 18
struct-subscript     : 168 233
subscript-star       : 231 232 233
swift-func-defn      : 31
switch-stmt          : 11
translation-unit     : 90 114 115 0
type-name            : 81 83
type-params          : 34
type-prefix          : 47 72 88 128
type-suffix          : 47 75 84 88 128
unary-expr           : 154 155
update-stmt          : 23
var-decl             : 15 24 96
var-decl-rest        : 72 73
var-decl-rest-star   : 73
var-mapping          : 77
var-name             : 20 37 39 47 75 94 105 119 120 128 132 133 173 231 235
wait-stmt            : 12
while-loop           : 16

Parsing method: LALR

state 0

    (0) S' -> . translation-unit
    (1) translation-unit -> . statement-star
    (2) statement-star -> . statement statement-star
    (3) statement-star -> . empty
    (4) statement -> . SEMICOLON
    (5) statement -> . global-const-defn
    (6) statement -> . import-stmt
    (7) statement -> . pragma-stmt
    (8) statement -> . func-defn
    (9) statement -> . block
    (10) statement -> . if-stmt
    (11) statement -> . switch-stmt
    (12) statement -> . wait-stmt
    (13) statement -> . foreach-loop
    (14) statement -> . for-loop
    (15) statement -> . var-decl
    (16) statement -> . while-loop
    (17) statement -> . iterate-loop
    (18) statement -> . stmt-chain
    (19) statement -> . opt-else-block
    (20) statement -> . var-name
    (21) statement -> . assignment
    (22) statement -> . func-call
    (23) statement -> . update-stmt
    (76) empty -> .
    (24) global-const-defn -> . C_GLOBAL C_CONST var-decl SEMICOLON
    (25) import-stmt -> . D_IMPORT module-path SEMICOLON
    (26) import-stmt -> . D_IMPORT STR_LITERAL SEMICOLON
    (30) pragma-stmt -> . C_PRAGMA ID expr SEMICOLON
    (31) func-defn -> . swift-func-defn
    (32) func-defn -> . app-func-defn
    (33) func-defn -> . foreign-func-defn
    (90) block -> . LBRACE translation-unit RBRACE
    (106) if-stmt -> . S_IF LPAREN expr RPAREN block opt-else-block
    (109) switch-stmt -> . S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE
    (116) wait-stmt -> . E_WAIT opt-deep LPAREN expr-list RPAREN block
    (119) foreach-loop -> . S_FOREACH var-name opt-comma-var-name S_IN expr block
    (122) for-loop -> . S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
    (72) var-decl -> . type-prefix var-decl-rest
    (123) while-loop -> . S_WHILE LPAREN expr RPAREN block
    (133) iterate-loop -> . S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN
    (91) stmt-chain -> . chainable-stmt semicolon-or-arrow statement
    (107) opt-else-block -> . S_ELSE block
    (108) opt-else-block -> . empty
    (227) var-name -> . ID
    (98) assignment -> . lval-or-paren-lval assign-or-plusas expr-list
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (105) update-stmt -> . var-name LESS ID GREATER UPD expr SEMICOLON
    (52) swift-func-defn -> . func-hdr ARROW block
    (53) app-func-defn -> . C_APP func-hdr LBRACE app-body RBRACE
    (64) foreign-func-defn -> . func-hdr foreign-func-body
    (81) type-prefix -> . type-name
    (82) type-prefix -> . param-type
    (94) chainable-stmt -> . var-name
    (95) chainable-stmt -> . func-call
    (96) chainable-stmt -> . var-decl
    (97) chainable-stmt -> . assignment
    (103) lval-or-paren-lval -> . lval-list
    (104) lval-or-paren-lval -> . LPAREN lval-list RPAREN
    (34) func-hdr -> . type-params formal-arg-list ID empty-or-arg-list
    (214) type-name -> . class_INT
    (215) type-name -> . class_DOUBLE
    (216) type-name -> . class_FLOAT
    (217) type-name -> . class_VOID
    (218) type-name -> . class_UINT
    (219) type-name -> . class_BOOL
    (220) type-name -> . class_CHARACTER
    (221) type-name -> . class_String
    (222) type-name -> . collection_SET
    (223) type-name -> . collection_ARRAY
    (224) type-name -> . collection_DICT
    (225) type-name -> . ID
    (83) param-type -> . type-name LESS standalone-type GREATER
    (228) lval-list -> . lval-expr lval-expr-star
    (37) type-params -> . LESS var-name comma-name-star GREATER
    (38) type-params -> . empty
    (231) lval-expr -> . var-name subscript-star

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for C_GLOBAL resolved as shift
  ! shift/reduce conflict for D_IMPORT resolved as shift
  ! shift/reduce conflict for C_PRAGMA resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for S_IF resolved as shift
  ! shift/reduce conflict for S_SWITCH resolved as shift
  ! shift/reduce conflict for E_WAIT resolved as shift
  ! shift/reduce conflict for S_FOREACH resolved as shift
  ! shift/reduce conflict for S_FOR resolved as shift
  ! shift/reduce conflict for S_WHILE resolved as shift
  ! shift/reduce conflict for S_ITERATE resolved as shift
  ! shift/reduce conflict for S_ELSE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for C_APP resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for class_INT resolved as shift
  ! shift/reduce conflict for class_DOUBLE resolved as shift
  ! shift/reduce conflict for class_FLOAT resolved as shift
  ! shift/reduce conflict for class_VOID resolved as shift
  ! shift/reduce conflict for class_UINT resolved as shift
  ! shift/reduce conflict for class_BOOL resolved as shift
  ! shift/reduce conflict for class_CHARACTER resolved as shift
  ! shift/reduce conflict for class_String resolved as shift
  ! shift/reduce conflict for collection_SET resolved as shift
  ! shift/reduce conflict for collection_ARRAY resolved as shift
  ! shift/reduce conflict for collection_DICT resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
    SEMICOLON       shift and go to state 5
    $end            reduce using rule 76 (empty -> .)
    C_GLOBAL        shift and go to state 25
    D_IMPORT        shift and go to state 26
    C_PRAGMA        shift and go to state 27
    LBRACE          shift and go to state 32
    S_IF            shift and go to state 33
    S_SWITCH        shift and go to state 35
    E_WAIT          shift and go to state 36
    S_FOREACH       shift and go to state 37
    S_FOR           shift and go to state 38
    S_WHILE         shift and go to state 40
    S_ITERATE       shift and go to state 41
    S_ELSE          shift and go to state 43
    ID              shift and go to state 28
    C_APP           shift and go to state 47
    LPAREN          shift and go to state 34
    class_INT       shift and go to state 52
    class_DOUBLE    shift and go to state 53
    class_FLOAT     shift and go to state 54
    class_VOID      shift and go to state 55
    class_UINT      shift and go to state 56
    class_BOOL      shift and go to state 57
    class_CHARACTER shift and go to state 58
    class_String    shift and go to state 59
    collection_SET  shift and go to state 60
    collection_ARRAY shift and go to state 61
    collection_DICT shift and go to state 62
    LESS            shift and go to state 45

  ! SEMICOLON       [ reduce using rule 76 (empty -> .) ]
  ! C_GLOBAL        [ reduce using rule 76 (empty -> .) ]
  ! D_IMPORT        [ reduce using rule 76 (empty -> .) ]
  ! C_PRAGMA        [ reduce using rule 76 (empty -> .) ]
  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! S_IF            [ reduce using rule 76 (empty -> .) ]
  ! S_SWITCH        [ reduce using rule 76 (empty -> .) ]
  ! E_WAIT          [ reduce using rule 76 (empty -> .) ]
  ! S_FOREACH       [ reduce using rule 76 (empty -> .) ]
  ! S_FOR           [ reduce using rule 76 (empty -> .) ]
  ! S_WHILE         [ reduce using rule 76 (empty -> .) ]
  ! S_ITERATE       [ reduce using rule 76 (empty -> .) ]
  ! S_ELSE          [ reduce using rule 76 (empty -> .) ]
  ! ID              [ reduce using rule 76 (empty -> .) ]
  ! C_APP           [ reduce using rule 76 (empty -> .) ]
  ! LPAREN          [ reduce using rule 76 (empty -> .) ]
  ! class_INT       [ reduce using rule 76 (empty -> .) ]
  ! class_DOUBLE    [ reduce using rule 76 (empty -> .) ]
  ! class_FLOAT     [ reduce using rule 76 (empty -> .) ]
  ! class_VOID      [ reduce using rule 76 (empty -> .) ]
  ! class_UINT      [ reduce using rule 76 (empty -> .) ]
  ! class_BOOL      [ reduce using rule 76 (empty -> .) ]
  ! class_CHARACTER [ reduce using rule 76 (empty -> .) ]
  ! class_String    [ reduce using rule 76 (empty -> .) ]
  ! collection_SET  [ reduce using rule 76 (empty -> .) ]
  ! collection_ARRAY [ reduce using rule 76 (empty -> .) ]
  ! collection_DICT [ reduce using rule 76 (empty -> .) ]
  ! LESS            [ reduce using rule 76 (empty -> .) ]

    translation-unit               shift and go to state 1
    statement-star                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    global-const-defn              shift and go to state 6
    import-stmt                    shift and go to state 7
    pragma-stmt                    shift and go to state 8
    func-defn                      shift and go to state 9
    block                          shift and go to state 10
    if-stmt                        shift and go to state 11
    switch-stmt                    shift and go to state 12
    wait-stmt                      shift and go to state 13
    foreach-loop                   shift and go to state 14
    for-loop                       shift and go to state 15
    var-decl                       shift and go to state 16
    while-loop                     shift and go to state 17
    iterate-loop                   shift and go to state 18
    stmt-chain                     shift and go to state 19
    opt-else-block                 shift and go to state 20
    var-name                       shift and go to state 21
    assignment                     shift and go to state 22
    func-call                      shift and go to state 23
    update-stmt                    shift and go to state 24
    swift-func-defn                shift and go to state 29
    app-func-defn                  shift and go to state 30
    foreign-func-defn              shift and go to state 31
    type-prefix                    shift and go to state 39
    chainable-stmt                 shift and go to state 42
    lval-or-paren-lval             shift and go to state 44
    func-hdr                       shift and go to state 46
    type-name                      shift and go to state 48
    param-type                     shift and go to state 49
    lval-list                      shift and go to state 50
    type-params                    shift and go to state 51
    lval-expr                      shift and go to state 63

state 1

    (0) S' -> translation-unit .



state 2

    (1) translation-unit -> statement-star .

    $end            reduce using rule 1 (translation-unit -> statement-star .)
    RBRACE          reduce using rule 1 (translation-unit -> statement-star .)
    S_CASE          reduce using rule 1 (translation-unit -> statement-star .)
    S_DEFAULT       reduce using rule 1 (translation-unit -> statement-star .)


state 3

    (2) statement-star -> statement . statement-star
    (2) statement-star -> . statement statement-star
    (3) statement-star -> . empty
    (4) statement -> . SEMICOLON
    (5) statement -> . global-const-defn
    (6) statement -> . import-stmt
    (7) statement -> . pragma-stmt
    (8) statement -> . func-defn
    (9) statement -> . block
    (10) statement -> . if-stmt
    (11) statement -> . switch-stmt
    (12) statement -> . wait-stmt
    (13) statement -> . foreach-loop
    (14) statement -> . for-loop
    (15) statement -> . var-decl
    (16) statement -> . while-loop
    (17) statement -> . iterate-loop
    (18) statement -> . stmt-chain
    (19) statement -> . opt-else-block
    (20) statement -> . var-name
    (21) statement -> . assignment
    (22) statement -> . func-call
    (23) statement -> . update-stmt
    (76) empty -> .
    (24) global-const-defn -> . C_GLOBAL C_CONST var-decl SEMICOLON
    (25) import-stmt -> . D_IMPORT module-path SEMICOLON
    (26) import-stmt -> . D_IMPORT STR_LITERAL SEMICOLON
    (30) pragma-stmt -> . C_PRAGMA ID expr SEMICOLON
    (31) func-defn -> . swift-func-defn
    (32) func-defn -> . app-func-defn
    (33) func-defn -> . foreign-func-defn
    (90) block -> . LBRACE translation-unit RBRACE
    (106) if-stmt -> . S_IF LPAREN expr RPAREN block opt-else-block
    (109) switch-stmt -> . S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE
    (116) wait-stmt -> . E_WAIT opt-deep LPAREN expr-list RPAREN block
    (119) foreach-loop -> . S_FOREACH var-name opt-comma-var-name S_IN expr block
    (122) for-loop -> . S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
    (72) var-decl -> . type-prefix var-decl-rest
    (123) while-loop -> . S_WHILE LPAREN expr RPAREN block
    (133) iterate-loop -> . S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN
    (91) stmt-chain -> . chainable-stmt semicolon-or-arrow statement
    (107) opt-else-block -> . S_ELSE block
    (108) opt-else-block -> . empty
    (227) var-name -> . ID
    (98) assignment -> . lval-or-paren-lval assign-or-plusas expr-list
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (105) update-stmt -> . var-name LESS ID GREATER UPD expr SEMICOLON
    (52) swift-func-defn -> . func-hdr ARROW block
    (53) app-func-defn -> . C_APP func-hdr LBRACE app-body RBRACE
    (64) foreign-func-defn -> . func-hdr foreign-func-body
    (81) type-prefix -> . type-name
    (82) type-prefix -> . param-type
    (94) chainable-stmt -> . var-name
    (95) chainable-stmt -> . func-call
    (96) chainable-stmt -> . var-decl
    (97) chainable-stmt -> . assignment
    (103) lval-or-paren-lval -> . lval-list
    (104) lval-or-paren-lval -> . LPAREN lval-list RPAREN
    (34) func-hdr -> . type-params formal-arg-list ID empty-or-arg-list
    (214) type-name -> . class_INT
    (215) type-name -> . class_DOUBLE
    (216) type-name -> . class_FLOAT
    (217) type-name -> . class_VOID
    (218) type-name -> . class_UINT
    (219) type-name -> . class_BOOL
    (220) type-name -> . class_CHARACTER
    (221) type-name -> . class_String
    (222) type-name -> . collection_SET
    (223) type-name -> . collection_ARRAY
    (224) type-name -> . collection_DICT
    (225) type-name -> . ID
    (83) param-type -> . type-name LESS standalone-type GREATER
    (228) lval-list -> . lval-expr lval-expr-star
    (37) type-params -> . LESS var-name comma-name-star GREATER
    (38) type-params -> . empty
    (231) lval-expr -> . var-name subscript-star

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for C_GLOBAL resolved as shift
  ! shift/reduce conflict for D_IMPORT resolved as shift
  ! shift/reduce conflict for C_PRAGMA resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for S_IF resolved as shift
  ! shift/reduce conflict for S_SWITCH resolved as shift
  ! shift/reduce conflict for E_WAIT resolved as shift
  ! shift/reduce conflict for S_FOREACH resolved as shift
  ! shift/reduce conflict for S_FOR resolved as shift
  ! shift/reduce conflict for S_WHILE resolved as shift
  ! shift/reduce conflict for S_ITERATE resolved as shift
  ! shift/reduce conflict for S_ELSE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for C_APP resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for class_INT resolved as shift
  ! shift/reduce conflict for class_DOUBLE resolved as shift
  ! shift/reduce conflict for class_FLOAT resolved as shift
  ! shift/reduce conflict for class_VOID resolved as shift
  ! shift/reduce conflict for class_UINT resolved as shift
  ! shift/reduce conflict for class_BOOL resolved as shift
  ! shift/reduce conflict for class_CHARACTER resolved as shift
  ! shift/reduce conflict for class_String resolved as shift
  ! shift/reduce conflict for collection_SET resolved as shift
  ! shift/reduce conflict for collection_ARRAY resolved as shift
  ! shift/reduce conflict for collection_DICT resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
    SEMICOLON       shift and go to state 5
    $end            reduce using rule 76 (empty -> .)
    RBRACE          reduce using rule 76 (empty -> .)
    S_CASE          reduce using rule 76 (empty -> .)
    S_DEFAULT       reduce using rule 76 (empty -> .)
    C_GLOBAL        shift and go to state 25
    D_IMPORT        shift and go to state 26
    C_PRAGMA        shift and go to state 27
    LBRACE          shift and go to state 32
    S_IF            shift and go to state 33
    S_SWITCH        shift and go to state 35
    E_WAIT          shift and go to state 36
    S_FOREACH       shift and go to state 37
    S_FOR           shift and go to state 38
    S_WHILE         shift and go to state 40
    S_ITERATE       shift and go to state 41
    S_ELSE          shift and go to state 43
    ID              shift and go to state 28
    C_APP           shift and go to state 47
    LPAREN          shift and go to state 34
    class_INT       shift and go to state 52
    class_DOUBLE    shift and go to state 53
    class_FLOAT     shift and go to state 54
    class_VOID      shift and go to state 55
    class_UINT      shift and go to state 56
    class_BOOL      shift and go to state 57
    class_CHARACTER shift and go to state 58
    class_String    shift and go to state 59
    collection_SET  shift and go to state 60
    collection_ARRAY shift and go to state 61
    collection_DICT shift and go to state 62
    LESS            shift and go to state 45

  ! SEMICOLON       [ reduce using rule 76 (empty -> .) ]
  ! C_GLOBAL        [ reduce using rule 76 (empty -> .) ]
  ! D_IMPORT        [ reduce using rule 76 (empty -> .) ]
  ! C_PRAGMA        [ reduce using rule 76 (empty -> .) ]
  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! S_IF            [ reduce using rule 76 (empty -> .) ]
  ! S_SWITCH        [ reduce using rule 76 (empty -> .) ]
  ! E_WAIT          [ reduce using rule 76 (empty -> .) ]
  ! S_FOREACH       [ reduce using rule 76 (empty -> .) ]
  ! S_FOR           [ reduce using rule 76 (empty -> .) ]
  ! S_WHILE         [ reduce using rule 76 (empty -> .) ]
  ! S_ITERATE       [ reduce using rule 76 (empty -> .) ]
  ! S_ELSE          [ reduce using rule 76 (empty -> .) ]
  ! ID              [ reduce using rule 76 (empty -> .) ]
  ! C_APP           [ reduce using rule 76 (empty -> .) ]
  ! LPAREN          [ reduce using rule 76 (empty -> .) ]
  ! class_INT       [ reduce using rule 76 (empty -> .) ]
  ! class_DOUBLE    [ reduce using rule 76 (empty -> .) ]
  ! class_FLOAT     [ reduce using rule 76 (empty -> .) ]
  ! class_VOID      [ reduce using rule 76 (empty -> .) ]
  ! class_UINT      [ reduce using rule 76 (empty -> .) ]
  ! class_BOOL      [ reduce using rule 76 (empty -> .) ]
  ! class_CHARACTER [ reduce using rule 76 (empty -> .) ]
  ! class_String    [ reduce using rule 76 (empty -> .) ]
  ! collection_SET  [ reduce using rule 76 (empty -> .) ]
  ! collection_ARRAY [ reduce using rule 76 (empty -> .) ]
  ! collection_DICT [ reduce using rule 76 (empty -> .) ]
  ! LESS            [ reduce using rule 76 (empty -> .) ]

    statement                      shift and go to state 3
    statement-star                 shift and go to state 64
    empty                          shift and go to state 4
    global-const-defn              shift and go to state 6
    import-stmt                    shift and go to state 7
    pragma-stmt                    shift and go to state 8
    func-defn                      shift and go to state 9
    block                          shift and go to state 10
    if-stmt                        shift and go to state 11
    switch-stmt                    shift and go to state 12
    wait-stmt                      shift and go to state 13
    foreach-loop                   shift and go to state 14
    for-loop                       shift and go to state 15
    var-decl                       shift and go to state 16
    while-loop                     shift and go to state 17
    iterate-loop                   shift and go to state 18
    stmt-chain                     shift and go to state 19
    opt-else-block                 shift and go to state 20
    var-name                       shift and go to state 21
    assignment                     shift and go to state 22
    func-call                      shift and go to state 23
    update-stmt                    shift and go to state 24
    swift-func-defn                shift and go to state 29
    app-func-defn                  shift and go to state 30
    foreign-func-defn              shift and go to state 31
    type-prefix                    shift and go to state 39
    chainable-stmt                 shift and go to state 42
    lval-or-paren-lval             shift and go to state 44
    func-hdr                       shift and go to state 46
    type-name                      shift and go to state 48
    param-type                     shift and go to state 49
    lval-list                      shift and go to state 50
    type-params                    shift and go to state 51
    lval-expr                      shift and go to state 63

state 4

    (3) statement-star -> empty .
    (108) opt-else-block -> empty .
    (38) type-params -> empty .

  ! reduce/reduce conflict for $end resolved using rule 3 (statement-star -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 3 (statement-star -> empty .)
  ! reduce/reduce conflict for S_CASE resolved using rule 3 (statement-star -> empty .)
  ! reduce/reduce conflict for S_DEFAULT resolved using rule 3 (statement-star -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 38 (type-params -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 38 (type-params -> empty .)
    $end            reduce using rule 3 (statement-star -> empty .)
    RBRACE          reduce using rule 3 (statement-star -> empty .)
    S_CASE          reduce using rule 3 (statement-star -> empty .)
    S_DEFAULT       reduce using rule 3 (statement-star -> empty .)
    SEMICOLON       reduce using rule 108 (opt-else-block -> empty .)
    C_GLOBAL        reduce using rule 108 (opt-else-block -> empty .)
    D_IMPORT        reduce using rule 108 (opt-else-block -> empty .)
    C_PRAGMA        reduce using rule 108 (opt-else-block -> empty .)
    LBRACE          reduce using rule 108 (opt-else-block -> empty .)
    S_IF            reduce using rule 108 (opt-else-block -> empty .)
    S_SWITCH        reduce using rule 108 (opt-else-block -> empty .)
    E_WAIT          reduce using rule 108 (opt-else-block -> empty .)
    S_FOREACH       reduce using rule 108 (opt-else-block -> empty .)
    S_FOR           reduce using rule 108 (opt-else-block -> empty .)
    S_WHILE         reduce using rule 108 (opt-else-block -> empty .)
    S_ITERATE       reduce using rule 108 (opt-else-block -> empty .)
    S_ELSE          reduce using rule 108 (opt-else-block -> empty .)
    C_APP           reduce using rule 108 (opt-else-block -> empty .)
    class_INT       reduce using rule 108 (opt-else-block -> empty .)
    class_DOUBLE    reduce using rule 108 (opt-else-block -> empty .)
    class_FLOAT     reduce using rule 108 (opt-else-block -> empty .)
    class_VOID      reduce using rule 108 (opt-else-block -> empty .)
    class_UINT      reduce using rule 108 (opt-else-block -> empty .)
    class_BOOL      reduce using rule 108 (opt-else-block -> empty .)
    class_CHARACTER reduce using rule 108 (opt-else-block -> empty .)
    class_String    reduce using rule 108 (opt-else-block -> empty .)
    collection_SET  reduce using rule 108 (opt-else-block -> empty .)
    collection_ARRAY reduce using rule 108 (opt-else-block -> empty .)
    collection_DICT reduce using rule 108 (opt-else-block -> empty .)
    LESS            reduce using rule 108 (opt-else-block -> empty .)
    LPAREN          reduce using rule 38 (type-params -> empty .)
    ID              reduce using rule 38 (type-params -> empty .)

  ! ID              [ reduce using rule 108 (opt-else-block -> empty .) ]
  ! LPAREN          [ reduce using rule 108 (opt-else-block -> empty .) ]
  ! $end            [ reduce using rule 108 (opt-else-block -> empty .) ]
  ! RBRACE          [ reduce using rule 108 (opt-else-block -> empty .) ]
  ! S_CASE          [ reduce using rule 108 (opt-else-block -> empty .) ]
  ! S_DEFAULT       [ reduce using rule 108 (opt-else-block -> empty .) ]


state 5

    (4) statement -> SEMICOLON .

    SEMICOLON       reduce using rule 4 (statement -> SEMICOLON .)
    C_GLOBAL        reduce using rule 4 (statement -> SEMICOLON .)
    D_IMPORT        reduce using rule 4 (statement -> SEMICOLON .)
    C_PRAGMA        reduce using rule 4 (statement -> SEMICOLON .)
    LBRACE          reduce using rule 4 (statement -> SEMICOLON .)
    S_IF            reduce using rule 4 (statement -> SEMICOLON .)
    S_SWITCH        reduce using rule 4 (statement -> SEMICOLON .)
    E_WAIT          reduce using rule 4 (statement -> SEMICOLON .)
    S_FOREACH       reduce using rule 4 (statement -> SEMICOLON .)
    S_FOR           reduce using rule 4 (statement -> SEMICOLON .)
    S_WHILE         reduce using rule 4 (statement -> SEMICOLON .)
    S_ITERATE       reduce using rule 4 (statement -> SEMICOLON .)
    S_ELSE          reduce using rule 4 (statement -> SEMICOLON .)
    ID              reduce using rule 4 (statement -> SEMICOLON .)
    C_APP           reduce using rule 4 (statement -> SEMICOLON .)
    LPAREN          reduce using rule 4 (statement -> SEMICOLON .)
    class_INT       reduce using rule 4 (statement -> SEMICOLON .)
    class_DOUBLE    reduce using rule 4 (statement -> SEMICOLON .)
    class_FLOAT     reduce using rule 4 (statement -> SEMICOLON .)
    class_VOID      reduce using rule 4 (statement -> SEMICOLON .)
    class_UINT      reduce using rule 4 (statement -> SEMICOLON .)
    class_BOOL      reduce using rule 4 (statement -> SEMICOLON .)
    class_CHARACTER reduce using rule 4 (statement -> SEMICOLON .)
    class_String    reduce using rule 4 (statement -> SEMICOLON .)
    collection_SET  reduce using rule 4 (statement -> SEMICOLON .)
    collection_ARRAY reduce using rule 4 (statement -> SEMICOLON .)
    collection_DICT reduce using rule 4 (statement -> SEMICOLON .)
    LESS            reduce using rule 4 (statement -> SEMICOLON .)
    $end            reduce using rule 4 (statement -> SEMICOLON .)
    RBRACE          reduce using rule 4 (statement -> SEMICOLON .)
    S_CASE          reduce using rule 4 (statement -> SEMICOLON .)
    S_DEFAULT       reduce using rule 4 (statement -> SEMICOLON .)


state 6

    (5) statement -> global-const-defn .

    SEMICOLON       reduce using rule 5 (statement -> global-const-defn .)
    C_GLOBAL        reduce using rule 5 (statement -> global-const-defn .)
    D_IMPORT        reduce using rule 5 (statement -> global-const-defn .)
    C_PRAGMA        reduce using rule 5 (statement -> global-const-defn .)
    LBRACE          reduce using rule 5 (statement -> global-const-defn .)
    S_IF            reduce using rule 5 (statement -> global-const-defn .)
    S_SWITCH        reduce using rule 5 (statement -> global-const-defn .)
    E_WAIT          reduce using rule 5 (statement -> global-const-defn .)
    S_FOREACH       reduce using rule 5 (statement -> global-const-defn .)
    S_FOR           reduce using rule 5 (statement -> global-const-defn .)
    S_WHILE         reduce using rule 5 (statement -> global-const-defn .)
    S_ITERATE       reduce using rule 5 (statement -> global-const-defn .)
    S_ELSE          reduce using rule 5 (statement -> global-const-defn .)
    ID              reduce using rule 5 (statement -> global-const-defn .)
    C_APP           reduce using rule 5 (statement -> global-const-defn .)
    LPAREN          reduce using rule 5 (statement -> global-const-defn .)
    class_INT       reduce using rule 5 (statement -> global-const-defn .)
    class_DOUBLE    reduce using rule 5 (statement -> global-const-defn .)
    class_FLOAT     reduce using rule 5 (statement -> global-const-defn .)
    class_VOID      reduce using rule 5 (statement -> global-const-defn .)
    class_UINT      reduce using rule 5 (statement -> global-const-defn .)
    class_BOOL      reduce using rule 5 (statement -> global-const-defn .)
    class_CHARACTER reduce using rule 5 (statement -> global-const-defn .)
    class_String    reduce using rule 5 (statement -> global-const-defn .)
    collection_SET  reduce using rule 5 (statement -> global-const-defn .)
    collection_ARRAY reduce using rule 5 (statement -> global-const-defn .)
    collection_DICT reduce using rule 5 (statement -> global-const-defn .)
    LESS            reduce using rule 5 (statement -> global-const-defn .)
    $end            reduce using rule 5 (statement -> global-const-defn .)
    RBRACE          reduce using rule 5 (statement -> global-const-defn .)
    S_CASE          reduce using rule 5 (statement -> global-const-defn .)
    S_DEFAULT       reduce using rule 5 (statement -> global-const-defn .)


state 7

    (6) statement -> import-stmt .

    SEMICOLON       reduce using rule 6 (statement -> import-stmt .)
    C_GLOBAL        reduce using rule 6 (statement -> import-stmt .)
    D_IMPORT        reduce using rule 6 (statement -> import-stmt .)
    C_PRAGMA        reduce using rule 6 (statement -> import-stmt .)
    LBRACE          reduce using rule 6 (statement -> import-stmt .)
    S_IF            reduce using rule 6 (statement -> import-stmt .)
    S_SWITCH        reduce using rule 6 (statement -> import-stmt .)
    E_WAIT          reduce using rule 6 (statement -> import-stmt .)
    S_FOREACH       reduce using rule 6 (statement -> import-stmt .)
    S_FOR           reduce using rule 6 (statement -> import-stmt .)
    S_WHILE         reduce using rule 6 (statement -> import-stmt .)
    S_ITERATE       reduce using rule 6 (statement -> import-stmt .)
    S_ELSE          reduce using rule 6 (statement -> import-stmt .)
    ID              reduce using rule 6 (statement -> import-stmt .)
    C_APP           reduce using rule 6 (statement -> import-stmt .)
    LPAREN          reduce using rule 6 (statement -> import-stmt .)
    class_INT       reduce using rule 6 (statement -> import-stmt .)
    class_DOUBLE    reduce using rule 6 (statement -> import-stmt .)
    class_FLOAT     reduce using rule 6 (statement -> import-stmt .)
    class_VOID      reduce using rule 6 (statement -> import-stmt .)
    class_UINT      reduce using rule 6 (statement -> import-stmt .)
    class_BOOL      reduce using rule 6 (statement -> import-stmt .)
    class_CHARACTER reduce using rule 6 (statement -> import-stmt .)
    class_String    reduce using rule 6 (statement -> import-stmt .)
    collection_SET  reduce using rule 6 (statement -> import-stmt .)
    collection_ARRAY reduce using rule 6 (statement -> import-stmt .)
    collection_DICT reduce using rule 6 (statement -> import-stmt .)
    LESS            reduce using rule 6 (statement -> import-stmt .)
    $end            reduce using rule 6 (statement -> import-stmt .)
    RBRACE          reduce using rule 6 (statement -> import-stmt .)
    S_CASE          reduce using rule 6 (statement -> import-stmt .)
    S_DEFAULT       reduce using rule 6 (statement -> import-stmt .)


state 8

    (7) statement -> pragma-stmt .

    SEMICOLON       reduce using rule 7 (statement -> pragma-stmt .)
    C_GLOBAL        reduce using rule 7 (statement -> pragma-stmt .)
    D_IMPORT        reduce using rule 7 (statement -> pragma-stmt .)
    C_PRAGMA        reduce using rule 7 (statement -> pragma-stmt .)
    LBRACE          reduce using rule 7 (statement -> pragma-stmt .)
    S_IF            reduce using rule 7 (statement -> pragma-stmt .)
    S_SWITCH        reduce using rule 7 (statement -> pragma-stmt .)
    E_WAIT          reduce using rule 7 (statement -> pragma-stmt .)
    S_FOREACH       reduce using rule 7 (statement -> pragma-stmt .)
    S_FOR           reduce using rule 7 (statement -> pragma-stmt .)
    S_WHILE         reduce using rule 7 (statement -> pragma-stmt .)
    S_ITERATE       reduce using rule 7 (statement -> pragma-stmt .)
    S_ELSE          reduce using rule 7 (statement -> pragma-stmt .)
    ID              reduce using rule 7 (statement -> pragma-stmt .)
    C_APP           reduce using rule 7 (statement -> pragma-stmt .)
    LPAREN          reduce using rule 7 (statement -> pragma-stmt .)
    class_INT       reduce using rule 7 (statement -> pragma-stmt .)
    class_DOUBLE    reduce using rule 7 (statement -> pragma-stmt .)
    class_FLOAT     reduce using rule 7 (statement -> pragma-stmt .)
    class_VOID      reduce using rule 7 (statement -> pragma-stmt .)
    class_UINT      reduce using rule 7 (statement -> pragma-stmt .)
    class_BOOL      reduce using rule 7 (statement -> pragma-stmt .)
    class_CHARACTER reduce using rule 7 (statement -> pragma-stmt .)
    class_String    reduce using rule 7 (statement -> pragma-stmt .)
    collection_SET  reduce using rule 7 (statement -> pragma-stmt .)
    collection_ARRAY reduce using rule 7 (statement -> pragma-stmt .)
    collection_DICT reduce using rule 7 (statement -> pragma-stmt .)
    LESS            reduce using rule 7 (statement -> pragma-stmt .)
    $end            reduce using rule 7 (statement -> pragma-stmt .)
    RBRACE          reduce using rule 7 (statement -> pragma-stmt .)
    S_CASE          reduce using rule 7 (statement -> pragma-stmt .)
    S_DEFAULT       reduce using rule 7 (statement -> pragma-stmt .)


state 9

    (8) statement -> func-defn .

    SEMICOLON       reduce using rule 8 (statement -> func-defn .)
    C_GLOBAL        reduce using rule 8 (statement -> func-defn .)
    D_IMPORT        reduce using rule 8 (statement -> func-defn .)
    C_PRAGMA        reduce using rule 8 (statement -> func-defn .)
    LBRACE          reduce using rule 8 (statement -> func-defn .)
    S_IF            reduce using rule 8 (statement -> func-defn .)
    S_SWITCH        reduce using rule 8 (statement -> func-defn .)
    E_WAIT          reduce using rule 8 (statement -> func-defn .)
    S_FOREACH       reduce using rule 8 (statement -> func-defn .)
    S_FOR           reduce using rule 8 (statement -> func-defn .)
    S_WHILE         reduce using rule 8 (statement -> func-defn .)
    S_ITERATE       reduce using rule 8 (statement -> func-defn .)
    S_ELSE          reduce using rule 8 (statement -> func-defn .)
    ID              reduce using rule 8 (statement -> func-defn .)
    C_APP           reduce using rule 8 (statement -> func-defn .)
    LPAREN          reduce using rule 8 (statement -> func-defn .)
    class_INT       reduce using rule 8 (statement -> func-defn .)
    class_DOUBLE    reduce using rule 8 (statement -> func-defn .)
    class_FLOAT     reduce using rule 8 (statement -> func-defn .)
    class_VOID      reduce using rule 8 (statement -> func-defn .)
    class_UINT      reduce using rule 8 (statement -> func-defn .)
    class_BOOL      reduce using rule 8 (statement -> func-defn .)
    class_CHARACTER reduce using rule 8 (statement -> func-defn .)
    class_String    reduce using rule 8 (statement -> func-defn .)
    collection_SET  reduce using rule 8 (statement -> func-defn .)
    collection_ARRAY reduce using rule 8 (statement -> func-defn .)
    collection_DICT reduce using rule 8 (statement -> func-defn .)
    LESS            reduce using rule 8 (statement -> func-defn .)
    $end            reduce using rule 8 (statement -> func-defn .)
    RBRACE          reduce using rule 8 (statement -> func-defn .)
    S_CASE          reduce using rule 8 (statement -> func-defn .)
    S_DEFAULT       reduce using rule 8 (statement -> func-defn .)


state 10

    (9) statement -> block .

    SEMICOLON       reduce using rule 9 (statement -> block .)
    C_GLOBAL        reduce using rule 9 (statement -> block .)
    D_IMPORT        reduce using rule 9 (statement -> block .)
    C_PRAGMA        reduce using rule 9 (statement -> block .)
    LBRACE          reduce using rule 9 (statement -> block .)
    S_IF            reduce using rule 9 (statement -> block .)
    S_SWITCH        reduce using rule 9 (statement -> block .)
    E_WAIT          reduce using rule 9 (statement -> block .)
    S_FOREACH       reduce using rule 9 (statement -> block .)
    S_FOR           reduce using rule 9 (statement -> block .)
    S_WHILE         reduce using rule 9 (statement -> block .)
    S_ITERATE       reduce using rule 9 (statement -> block .)
    S_ELSE          reduce using rule 9 (statement -> block .)
    ID              reduce using rule 9 (statement -> block .)
    C_APP           reduce using rule 9 (statement -> block .)
    LPAREN          reduce using rule 9 (statement -> block .)
    class_INT       reduce using rule 9 (statement -> block .)
    class_DOUBLE    reduce using rule 9 (statement -> block .)
    class_FLOAT     reduce using rule 9 (statement -> block .)
    class_VOID      reduce using rule 9 (statement -> block .)
    class_UINT      reduce using rule 9 (statement -> block .)
    class_BOOL      reduce using rule 9 (statement -> block .)
    class_CHARACTER reduce using rule 9 (statement -> block .)
    class_String    reduce using rule 9 (statement -> block .)
    collection_SET  reduce using rule 9 (statement -> block .)
    collection_ARRAY reduce using rule 9 (statement -> block .)
    collection_DICT reduce using rule 9 (statement -> block .)
    LESS            reduce using rule 9 (statement -> block .)
    $end            reduce using rule 9 (statement -> block .)
    RBRACE          reduce using rule 9 (statement -> block .)
    S_CASE          reduce using rule 9 (statement -> block .)
    S_DEFAULT       reduce using rule 9 (statement -> block .)


state 11

    (10) statement -> if-stmt .

    SEMICOLON       reduce using rule 10 (statement -> if-stmt .)
    C_GLOBAL        reduce using rule 10 (statement -> if-stmt .)
    D_IMPORT        reduce using rule 10 (statement -> if-stmt .)
    C_PRAGMA        reduce using rule 10 (statement -> if-stmt .)
    LBRACE          reduce using rule 10 (statement -> if-stmt .)
    S_IF            reduce using rule 10 (statement -> if-stmt .)
    S_SWITCH        reduce using rule 10 (statement -> if-stmt .)
    E_WAIT          reduce using rule 10 (statement -> if-stmt .)
    S_FOREACH       reduce using rule 10 (statement -> if-stmt .)
    S_FOR           reduce using rule 10 (statement -> if-stmt .)
    S_WHILE         reduce using rule 10 (statement -> if-stmt .)
    S_ITERATE       reduce using rule 10 (statement -> if-stmt .)
    S_ELSE          reduce using rule 10 (statement -> if-stmt .)
    ID              reduce using rule 10 (statement -> if-stmt .)
    C_APP           reduce using rule 10 (statement -> if-stmt .)
    LPAREN          reduce using rule 10 (statement -> if-stmt .)
    class_INT       reduce using rule 10 (statement -> if-stmt .)
    class_DOUBLE    reduce using rule 10 (statement -> if-stmt .)
    class_FLOAT     reduce using rule 10 (statement -> if-stmt .)
    class_VOID      reduce using rule 10 (statement -> if-stmt .)
    class_UINT      reduce using rule 10 (statement -> if-stmt .)
    class_BOOL      reduce using rule 10 (statement -> if-stmt .)
    class_CHARACTER reduce using rule 10 (statement -> if-stmt .)
    class_String    reduce using rule 10 (statement -> if-stmt .)
    collection_SET  reduce using rule 10 (statement -> if-stmt .)
    collection_ARRAY reduce using rule 10 (statement -> if-stmt .)
    collection_DICT reduce using rule 10 (statement -> if-stmt .)
    LESS            reduce using rule 10 (statement -> if-stmt .)
    $end            reduce using rule 10 (statement -> if-stmt .)
    RBRACE          reduce using rule 10 (statement -> if-stmt .)
    S_CASE          reduce using rule 10 (statement -> if-stmt .)
    S_DEFAULT       reduce using rule 10 (statement -> if-stmt .)


state 12

    (11) statement -> switch-stmt .

    SEMICOLON       reduce using rule 11 (statement -> switch-stmt .)
    C_GLOBAL        reduce using rule 11 (statement -> switch-stmt .)
    D_IMPORT        reduce using rule 11 (statement -> switch-stmt .)
    C_PRAGMA        reduce using rule 11 (statement -> switch-stmt .)
    LBRACE          reduce using rule 11 (statement -> switch-stmt .)
    S_IF            reduce using rule 11 (statement -> switch-stmt .)
    S_SWITCH        reduce using rule 11 (statement -> switch-stmt .)
    E_WAIT          reduce using rule 11 (statement -> switch-stmt .)
    S_FOREACH       reduce using rule 11 (statement -> switch-stmt .)
    S_FOR           reduce using rule 11 (statement -> switch-stmt .)
    S_WHILE         reduce using rule 11 (statement -> switch-stmt .)
    S_ITERATE       reduce using rule 11 (statement -> switch-stmt .)
    S_ELSE          reduce using rule 11 (statement -> switch-stmt .)
    ID              reduce using rule 11 (statement -> switch-stmt .)
    C_APP           reduce using rule 11 (statement -> switch-stmt .)
    LPAREN          reduce using rule 11 (statement -> switch-stmt .)
    class_INT       reduce using rule 11 (statement -> switch-stmt .)
    class_DOUBLE    reduce using rule 11 (statement -> switch-stmt .)
    class_FLOAT     reduce using rule 11 (statement -> switch-stmt .)
    class_VOID      reduce using rule 11 (statement -> switch-stmt .)
    class_UINT      reduce using rule 11 (statement -> switch-stmt .)
    class_BOOL      reduce using rule 11 (statement -> switch-stmt .)
    class_CHARACTER reduce using rule 11 (statement -> switch-stmt .)
    class_String    reduce using rule 11 (statement -> switch-stmt .)
    collection_SET  reduce using rule 11 (statement -> switch-stmt .)
    collection_ARRAY reduce using rule 11 (statement -> switch-stmt .)
    collection_DICT reduce using rule 11 (statement -> switch-stmt .)
    LESS            reduce using rule 11 (statement -> switch-stmt .)
    $end            reduce using rule 11 (statement -> switch-stmt .)
    RBRACE          reduce using rule 11 (statement -> switch-stmt .)
    S_CASE          reduce using rule 11 (statement -> switch-stmt .)
    S_DEFAULT       reduce using rule 11 (statement -> switch-stmt .)


state 13

    (12) statement -> wait-stmt .

    SEMICOLON       reduce using rule 12 (statement -> wait-stmt .)
    C_GLOBAL        reduce using rule 12 (statement -> wait-stmt .)
    D_IMPORT        reduce using rule 12 (statement -> wait-stmt .)
    C_PRAGMA        reduce using rule 12 (statement -> wait-stmt .)
    LBRACE          reduce using rule 12 (statement -> wait-stmt .)
    S_IF            reduce using rule 12 (statement -> wait-stmt .)
    S_SWITCH        reduce using rule 12 (statement -> wait-stmt .)
    E_WAIT          reduce using rule 12 (statement -> wait-stmt .)
    S_FOREACH       reduce using rule 12 (statement -> wait-stmt .)
    S_FOR           reduce using rule 12 (statement -> wait-stmt .)
    S_WHILE         reduce using rule 12 (statement -> wait-stmt .)
    S_ITERATE       reduce using rule 12 (statement -> wait-stmt .)
    S_ELSE          reduce using rule 12 (statement -> wait-stmt .)
    ID              reduce using rule 12 (statement -> wait-stmt .)
    C_APP           reduce using rule 12 (statement -> wait-stmt .)
    LPAREN          reduce using rule 12 (statement -> wait-stmt .)
    class_INT       reduce using rule 12 (statement -> wait-stmt .)
    class_DOUBLE    reduce using rule 12 (statement -> wait-stmt .)
    class_FLOAT     reduce using rule 12 (statement -> wait-stmt .)
    class_VOID      reduce using rule 12 (statement -> wait-stmt .)
    class_UINT      reduce using rule 12 (statement -> wait-stmt .)
    class_BOOL      reduce using rule 12 (statement -> wait-stmt .)
    class_CHARACTER reduce using rule 12 (statement -> wait-stmt .)
    class_String    reduce using rule 12 (statement -> wait-stmt .)
    collection_SET  reduce using rule 12 (statement -> wait-stmt .)
    collection_ARRAY reduce using rule 12 (statement -> wait-stmt .)
    collection_DICT reduce using rule 12 (statement -> wait-stmt .)
    LESS            reduce using rule 12 (statement -> wait-stmt .)
    $end            reduce using rule 12 (statement -> wait-stmt .)
    RBRACE          reduce using rule 12 (statement -> wait-stmt .)
    S_CASE          reduce using rule 12 (statement -> wait-stmt .)
    S_DEFAULT       reduce using rule 12 (statement -> wait-stmt .)


state 14

    (13) statement -> foreach-loop .

    SEMICOLON       reduce using rule 13 (statement -> foreach-loop .)
    C_GLOBAL        reduce using rule 13 (statement -> foreach-loop .)
    D_IMPORT        reduce using rule 13 (statement -> foreach-loop .)
    C_PRAGMA        reduce using rule 13 (statement -> foreach-loop .)
    LBRACE          reduce using rule 13 (statement -> foreach-loop .)
    S_IF            reduce using rule 13 (statement -> foreach-loop .)
    S_SWITCH        reduce using rule 13 (statement -> foreach-loop .)
    E_WAIT          reduce using rule 13 (statement -> foreach-loop .)
    S_FOREACH       reduce using rule 13 (statement -> foreach-loop .)
    S_FOR           reduce using rule 13 (statement -> foreach-loop .)
    S_WHILE         reduce using rule 13 (statement -> foreach-loop .)
    S_ITERATE       reduce using rule 13 (statement -> foreach-loop .)
    S_ELSE          reduce using rule 13 (statement -> foreach-loop .)
    ID              reduce using rule 13 (statement -> foreach-loop .)
    C_APP           reduce using rule 13 (statement -> foreach-loop .)
    LPAREN          reduce using rule 13 (statement -> foreach-loop .)
    class_INT       reduce using rule 13 (statement -> foreach-loop .)
    class_DOUBLE    reduce using rule 13 (statement -> foreach-loop .)
    class_FLOAT     reduce using rule 13 (statement -> foreach-loop .)
    class_VOID      reduce using rule 13 (statement -> foreach-loop .)
    class_UINT      reduce using rule 13 (statement -> foreach-loop .)
    class_BOOL      reduce using rule 13 (statement -> foreach-loop .)
    class_CHARACTER reduce using rule 13 (statement -> foreach-loop .)
    class_String    reduce using rule 13 (statement -> foreach-loop .)
    collection_SET  reduce using rule 13 (statement -> foreach-loop .)
    collection_ARRAY reduce using rule 13 (statement -> foreach-loop .)
    collection_DICT reduce using rule 13 (statement -> foreach-loop .)
    LESS            reduce using rule 13 (statement -> foreach-loop .)
    $end            reduce using rule 13 (statement -> foreach-loop .)
    RBRACE          reduce using rule 13 (statement -> foreach-loop .)
    S_CASE          reduce using rule 13 (statement -> foreach-loop .)
    S_DEFAULT       reduce using rule 13 (statement -> foreach-loop .)


state 15

    (14) statement -> for-loop .

    SEMICOLON       reduce using rule 14 (statement -> for-loop .)
    C_GLOBAL        reduce using rule 14 (statement -> for-loop .)
    D_IMPORT        reduce using rule 14 (statement -> for-loop .)
    C_PRAGMA        reduce using rule 14 (statement -> for-loop .)
    LBRACE          reduce using rule 14 (statement -> for-loop .)
    S_IF            reduce using rule 14 (statement -> for-loop .)
    S_SWITCH        reduce using rule 14 (statement -> for-loop .)
    E_WAIT          reduce using rule 14 (statement -> for-loop .)
    S_FOREACH       reduce using rule 14 (statement -> for-loop .)
    S_FOR           reduce using rule 14 (statement -> for-loop .)
    S_WHILE         reduce using rule 14 (statement -> for-loop .)
    S_ITERATE       reduce using rule 14 (statement -> for-loop .)
    S_ELSE          reduce using rule 14 (statement -> for-loop .)
    ID              reduce using rule 14 (statement -> for-loop .)
    C_APP           reduce using rule 14 (statement -> for-loop .)
    LPAREN          reduce using rule 14 (statement -> for-loop .)
    class_INT       reduce using rule 14 (statement -> for-loop .)
    class_DOUBLE    reduce using rule 14 (statement -> for-loop .)
    class_FLOAT     reduce using rule 14 (statement -> for-loop .)
    class_VOID      reduce using rule 14 (statement -> for-loop .)
    class_UINT      reduce using rule 14 (statement -> for-loop .)
    class_BOOL      reduce using rule 14 (statement -> for-loop .)
    class_CHARACTER reduce using rule 14 (statement -> for-loop .)
    class_String    reduce using rule 14 (statement -> for-loop .)
    collection_SET  reduce using rule 14 (statement -> for-loop .)
    collection_ARRAY reduce using rule 14 (statement -> for-loop .)
    collection_DICT reduce using rule 14 (statement -> for-loop .)
    LESS            reduce using rule 14 (statement -> for-loop .)
    $end            reduce using rule 14 (statement -> for-loop .)
    RBRACE          reduce using rule 14 (statement -> for-loop .)
    S_CASE          reduce using rule 14 (statement -> for-loop .)
    S_DEFAULT       reduce using rule 14 (statement -> for-loop .)


state 16

    (15) statement -> var-decl .
    (96) chainable-stmt -> var-decl .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 15 (statement -> var-decl .)
    SEMICOLON       reduce using rule 15 (statement -> var-decl .)
    C_GLOBAL        reduce using rule 15 (statement -> var-decl .)
    D_IMPORT        reduce using rule 15 (statement -> var-decl .)
    C_PRAGMA        reduce using rule 15 (statement -> var-decl .)
    LBRACE          reduce using rule 15 (statement -> var-decl .)
    S_IF            reduce using rule 15 (statement -> var-decl .)
    S_SWITCH        reduce using rule 15 (statement -> var-decl .)
    E_WAIT          reduce using rule 15 (statement -> var-decl .)
    S_FOREACH       reduce using rule 15 (statement -> var-decl .)
    S_FOR           reduce using rule 15 (statement -> var-decl .)
    S_WHILE         reduce using rule 15 (statement -> var-decl .)
    S_ITERATE       reduce using rule 15 (statement -> var-decl .)
    S_ELSE          reduce using rule 15 (statement -> var-decl .)
    ID              reduce using rule 15 (statement -> var-decl .)
    C_APP           reduce using rule 15 (statement -> var-decl .)
    LPAREN          reduce using rule 15 (statement -> var-decl .)
    class_INT       reduce using rule 15 (statement -> var-decl .)
    class_DOUBLE    reduce using rule 15 (statement -> var-decl .)
    class_FLOAT     reduce using rule 15 (statement -> var-decl .)
    class_VOID      reduce using rule 15 (statement -> var-decl .)
    class_UINT      reduce using rule 15 (statement -> var-decl .)
    class_BOOL      reduce using rule 15 (statement -> var-decl .)
    class_CHARACTER reduce using rule 15 (statement -> var-decl .)
    class_String    reduce using rule 15 (statement -> var-decl .)
    collection_SET  reduce using rule 15 (statement -> var-decl .)
    collection_ARRAY reduce using rule 15 (statement -> var-decl .)
    collection_DICT reduce using rule 15 (statement -> var-decl .)
    LESS            reduce using rule 15 (statement -> var-decl .)
    $end            reduce using rule 15 (statement -> var-decl .)
    RBRACE          reduce using rule 15 (statement -> var-decl .)
    S_CASE          reduce using rule 15 (statement -> var-decl .)
    S_DEFAULT       reduce using rule 15 (statement -> var-decl .)
    ARROW           reduce using rule 96 (chainable-stmt -> var-decl .)

  ! SEMICOLON       [ reduce using rule 96 (chainable-stmt -> var-decl .) ]


state 17

    (16) statement -> while-loop .

    SEMICOLON       reduce using rule 16 (statement -> while-loop .)
    C_GLOBAL        reduce using rule 16 (statement -> while-loop .)
    D_IMPORT        reduce using rule 16 (statement -> while-loop .)
    C_PRAGMA        reduce using rule 16 (statement -> while-loop .)
    LBRACE          reduce using rule 16 (statement -> while-loop .)
    S_IF            reduce using rule 16 (statement -> while-loop .)
    S_SWITCH        reduce using rule 16 (statement -> while-loop .)
    E_WAIT          reduce using rule 16 (statement -> while-loop .)
    S_FOREACH       reduce using rule 16 (statement -> while-loop .)
    S_FOR           reduce using rule 16 (statement -> while-loop .)
    S_WHILE         reduce using rule 16 (statement -> while-loop .)
    S_ITERATE       reduce using rule 16 (statement -> while-loop .)
    S_ELSE          reduce using rule 16 (statement -> while-loop .)
    ID              reduce using rule 16 (statement -> while-loop .)
    C_APP           reduce using rule 16 (statement -> while-loop .)
    LPAREN          reduce using rule 16 (statement -> while-loop .)
    class_INT       reduce using rule 16 (statement -> while-loop .)
    class_DOUBLE    reduce using rule 16 (statement -> while-loop .)
    class_FLOAT     reduce using rule 16 (statement -> while-loop .)
    class_VOID      reduce using rule 16 (statement -> while-loop .)
    class_UINT      reduce using rule 16 (statement -> while-loop .)
    class_BOOL      reduce using rule 16 (statement -> while-loop .)
    class_CHARACTER reduce using rule 16 (statement -> while-loop .)
    class_String    reduce using rule 16 (statement -> while-loop .)
    collection_SET  reduce using rule 16 (statement -> while-loop .)
    collection_ARRAY reduce using rule 16 (statement -> while-loop .)
    collection_DICT reduce using rule 16 (statement -> while-loop .)
    LESS            reduce using rule 16 (statement -> while-loop .)
    $end            reduce using rule 16 (statement -> while-loop .)
    RBRACE          reduce using rule 16 (statement -> while-loop .)
    S_CASE          reduce using rule 16 (statement -> while-loop .)
    S_DEFAULT       reduce using rule 16 (statement -> while-loop .)


state 18

    (17) statement -> iterate-loop .

    SEMICOLON       reduce using rule 17 (statement -> iterate-loop .)
    C_GLOBAL        reduce using rule 17 (statement -> iterate-loop .)
    D_IMPORT        reduce using rule 17 (statement -> iterate-loop .)
    C_PRAGMA        reduce using rule 17 (statement -> iterate-loop .)
    LBRACE          reduce using rule 17 (statement -> iterate-loop .)
    S_IF            reduce using rule 17 (statement -> iterate-loop .)
    S_SWITCH        reduce using rule 17 (statement -> iterate-loop .)
    E_WAIT          reduce using rule 17 (statement -> iterate-loop .)
    S_FOREACH       reduce using rule 17 (statement -> iterate-loop .)
    S_FOR           reduce using rule 17 (statement -> iterate-loop .)
    S_WHILE         reduce using rule 17 (statement -> iterate-loop .)
    S_ITERATE       reduce using rule 17 (statement -> iterate-loop .)
    S_ELSE          reduce using rule 17 (statement -> iterate-loop .)
    ID              reduce using rule 17 (statement -> iterate-loop .)
    C_APP           reduce using rule 17 (statement -> iterate-loop .)
    LPAREN          reduce using rule 17 (statement -> iterate-loop .)
    class_INT       reduce using rule 17 (statement -> iterate-loop .)
    class_DOUBLE    reduce using rule 17 (statement -> iterate-loop .)
    class_FLOAT     reduce using rule 17 (statement -> iterate-loop .)
    class_VOID      reduce using rule 17 (statement -> iterate-loop .)
    class_UINT      reduce using rule 17 (statement -> iterate-loop .)
    class_BOOL      reduce using rule 17 (statement -> iterate-loop .)
    class_CHARACTER reduce using rule 17 (statement -> iterate-loop .)
    class_String    reduce using rule 17 (statement -> iterate-loop .)
    collection_SET  reduce using rule 17 (statement -> iterate-loop .)
    collection_ARRAY reduce using rule 17 (statement -> iterate-loop .)
    collection_DICT reduce using rule 17 (statement -> iterate-loop .)
    LESS            reduce using rule 17 (statement -> iterate-loop .)
    $end            reduce using rule 17 (statement -> iterate-loop .)
    RBRACE          reduce using rule 17 (statement -> iterate-loop .)
    S_CASE          reduce using rule 17 (statement -> iterate-loop .)
    S_DEFAULT       reduce using rule 17 (statement -> iterate-loop .)


state 19

    (18) statement -> stmt-chain .

    SEMICOLON       reduce using rule 18 (statement -> stmt-chain .)
    C_GLOBAL        reduce using rule 18 (statement -> stmt-chain .)
    D_IMPORT        reduce using rule 18 (statement -> stmt-chain .)
    C_PRAGMA        reduce using rule 18 (statement -> stmt-chain .)
    LBRACE          reduce using rule 18 (statement -> stmt-chain .)
    S_IF            reduce using rule 18 (statement -> stmt-chain .)
    S_SWITCH        reduce using rule 18 (statement -> stmt-chain .)
    E_WAIT          reduce using rule 18 (statement -> stmt-chain .)
    S_FOREACH       reduce using rule 18 (statement -> stmt-chain .)
    S_FOR           reduce using rule 18 (statement -> stmt-chain .)
    S_WHILE         reduce using rule 18 (statement -> stmt-chain .)
    S_ITERATE       reduce using rule 18 (statement -> stmt-chain .)
    S_ELSE          reduce using rule 18 (statement -> stmt-chain .)
    ID              reduce using rule 18 (statement -> stmt-chain .)
    C_APP           reduce using rule 18 (statement -> stmt-chain .)
    LPAREN          reduce using rule 18 (statement -> stmt-chain .)
    class_INT       reduce using rule 18 (statement -> stmt-chain .)
    class_DOUBLE    reduce using rule 18 (statement -> stmt-chain .)
    class_FLOAT     reduce using rule 18 (statement -> stmt-chain .)
    class_VOID      reduce using rule 18 (statement -> stmt-chain .)
    class_UINT      reduce using rule 18 (statement -> stmt-chain .)
    class_BOOL      reduce using rule 18 (statement -> stmt-chain .)
    class_CHARACTER reduce using rule 18 (statement -> stmt-chain .)
    class_String    reduce using rule 18 (statement -> stmt-chain .)
    collection_SET  reduce using rule 18 (statement -> stmt-chain .)
    collection_ARRAY reduce using rule 18 (statement -> stmt-chain .)
    collection_DICT reduce using rule 18 (statement -> stmt-chain .)
    LESS            reduce using rule 18 (statement -> stmt-chain .)
    $end            reduce using rule 18 (statement -> stmt-chain .)
    RBRACE          reduce using rule 18 (statement -> stmt-chain .)
    S_CASE          reduce using rule 18 (statement -> stmt-chain .)
    S_DEFAULT       reduce using rule 18 (statement -> stmt-chain .)


state 20

    (19) statement -> opt-else-block .

    SEMICOLON       reduce using rule 19 (statement -> opt-else-block .)
    C_GLOBAL        reduce using rule 19 (statement -> opt-else-block .)
    D_IMPORT        reduce using rule 19 (statement -> opt-else-block .)
    C_PRAGMA        reduce using rule 19 (statement -> opt-else-block .)
    LBRACE          reduce using rule 19 (statement -> opt-else-block .)
    S_IF            reduce using rule 19 (statement -> opt-else-block .)
    S_SWITCH        reduce using rule 19 (statement -> opt-else-block .)
    E_WAIT          reduce using rule 19 (statement -> opt-else-block .)
    S_FOREACH       reduce using rule 19 (statement -> opt-else-block .)
    S_FOR           reduce using rule 19 (statement -> opt-else-block .)
    S_WHILE         reduce using rule 19 (statement -> opt-else-block .)
    S_ITERATE       reduce using rule 19 (statement -> opt-else-block .)
    S_ELSE          reduce using rule 19 (statement -> opt-else-block .)
    ID              reduce using rule 19 (statement -> opt-else-block .)
    C_APP           reduce using rule 19 (statement -> opt-else-block .)
    LPAREN          reduce using rule 19 (statement -> opt-else-block .)
    class_INT       reduce using rule 19 (statement -> opt-else-block .)
    class_DOUBLE    reduce using rule 19 (statement -> opt-else-block .)
    class_FLOAT     reduce using rule 19 (statement -> opt-else-block .)
    class_VOID      reduce using rule 19 (statement -> opt-else-block .)
    class_UINT      reduce using rule 19 (statement -> opt-else-block .)
    class_BOOL      reduce using rule 19 (statement -> opt-else-block .)
    class_CHARACTER reduce using rule 19 (statement -> opt-else-block .)
    class_String    reduce using rule 19 (statement -> opt-else-block .)
    collection_SET  reduce using rule 19 (statement -> opt-else-block .)
    collection_ARRAY reduce using rule 19 (statement -> opt-else-block .)
    collection_DICT reduce using rule 19 (statement -> opt-else-block .)
    LESS            reduce using rule 19 (statement -> opt-else-block .)
    $end            reduce using rule 19 (statement -> opt-else-block .)
    RBRACE          reduce using rule 19 (statement -> opt-else-block .)
    S_CASE          reduce using rule 19 (statement -> opt-else-block .)
    S_DEFAULT       reduce using rule 19 (statement -> opt-else-block .)


state 21

    (20) statement -> var-name .
    (105) update-stmt -> var-name . LESS ID GREATER UPD expr SEMICOLON
    (94) chainable-stmt -> var-name .
    (231) lval-expr -> var-name . subscript-star
    (232) subscript-star -> . array-subscript subscript-star
    (233) subscript-star -> . struct-subscript subscript-star
    (234) subscript-star -> . empty
    (169) array-subscript -> . LBRACKET expr RBRACKET
    (170) struct-subscript -> . DOT ID
    (76) empty -> .

  ! shift/reduce conflict for LESS resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 20 (statement -> var-name .)
    SEMICOLON       reduce using rule 20 (statement -> var-name .)
    C_GLOBAL        reduce using rule 20 (statement -> var-name .)
    D_IMPORT        reduce using rule 20 (statement -> var-name .)
    C_PRAGMA        reduce using rule 20 (statement -> var-name .)
    LBRACE          reduce using rule 20 (statement -> var-name .)
    S_IF            reduce using rule 20 (statement -> var-name .)
    S_SWITCH        reduce using rule 20 (statement -> var-name .)
    E_WAIT          reduce using rule 20 (statement -> var-name .)
    S_FOREACH       reduce using rule 20 (statement -> var-name .)
    S_FOR           reduce using rule 20 (statement -> var-name .)
    S_WHILE         reduce using rule 20 (statement -> var-name .)
    S_ITERATE       reduce using rule 20 (statement -> var-name .)
    S_ELSE          reduce using rule 20 (statement -> var-name .)
    ID              reduce using rule 20 (statement -> var-name .)
    C_APP           reduce using rule 20 (statement -> var-name .)
    LPAREN          reduce using rule 20 (statement -> var-name .)
    class_INT       reduce using rule 20 (statement -> var-name .)
    class_DOUBLE    reduce using rule 20 (statement -> var-name .)
    class_FLOAT     reduce using rule 20 (statement -> var-name .)
    class_VOID      reduce using rule 20 (statement -> var-name .)
    class_UINT      reduce using rule 20 (statement -> var-name .)
    class_BOOL      reduce using rule 20 (statement -> var-name .)
    class_CHARACTER reduce using rule 20 (statement -> var-name .)
    class_String    reduce using rule 20 (statement -> var-name .)
    collection_SET  reduce using rule 20 (statement -> var-name .)
    collection_ARRAY reduce using rule 20 (statement -> var-name .)
    collection_DICT reduce using rule 20 (statement -> var-name .)
    $end            reduce using rule 20 (statement -> var-name .)
    RBRACE          reduce using rule 20 (statement -> var-name .)
    S_CASE          reduce using rule 20 (statement -> var-name .)
    S_DEFAULT       reduce using rule 20 (statement -> var-name .)
    LESS            shift and go to state 65
    ARROW           reduce using rule 94 (chainable-stmt -> var-name .)
    LBRACKET        shift and go to state 70
    DOT             shift and go to state 71
    COMMA           reduce using rule 76 (empty -> .)
    ASSIGN          reduce using rule 76 (empty -> .)
    PLUS_AS         reduce using rule 76 (empty -> .)

  ! LESS            [ reduce using rule 20 (statement -> var-name .) ]
  ! SEMICOLON       [ reduce using rule 94 (chainable-stmt -> var-name .) ]

    subscript-star                 shift and go to state 66
    array-subscript                shift and go to state 67
    struct-subscript               shift and go to state 68
    empty                          shift and go to state 69

state 22

    (21) statement -> assignment .
    (97) chainable-stmt -> assignment .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 21 (statement -> assignment .)
    SEMICOLON       reduce using rule 21 (statement -> assignment .)
    C_GLOBAL        reduce using rule 21 (statement -> assignment .)
    D_IMPORT        reduce using rule 21 (statement -> assignment .)
    C_PRAGMA        reduce using rule 21 (statement -> assignment .)
    LBRACE          reduce using rule 21 (statement -> assignment .)
    S_IF            reduce using rule 21 (statement -> assignment .)
    S_SWITCH        reduce using rule 21 (statement -> assignment .)
    E_WAIT          reduce using rule 21 (statement -> assignment .)
    S_FOREACH       reduce using rule 21 (statement -> assignment .)
    S_FOR           reduce using rule 21 (statement -> assignment .)
    S_WHILE         reduce using rule 21 (statement -> assignment .)
    S_ITERATE       reduce using rule 21 (statement -> assignment .)
    S_ELSE          reduce using rule 21 (statement -> assignment .)
    ID              reduce using rule 21 (statement -> assignment .)
    C_APP           reduce using rule 21 (statement -> assignment .)
    LPAREN          reduce using rule 21 (statement -> assignment .)
    class_INT       reduce using rule 21 (statement -> assignment .)
    class_DOUBLE    reduce using rule 21 (statement -> assignment .)
    class_FLOAT     reduce using rule 21 (statement -> assignment .)
    class_VOID      reduce using rule 21 (statement -> assignment .)
    class_UINT      reduce using rule 21 (statement -> assignment .)
    class_BOOL      reduce using rule 21 (statement -> assignment .)
    class_CHARACTER reduce using rule 21 (statement -> assignment .)
    class_String    reduce using rule 21 (statement -> assignment .)
    collection_SET  reduce using rule 21 (statement -> assignment .)
    collection_ARRAY reduce using rule 21 (statement -> assignment .)
    collection_DICT reduce using rule 21 (statement -> assignment .)
    LESS            reduce using rule 21 (statement -> assignment .)
    $end            reduce using rule 21 (statement -> assignment .)
    RBRACE          reduce using rule 21 (statement -> assignment .)
    S_CASE          reduce using rule 21 (statement -> assignment .)
    S_DEFAULT       reduce using rule 21 (statement -> assignment .)
    ARROW           reduce using rule 97 (chainable-stmt -> assignment .)

  ! SEMICOLON       [ reduce using rule 97 (chainable-stmt -> assignment .) ]


state 23

    (22) statement -> func-call .
    (95) chainable-stmt -> func-call .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 22 (statement -> func-call .)
    SEMICOLON       reduce using rule 22 (statement -> func-call .)
    C_GLOBAL        reduce using rule 22 (statement -> func-call .)
    D_IMPORT        reduce using rule 22 (statement -> func-call .)
    C_PRAGMA        reduce using rule 22 (statement -> func-call .)
    LBRACE          reduce using rule 22 (statement -> func-call .)
    S_IF            reduce using rule 22 (statement -> func-call .)
    S_SWITCH        reduce using rule 22 (statement -> func-call .)
    E_WAIT          reduce using rule 22 (statement -> func-call .)
    S_FOREACH       reduce using rule 22 (statement -> func-call .)
    S_FOR           reduce using rule 22 (statement -> func-call .)
    S_WHILE         reduce using rule 22 (statement -> func-call .)
    S_ITERATE       reduce using rule 22 (statement -> func-call .)
    S_ELSE          reduce using rule 22 (statement -> func-call .)
    ID              reduce using rule 22 (statement -> func-call .)
    C_APP           reduce using rule 22 (statement -> func-call .)
    LPAREN          reduce using rule 22 (statement -> func-call .)
    class_INT       reduce using rule 22 (statement -> func-call .)
    class_DOUBLE    reduce using rule 22 (statement -> func-call .)
    class_FLOAT     reduce using rule 22 (statement -> func-call .)
    class_VOID      reduce using rule 22 (statement -> func-call .)
    class_UINT      reduce using rule 22 (statement -> func-call .)
    class_BOOL      reduce using rule 22 (statement -> func-call .)
    class_CHARACTER reduce using rule 22 (statement -> func-call .)
    class_String    reduce using rule 22 (statement -> func-call .)
    collection_SET  reduce using rule 22 (statement -> func-call .)
    collection_ARRAY reduce using rule 22 (statement -> func-call .)
    collection_DICT reduce using rule 22 (statement -> func-call .)
    LESS            reduce using rule 22 (statement -> func-call .)
    $end            reduce using rule 22 (statement -> func-call .)
    RBRACE          reduce using rule 22 (statement -> func-call .)
    S_CASE          reduce using rule 22 (statement -> func-call .)
    S_DEFAULT       reduce using rule 22 (statement -> func-call .)
    ARROW           reduce using rule 95 (chainable-stmt -> func-call .)

  ! SEMICOLON       [ reduce using rule 95 (chainable-stmt -> func-call .) ]


state 24

    (23) statement -> update-stmt .

    SEMICOLON       reduce using rule 23 (statement -> update-stmt .)
    C_GLOBAL        reduce using rule 23 (statement -> update-stmt .)
    D_IMPORT        reduce using rule 23 (statement -> update-stmt .)
    C_PRAGMA        reduce using rule 23 (statement -> update-stmt .)
    LBRACE          reduce using rule 23 (statement -> update-stmt .)
    S_IF            reduce using rule 23 (statement -> update-stmt .)
    S_SWITCH        reduce using rule 23 (statement -> update-stmt .)
    E_WAIT          reduce using rule 23 (statement -> update-stmt .)
    S_FOREACH       reduce using rule 23 (statement -> update-stmt .)
    S_FOR           reduce using rule 23 (statement -> update-stmt .)
    S_WHILE         reduce using rule 23 (statement -> update-stmt .)
    S_ITERATE       reduce using rule 23 (statement -> update-stmt .)
    S_ELSE          reduce using rule 23 (statement -> update-stmt .)
    ID              reduce using rule 23 (statement -> update-stmt .)
    C_APP           reduce using rule 23 (statement -> update-stmt .)
    LPAREN          reduce using rule 23 (statement -> update-stmt .)
    class_INT       reduce using rule 23 (statement -> update-stmt .)
    class_DOUBLE    reduce using rule 23 (statement -> update-stmt .)
    class_FLOAT     reduce using rule 23 (statement -> update-stmt .)
    class_VOID      reduce using rule 23 (statement -> update-stmt .)
    class_UINT      reduce using rule 23 (statement -> update-stmt .)
    class_BOOL      reduce using rule 23 (statement -> update-stmt .)
    class_CHARACTER reduce using rule 23 (statement -> update-stmt .)
    class_String    reduce using rule 23 (statement -> update-stmt .)
    collection_SET  reduce using rule 23 (statement -> update-stmt .)
    collection_ARRAY reduce using rule 23 (statement -> update-stmt .)
    collection_DICT reduce using rule 23 (statement -> update-stmt .)
    LESS            reduce using rule 23 (statement -> update-stmt .)
    $end            reduce using rule 23 (statement -> update-stmt .)
    RBRACE          reduce using rule 23 (statement -> update-stmt .)
    S_CASE          reduce using rule 23 (statement -> update-stmt .)
    S_DEFAULT       reduce using rule 23 (statement -> update-stmt .)


state 25

    (24) global-const-defn -> C_GLOBAL . C_CONST var-decl SEMICOLON

    C_CONST         shift and go to state 72


state 26

    (25) import-stmt -> D_IMPORT . module-path SEMICOLON
    (26) import-stmt -> D_IMPORT . STR_LITERAL SEMICOLON
    (27) module-path -> . ID path-star

    STR_LITERAL     shift and go to state 74
    ID              shift and go to state 75

    module-path                    shift and go to state 73

state 27

    (30) pragma-stmt -> C_PRAGMA . ID expr SEMICOLON

    ID              shift and go to state 76


state 28

    (227) var-name -> ID .
    (177) func-call -> ID . LPAREN func-call-arg-list RPAREN
    (225) type-name -> ID .

  ! shift/reduce conflict for LPAREN resolved as shift
  ! reduce/reduce conflict for LESS resolved using rule 225 (type-name -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 225 (type-name -> ID .)
    LBRACKET        reduce using rule 227 (var-name -> ID .)
    DOT             reduce using rule 227 (var-name -> ID .)
    SEMICOLON       reduce using rule 227 (var-name -> ID .)
    C_GLOBAL        reduce using rule 227 (var-name -> ID .)
    D_IMPORT        reduce using rule 227 (var-name -> ID .)
    C_PRAGMA        reduce using rule 227 (var-name -> ID .)
    LBRACE          reduce using rule 227 (var-name -> ID .)
    S_IF            reduce using rule 227 (var-name -> ID .)
    S_SWITCH        reduce using rule 227 (var-name -> ID .)
    E_WAIT          reduce using rule 227 (var-name -> ID .)
    S_FOREACH       reduce using rule 227 (var-name -> ID .)
    S_FOR           reduce using rule 227 (var-name -> ID .)
    S_WHILE         reduce using rule 227 (var-name -> ID .)
    S_ITERATE       reduce using rule 227 (var-name -> ID .)
    S_ELSE          reduce using rule 227 (var-name -> ID .)
    C_APP           reduce using rule 227 (var-name -> ID .)
    class_INT       reduce using rule 227 (var-name -> ID .)
    class_DOUBLE    reduce using rule 227 (var-name -> ID .)
    class_FLOAT     reduce using rule 227 (var-name -> ID .)
    class_VOID      reduce using rule 227 (var-name -> ID .)
    class_UINT      reduce using rule 227 (var-name -> ID .)
    class_BOOL      reduce using rule 227 (var-name -> ID .)
    class_CHARACTER reduce using rule 227 (var-name -> ID .)
    class_String    reduce using rule 227 (var-name -> ID .)
    collection_SET  reduce using rule 227 (var-name -> ID .)
    collection_ARRAY reduce using rule 227 (var-name -> ID .)
    collection_DICT reduce using rule 227 (var-name -> ID .)
    $end            reduce using rule 227 (var-name -> ID .)
    ARROW           reduce using rule 227 (var-name -> ID .)
    COMMA           reduce using rule 227 (var-name -> ID .)
    ASSIGN          reduce using rule 227 (var-name -> ID .)
    PLUS_AS         reduce using rule 227 (var-name -> ID .)
    RBRACE          reduce using rule 227 (var-name -> ID .)
    S_CASE          reduce using rule 227 (var-name -> ID .)
    S_DEFAULT       reduce using rule 227 (var-name -> ID .)
    LPAREN          shift and go to state 77
    LESS            reduce using rule 225 (type-name -> ID .)
    ID              reduce using rule 225 (type-name -> ID .)

  ! LESS            [ reduce using rule 227 (var-name -> ID .) ]
  ! ID              [ reduce using rule 227 (var-name -> ID .) ]
  ! LPAREN          [ reduce using rule 227 (var-name -> ID .) ]


state 29

    (31) func-defn -> swift-func-defn .

    SEMICOLON       reduce using rule 31 (func-defn -> swift-func-defn .)
    C_GLOBAL        reduce using rule 31 (func-defn -> swift-func-defn .)
    D_IMPORT        reduce using rule 31 (func-defn -> swift-func-defn .)
    C_PRAGMA        reduce using rule 31 (func-defn -> swift-func-defn .)
    LBRACE          reduce using rule 31 (func-defn -> swift-func-defn .)
    S_IF            reduce using rule 31 (func-defn -> swift-func-defn .)
    S_SWITCH        reduce using rule 31 (func-defn -> swift-func-defn .)
    E_WAIT          reduce using rule 31 (func-defn -> swift-func-defn .)
    S_FOREACH       reduce using rule 31 (func-defn -> swift-func-defn .)
    S_FOR           reduce using rule 31 (func-defn -> swift-func-defn .)
    S_WHILE         reduce using rule 31 (func-defn -> swift-func-defn .)
    S_ITERATE       reduce using rule 31 (func-defn -> swift-func-defn .)
    S_ELSE          reduce using rule 31 (func-defn -> swift-func-defn .)
    ID              reduce using rule 31 (func-defn -> swift-func-defn .)
    C_APP           reduce using rule 31 (func-defn -> swift-func-defn .)
    LPAREN          reduce using rule 31 (func-defn -> swift-func-defn .)
    class_INT       reduce using rule 31 (func-defn -> swift-func-defn .)
    class_DOUBLE    reduce using rule 31 (func-defn -> swift-func-defn .)
    class_FLOAT     reduce using rule 31 (func-defn -> swift-func-defn .)
    class_VOID      reduce using rule 31 (func-defn -> swift-func-defn .)
    class_UINT      reduce using rule 31 (func-defn -> swift-func-defn .)
    class_BOOL      reduce using rule 31 (func-defn -> swift-func-defn .)
    class_CHARACTER reduce using rule 31 (func-defn -> swift-func-defn .)
    class_String    reduce using rule 31 (func-defn -> swift-func-defn .)
    collection_SET  reduce using rule 31 (func-defn -> swift-func-defn .)
    collection_ARRAY reduce using rule 31 (func-defn -> swift-func-defn .)
    collection_DICT reduce using rule 31 (func-defn -> swift-func-defn .)
    LESS            reduce using rule 31 (func-defn -> swift-func-defn .)
    $end            reduce using rule 31 (func-defn -> swift-func-defn .)
    RBRACE          reduce using rule 31 (func-defn -> swift-func-defn .)
    S_CASE          reduce using rule 31 (func-defn -> swift-func-defn .)
    S_DEFAULT       reduce using rule 31 (func-defn -> swift-func-defn .)


state 30

    (32) func-defn -> app-func-defn .

    SEMICOLON       reduce using rule 32 (func-defn -> app-func-defn .)
    C_GLOBAL        reduce using rule 32 (func-defn -> app-func-defn .)
    D_IMPORT        reduce using rule 32 (func-defn -> app-func-defn .)
    C_PRAGMA        reduce using rule 32 (func-defn -> app-func-defn .)
    LBRACE          reduce using rule 32 (func-defn -> app-func-defn .)
    S_IF            reduce using rule 32 (func-defn -> app-func-defn .)
    S_SWITCH        reduce using rule 32 (func-defn -> app-func-defn .)
    E_WAIT          reduce using rule 32 (func-defn -> app-func-defn .)
    S_FOREACH       reduce using rule 32 (func-defn -> app-func-defn .)
    S_FOR           reduce using rule 32 (func-defn -> app-func-defn .)
    S_WHILE         reduce using rule 32 (func-defn -> app-func-defn .)
    S_ITERATE       reduce using rule 32 (func-defn -> app-func-defn .)
    S_ELSE          reduce using rule 32 (func-defn -> app-func-defn .)
    ID              reduce using rule 32 (func-defn -> app-func-defn .)
    C_APP           reduce using rule 32 (func-defn -> app-func-defn .)
    LPAREN          reduce using rule 32 (func-defn -> app-func-defn .)
    class_INT       reduce using rule 32 (func-defn -> app-func-defn .)
    class_DOUBLE    reduce using rule 32 (func-defn -> app-func-defn .)
    class_FLOAT     reduce using rule 32 (func-defn -> app-func-defn .)
    class_VOID      reduce using rule 32 (func-defn -> app-func-defn .)
    class_UINT      reduce using rule 32 (func-defn -> app-func-defn .)
    class_BOOL      reduce using rule 32 (func-defn -> app-func-defn .)
    class_CHARACTER reduce using rule 32 (func-defn -> app-func-defn .)
    class_String    reduce using rule 32 (func-defn -> app-func-defn .)
    collection_SET  reduce using rule 32 (func-defn -> app-func-defn .)
    collection_ARRAY reduce using rule 32 (func-defn -> app-func-defn .)
    collection_DICT reduce using rule 32 (func-defn -> app-func-defn .)
    LESS            reduce using rule 32 (func-defn -> app-func-defn .)
    $end            reduce using rule 32 (func-defn -> app-func-defn .)
    RBRACE          reduce using rule 32 (func-defn -> app-func-defn .)
    S_CASE          reduce using rule 32 (func-defn -> app-func-defn .)
    S_DEFAULT       reduce using rule 32 (func-defn -> app-func-defn .)


state 31

    (33) func-defn -> foreign-func-defn .

    SEMICOLON       reduce using rule 33 (func-defn -> foreign-func-defn .)
    C_GLOBAL        reduce using rule 33 (func-defn -> foreign-func-defn .)
    D_IMPORT        reduce using rule 33 (func-defn -> foreign-func-defn .)
    C_PRAGMA        reduce using rule 33 (func-defn -> foreign-func-defn .)
    LBRACE          reduce using rule 33 (func-defn -> foreign-func-defn .)
    S_IF            reduce using rule 33 (func-defn -> foreign-func-defn .)
    S_SWITCH        reduce using rule 33 (func-defn -> foreign-func-defn .)
    E_WAIT          reduce using rule 33 (func-defn -> foreign-func-defn .)
    S_FOREACH       reduce using rule 33 (func-defn -> foreign-func-defn .)
    S_FOR           reduce using rule 33 (func-defn -> foreign-func-defn .)
    S_WHILE         reduce using rule 33 (func-defn -> foreign-func-defn .)
    S_ITERATE       reduce using rule 33 (func-defn -> foreign-func-defn .)
    S_ELSE          reduce using rule 33 (func-defn -> foreign-func-defn .)
    ID              reduce using rule 33 (func-defn -> foreign-func-defn .)
    C_APP           reduce using rule 33 (func-defn -> foreign-func-defn .)
    LPAREN          reduce using rule 33 (func-defn -> foreign-func-defn .)
    class_INT       reduce using rule 33 (func-defn -> foreign-func-defn .)
    class_DOUBLE    reduce using rule 33 (func-defn -> foreign-func-defn .)
    class_FLOAT     reduce using rule 33 (func-defn -> foreign-func-defn .)
    class_VOID      reduce using rule 33 (func-defn -> foreign-func-defn .)
    class_UINT      reduce using rule 33 (func-defn -> foreign-func-defn .)
    class_BOOL      reduce using rule 33 (func-defn -> foreign-func-defn .)
    class_CHARACTER reduce using rule 33 (func-defn -> foreign-func-defn .)
    class_String    reduce using rule 33 (func-defn -> foreign-func-defn .)
    collection_SET  reduce using rule 33 (func-defn -> foreign-func-defn .)
    collection_ARRAY reduce using rule 33 (func-defn -> foreign-func-defn .)
    collection_DICT reduce using rule 33 (func-defn -> foreign-func-defn .)
    LESS            reduce using rule 33 (func-defn -> foreign-func-defn .)
    $end            reduce using rule 33 (func-defn -> foreign-func-defn .)
    RBRACE          reduce using rule 33 (func-defn -> foreign-func-defn .)
    S_CASE          reduce using rule 33 (func-defn -> foreign-func-defn .)
    S_DEFAULT       reduce using rule 33 (func-defn -> foreign-func-defn .)


state 32

    (90) block -> LBRACE . translation-unit RBRACE
    (1) translation-unit -> . statement-star
    (2) statement-star -> . statement statement-star
    (3) statement-star -> . empty
    (4) statement -> . SEMICOLON
    (5) statement -> . global-const-defn
    (6) statement -> . import-stmt
    (7) statement -> . pragma-stmt
    (8) statement -> . func-defn
    (9) statement -> . block
    (10) statement -> . if-stmt
    (11) statement -> . switch-stmt
    (12) statement -> . wait-stmt
    (13) statement -> . foreach-loop
    (14) statement -> . for-loop
    (15) statement -> . var-decl
    (16) statement -> . while-loop
    (17) statement -> . iterate-loop
    (18) statement -> . stmt-chain
    (19) statement -> . opt-else-block
    (20) statement -> . var-name
    (21) statement -> . assignment
    (22) statement -> . func-call
    (23) statement -> . update-stmt
    (76) empty -> .
    (24) global-const-defn -> . C_GLOBAL C_CONST var-decl SEMICOLON
    (25) import-stmt -> . D_IMPORT module-path SEMICOLON
    (26) import-stmt -> . D_IMPORT STR_LITERAL SEMICOLON
    (30) pragma-stmt -> . C_PRAGMA ID expr SEMICOLON
    (31) func-defn -> . swift-func-defn
    (32) func-defn -> . app-func-defn
    (33) func-defn -> . foreign-func-defn
    (90) block -> . LBRACE translation-unit RBRACE
    (106) if-stmt -> . S_IF LPAREN expr RPAREN block opt-else-block
    (109) switch-stmt -> . S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE
    (116) wait-stmt -> . E_WAIT opt-deep LPAREN expr-list RPAREN block
    (119) foreach-loop -> . S_FOREACH var-name opt-comma-var-name S_IN expr block
    (122) for-loop -> . S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
    (72) var-decl -> . type-prefix var-decl-rest
    (123) while-loop -> . S_WHILE LPAREN expr RPAREN block
    (133) iterate-loop -> . S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN
    (91) stmt-chain -> . chainable-stmt semicolon-or-arrow statement
    (107) opt-else-block -> . S_ELSE block
    (108) opt-else-block -> . empty
    (227) var-name -> . ID
    (98) assignment -> . lval-or-paren-lval assign-or-plusas expr-list
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (105) update-stmt -> . var-name LESS ID GREATER UPD expr SEMICOLON
    (52) swift-func-defn -> . func-hdr ARROW block
    (53) app-func-defn -> . C_APP func-hdr LBRACE app-body RBRACE
    (64) foreign-func-defn -> . func-hdr foreign-func-body
    (81) type-prefix -> . type-name
    (82) type-prefix -> . param-type
    (94) chainable-stmt -> . var-name
    (95) chainable-stmt -> . func-call
    (96) chainable-stmt -> . var-decl
    (97) chainable-stmt -> . assignment
    (103) lval-or-paren-lval -> . lval-list
    (104) lval-or-paren-lval -> . LPAREN lval-list RPAREN
    (34) func-hdr -> . type-params formal-arg-list ID empty-or-arg-list
    (214) type-name -> . class_INT
    (215) type-name -> . class_DOUBLE
    (216) type-name -> . class_FLOAT
    (217) type-name -> . class_VOID
    (218) type-name -> . class_UINT
    (219) type-name -> . class_BOOL
    (220) type-name -> . class_CHARACTER
    (221) type-name -> . class_String
    (222) type-name -> . collection_SET
    (223) type-name -> . collection_ARRAY
    (224) type-name -> . collection_DICT
    (225) type-name -> . ID
    (83) param-type -> . type-name LESS standalone-type GREATER
    (228) lval-list -> . lval-expr lval-expr-star
    (37) type-params -> . LESS var-name comma-name-star GREATER
    (38) type-params -> . empty
    (231) lval-expr -> . var-name subscript-star

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for C_GLOBAL resolved as shift
  ! shift/reduce conflict for D_IMPORT resolved as shift
  ! shift/reduce conflict for C_PRAGMA resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for S_IF resolved as shift
  ! shift/reduce conflict for S_SWITCH resolved as shift
  ! shift/reduce conflict for E_WAIT resolved as shift
  ! shift/reduce conflict for S_FOREACH resolved as shift
  ! shift/reduce conflict for S_FOR resolved as shift
  ! shift/reduce conflict for S_WHILE resolved as shift
  ! shift/reduce conflict for S_ITERATE resolved as shift
  ! shift/reduce conflict for S_ELSE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for C_APP resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for class_INT resolved as shift
  ! shift/reduce conflict for class_DOUBLE resolved as shift
  ! shift/reduce conflict for class_FLOAT resolved as shift
  ! shift/reduce conflict for class_VOID resolved as shift
  ! shift/reduce conflict for class_UINT resolved as shift
  ! shift/reduce conflict for class_BOOL resolved as shift
  ! shift/reduce conflict for class_CHARACTER resolved as shift
  ! shift/reduce conflict for class_String resolved as shift
  ! shift/reduce conflict for collection_SET resolved as shift
  ! shift/reduce conflict for collection_ARRAY resolved as shift
  ! shift/reduce conflict for collection_DICT resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
    SEMICOLON       shift and go to state 5
    RBRACE          reduce using rule 76 (empty -> .)
    C_GLOBAL        shift and go to state 25
    D_IMPORT        shift and go to state 26
    C_PRAGMA        shift and go to state 27
    LBRACE          shift and go to state 32
    S_IF            shift and go to state 33
    S_SWITCH        shift and go to state 35
    E_WAIT          shift and go to state 36
    S_FOREACH       shift and go to state 37
    S_FOR           shift and go to state 38
    S_WHILE         shift and go to state 40
    S_ITERATE       shift and go to state 41
    S_ELSE          shift and go to state 43
    ID              shift and go to state 28
    C_APP           shift and go to state 47
    LPAREN          shift and go to state 34
    class_INT       shift and go to state 52
    class_DOUBLE    shift and go to state 53
    class_FLOAT     shift and go to state 54
    class_VOID      shift and go to state 55
    class_UINT      shift and go to state 56
    class_BOOL      shift and go to state 57
    class_CHARACTER shift and go to state 58
    class_String    shift and go to state 59
    collection_SET  shift and go to state 60
    collection_ARRAY shift and go to state 61
    collection_DICT shift and go to state 62
    LESS            shift and go to state 45

  ! SEMICOLON       [ reduce using rule 76 (empty -> .) ]
  ! C_GLOBAL        [ reduce using rule 76 (empty -> .) ]
  ! D_IMPORT        [ reduce using rule 76 (empty -> .) ]
  ! C_PRAGMA        [ reduce using rule 76 (empty -> .) ]
  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! S_IF            [ reduce using rule 76 (empty -> .) ]
  ! S_SWITCH        [ reduce using rule 76 (empty -> .) ]
  ! E_WAIT          [ reduce using rule 76 (empty -> .) ]
  ! S_FOREACH       [ reduce using rule 76 (empty -> .) ]
  ! S_FOR           [ reduce using rule 76 (empty -> .) ]
  ! S_WHILE         [ reduce using rule 76 (empty -> .) ]
  ! S_ITERATE       [ reduce using rule 76 (empty -> .) ]
  ! S_ELSE          [ reduce using rule 76 (empty -> .) ]
  ! ID              [ reduce using rule 76 (empty -> .) ]
  ! C_APP           [ reduce using rule 76 (empty -> .) ]
  ! LPAREN          [ reduce using rule 76 (empty -> .) ]
  ! class_INT       [ reduce using rule 76 (empty -> .) ]
  ! class_DOUBLE    [ reduce using rule 76 (empty -> .) ]
  ! class_FLOAT     [ reduce using rule 76 (empty -> .) ]
  ! class_VOID      [ reduce using rule 76 (empty -> .) ]
  ! class_UINT      [ reduce using rule 76 (empty -> .) ]
  ! class_BOOL      [ reduce using rule 76 (empty -> .) ]
  ! class_CHARACTER [ reduce using rule 76 (empty -> .) ]
  ! class_String    [ reduce using rule 76 (empty -> .) ]
  ! collection_SET  [ reduce using rule 76 (empty -> .) ]
  ! collection_ARRAY [ reduce using rule 76 (empty -> .) ]
  ! collection_DICT [ reduce using rule 76 (empty -> .) ]
  ! LESS            [ reduce using rule 76 (empty -> .) ]

    translation-unit               shift and go to state 78
    statement-star                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    global-const-defn              shift and go to state 6
    import-stmt                    shift and go to state 7
    pragma-stmt                    shift and go to state 8
    func-defn                      shift and go to state 9
    block                          shift and go to state 10
    if-stmt                        shift and go to state 11
    switch-stmt                    shift and go to state 12
    wait-stmt                      shift and go to state 13
    foreach-loop                   shift and go to state 14
    for-loop                       shift and go to state 15
    var-decl                       shift and go to state 16
    while-loop                     shift and go to state 17
    iterate-loop                   shift and go to state 18
    stmt-chain                     shift and go to state 19
    opt-else-block                 shift and go to state 20
    var-name                       shift and go to state 21
    assignment                     shift and go to state 22
    func-call                      shift and go to state 23
    update-stmt                    shift and go to state 24
    swift-func-defn                shift and go to state 29
    app-func-defn                  shift and go to state 30
    foreign-func-defn              shift and go to state 31
    type-prefix                    shift and go to state 39
    chainable-stmt                 shift and go to state 42
    lval-or-paren-lval             shift and go to state 44
    func-hdr                       shift and go to state 46
    type-name                      shift and go to state 48
    param-type                     shift and go to state 49
    lval-list                      shift and go to state 50
    type-params                    shift and go to state 51
    lval-expr                      shift and go to state 63

state 33

    (106) if-stmt -> S_IF . LPAREN expr RPAREN block opt-else-block

    LPAREN          shift and go to state 79


state 34

    (104) lval-or-paren-lval -> LPAREN . lval-list RPAREN
    (228) lval-list -> . lval-expr lval-expr-star
    (231) lval-expr -> . var-name subscript-star
    (227) var-name -> . ID

    ID              shift and go to state 82

    lval-list                      shift and go to state 80
    lval-expr                      shift and go to state 63
    var-name                       shift and go to state 81

state 35

    (109) switch-stmt -> S_SWITCH . LPAREN expr RPAREN LBRACE case-star opt-default RBRACE

    LPAREN          shift and go to state 83


state 36

    (116) wait-stmt -> E_WAIT . opt-deep LPAREN expr-list RPAREN block
    (117) opt-deep -> . E_DEEP
    (118) opt-deep -> . empty
    (76) empty -> .

    E_DEEP          shift and go to state 85
    LPAREN          reduce using rule 76 (empty -> .)

    opt-deep                       shift and go to state 84
    empty                          shift and go to state 86

state 37

    (119) foreach-loop -> S_FOREACH . var-name opt-comma-var-name S_IN expr block
    (227) var-name -> . ID

    ID              shift and go to state 82

    var-name                       shift and go to state 87

state 38

    (122) for-loop -> S_FOR . LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block

    LPAREN          shift and go to state 88


state 39

    (72) var-decl -> type-prefix . var-decl-rest
    (75) var-decl-rest -> . var-name type-suffix empty-or-var-mapping empty-or-assign-expr
    (227) var-name -> . ID

    ID              shift and go to state 82

    var-decl-rest                  shift and go to state 89
    var-name                       shift and go to state 90

state 40

    (123) while-loop -> S_WHILE . LPAREN expr RPAREN block

    LPAREN          shift and go to state 91


state 41

    (133) iterate-loop -> S_ITERATE . var-name block S_UNTIL LPAREN expr RPAREN
    (227) var-name -> . ID

    ID              shift and go to state 82

    var-name                       shift and go to state 92

state 42

    (91) stmt-chain -> chainable-stmt . semicolon-or-arrow statement
    (92) semicolon-or-arrow -> . SEMICOLON
    (93) semicolon-or-arrow -> . ARROW

    SEMICOLON       shift and go to state 94
    ARROW           shift and go to state 95

    semicolon-or-arrow             shift and go to state 93

state 43

    (107) opt-else-block -> S_ELSE . block
    (90) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 96

state 44

    (98) assignment -> lval-or-paren-lval . assign-or-plusas expr-list
    (101) assign-or-plusas -> . ASSIGN
    (102) assign-or-plusas -> . PLUS_AS

    ASSIGN          shift and go to state 98
    PLUS_AS         shift and go to state 99

    assign-or-plusas               shift and go to state 97

state 45

    (37) type-params -> LESS . var-name comma-name-star GREATER
    (227) var-name -> . ID

    ID              shift and go to state 82

    var-name                       shift and go to state 100

state 46

    (52) swift-func-defn -> func-hdr . ARROW block
    (64) foreign-func-defn -> func-hdr . foreign-func-body
    (65) foreign-func-body -> . STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals

    ARROW           shift and go to state 101
    STR_LITERAL     shift and go to state 103

    foreign-func-body              shift and go to state 102

state 47

    (53) app-func-defn -> C_APP . func-hdr LBRACE app-body RBRACE
    (34) func-hdr -> . type-params formal-arg-list ID empty-or-arg-list
    (37) type-params -> . LESS var-name comma-name-star GREATER
    (38) type-params -> . empty
    (76) empty -> .

    LESS            shift and go to state 45
    LPAREN          reduce using rule 76 (empty -> .)
    ID              reduce using rule 76 (empty -> .)

    func-hdr                       shift and go to state 104
    type-params                    shift and go to state 51
    empty                          shift and go to state 105

state 48

    (81) type-prefix -> type-name .
    (83) param-type -> type-name . LESS standalone-type GREATER

    ID              reduce using rule 81 (type-prefix -> type-name .)
    LBRACKET        reduce using rule 81 (type-prefix -> type-name .)
    GREATER         reduce using rule 81 (type-prefix -> type-name .)
    RANGE           reduce using rule 81 (type-prefix -> type-name .)
    RBRACKET        reduce using rule 81 (type-prefix -> type-name .)
    LESS            shift and go to state 106


state 49

    (82) type-prefix -> param-type .

    ID              reduce using rule 82 (type-prefix -> param-type .)
    LBRACKET        reduce using rule 82 (type-prefix -> param-type .)
    GREATER         reduce using rule 82 (type-prefix -> param-type .)
    RANGE           reduce using rule 82 (type-prefix -> param-type .)
    RBRACKET        reduce using rule 82 (type-prefix -> param-type .)


state 50

    (103) lval-or-paren-lval -> lval-list .

    ASSIGN          reduce using rule 103 (lval-or-paren-lval -> lval-list .)
    PLUS_AS         reduce using rule 103 (lval-or-paren-lval -> lval-list .)


state 51

    (34) func-hdr -> type-params . formal-arg-list ID empty-or-arg-list
    (41) formal-arg-list -> . LPAREN opt-formal-args RPAREN
    (42) formal-arg-list -> . empty
    (76) empty -> .

    LPAREN          shift and go to state 108
    ID              reduce using rule 76 (empty -> .)

    formal-arg-list                shift and go to state 107
    empty                          shift and go to state 109

state 52

    (214) type-name -> class_INT .

    LESS            reduce using rule 214 (type-name -> class_INT .)
    ID              reduce using rule 214 (type-name -> class_INT .)
    LBRACKET        reduce using rule 214 (type-name -> class_INT .)
    GREATER         reduce using rule 214 (type-name -> class_INT .)
    RANGE           reduce using rule 214 (type-name -> class_INT .)
    RBRACKET        reduce using rule 214 (type-name -> class_INT .)


state 53

    (215) type-name -> class_DOUBLE .

    LESS            reduce using rule 215 (type-name -> class_DOUBLE .)
    ID              reduce using rule 215 (type-name -> class_DOUBLE .)
    LBRACKET        reduce using rule 215 (type-name -> class_DOUBLE .)
    GREATER         reduce using rule 215 (type-name -> class_DOUBLE .)
    RANGE           reduce using rule 215 (type-name -> class_DOUBLE .)
    RBRACKET        reduce using rule 215 (type-name -> class_DOUBLE .)


state 54

    (216) type-name -> class_FLOAT .

    LESS            reduce using rule 216 (type-name -> class_FLOAT .)
    ID              reduce using rule 216 (type-name -> class_FLOAT .)
    LBRACKET        reduce using rule 216 (type-name -> class_FLOAT .)
    GREATER         reduce using rule 216 (type-name -> class_FLOAT .)
    RANGE           reduce using rule 216 (type-name -> class_FLOAT .)
    RBRACKET        reduce using rule 216 (type-name -> class_FLOAT .)


state 55

    (217) type-name -> class_VOID .

    LESS            reduce using rule 217 (type-name -> class_VOID .)
    ID              reduce using rule 217 (type-name -> class_VOID .)
    LBRACKET        reduce using rule 217 (type-name -> class_VOID .)
    GREATER         reduce using rule 217 (type-name -> class_VOID .)
    RANGE           reduce using rule 217 (type-name -> class_VOID .)
    RBRACKET        reduce using rule 217 (type-name -> class_VOID .)


state 56

    (218) type-name -> class_UINT .

    LESS            reduce using rule 218 (type-name -> class_UINT .)
    ID              reduce using rule 218 (type-name -> class_UINT .)
    LBRACKET        reduce using rule 218 (type-name -> class_UINT .)
    GREATER         reduce using rule 218 (type-name -> class_UINT .)
    RANGE           reduce using rule 218 (type-name -> class_UINT .)
    RBRACKET        reduce using rule 218 (type-name -> class_UINT .)


state 57

    (219) type-name -> class_BOOL .

    LESS            reduce using rule 219 (type-name -> class_BOOL .)
    ID              reduce using rule 219 (type-name -> class_BOOL .)
    LBRACKET        reduce using rule 219 (type-name -> class_BOOL .)
    GREATER         reduce using rule 219 (type-name -> class_BOOL .)
    RANGE           reduce using rule 219 (type-name -> class_BOOL .)
    RBRACKET        reduce using rule 219 (type-name -> class_BOOL .)


state 58

    (220) type-name -> class_CHARACTER .

    LESS            reduce using rule 220 (type-name -> class_CHARACTER .)
    ID              reduce using rule 220 (type-name -> class_CHARACTER .)
    LBRACKET        reduce using rule 220 (type-name -> class_CHARACTER .)
    GREATER         reduce using rule 220 (type-name -> class_CHARACTER .)
    RANGE           reduce using rule 220 (type-name -> class_CHARACTER .)
    RBRACKET        reduce using rule 220 (type-name -> class_CHARACTER .)


state 59

    (221) type-name -> class_String .

    LESS            reduce using rule 221 (type-name -> class_String .)
    ID              reduce using rule 221 (type-name -> class_String .)
    LBRACKET        reduce using rule 221 (type-name -> class_String .)
    GREATER         reduce using rule 221 (type-name -> class_String .)
    RANGE           reduce using rule 221 (type-name -> class_String .)
    RBRACKET        reduce using rule 221 (type-name -> class_String .)


state 60

    (222) type-name -> collection_SET .

    LESS            reduce using rule 222 (type-name -> collection_SET .)
    ID              reduce using rule 222 (type-name -> collection_SET .)
    LBRACKET        reduce using rule 222 (type-name -> collection_SET .)
    GREATER         reduce using rule 222 (type-name -> collection_SET .)
    RANGE           reduce using rule 222 (type-name -> collection_SET .)
    RBRACKET        reduce using rule 222 (type-name -> collection_SET .)


state 61

    (223) type-name -> collection_ARRAY .

    LESS            reduce using rule 223 (type-name -> collection_ARRAY .)
    ID              reduce using rule 223 (type-name -> collection_ARRAY .)
    LBRACKET        reduce using rule 223 (type-name -> collection_ARRAY .)
    GREATER         reduce using rule 223 (type-name -> collection_ARRAY .)
    RANGE           reduce using rule 223 (type-name -> collection_ARRAY .)
    RBRACKET        reduce using rule 223 (type-name -> collection_ARRAY .)


state 62

    (224) type-name -> collection_DICT .

    LESS            reduce using rule 224 (type-name -> collection_DICT .)
    ID              reduce using rule 224 (type-name -> collection_DICT .)
    LBRACKET        reduce using rule 224 (type-name -> collection_DICT .)
    GREATER         reduce using rule 224 (type-name -> collection_DICT .)
    RANGE           reduce using rule 224 (type-name -> collection_DICT .)
    RBRACKET        reduce using rule 224 (type-name -> collection_DICT .)


state 63

    (228) lval-list -> lval-expr . lval-expr-star
    (229) lval-expr-star -> . COMMA lval-expr lval-expr-star
    (230) lval-expr-star -> .

    COMMA           shift and go to state 111
    ASSIGN          reduce using rule 230 (lval-expr-star -> .)
    PLUS_AS         reduce using rule 230 (lval-expr-star -> .)
    RPAREN          reduce using rule 230 (lval-expr-star -> .)

    lval-expr-star                 shift and go to state 110

state 64

    (2) statement-star -> statement statement-star .

    $end            reduce using rule 2 (statement-star -> statement statement-star .)
    RBRACE          reduce using rule 2 (statement-star -> statement statement-star .)
    S_CASE          reduce using rule 2 (statement-star -> statement statement-star .)
    S_DEFAULT       reduce using rule 2 (statement-star -> statement statement-star .)


state 65

    (105) update-stmt -> var-name LESS . ID GREATER UPD expr SEMICOLON

    ID              shift and go to state 112


state 66

    (231) lval-expr -> var-name subscript-star .

    COMMA           reduce using rule 231 (lval-expr -> var-name subscript-star .)
    ASSIGN          reduce using rule 231 (lval-expr -> var-name subscript-star .)
    PLUS_AS         reduce using rule 231 (lval-expr -> var-name subscript-star .)
    RPAREN          reduce using rule 231 (lval-expr -> var-name subscript-star .)


state 67

    (232) subscript-star -> array-subscript . subscript-star
    (232) subscript-star -> . array-subscript subscript-star
    (233) subscript-star -> . struct-subscript subscript-star
    (234) subscript-star -> . empty
    (169) array-subscript -> . LBRACKET expr RBRACKET
    (170) struct-subscript -> . DOT ID
    (76) empty -> .

    LBRACKET        shift and go to state 70
    DOT             shift and go to state 71
    COMMA           reduce using rule 76 (empty -> .)
    ASSIGN          reduce using rule 76 (empty -> .)
    PLUS_AS         reduce using rule 76 (empty -> .)
    RPAREN          reduce using rule 76 (empty -> .)

    array-subscript                shift and go to state 67
    subscript-star                 shift and go to state 113
    struct-subscript               shift and go to state 68
    empty                          shift and go to state 69

state 68

    (233) subscript-star -> struct-subscript . subscript-star
    (232) subscript-star -> . array-subscript subscript-star
    (233) subscript-star -> . struct-subscript subscript-star
    (234) subscript-star -> . empty
    (169) array-subscript -> . LBRACKET expr RBRACKET
    (170) struct-subscript -> . DOT ID
    (76) empty -> .

    LBRACKET        shift and go to state 70
    DOT             shift and go to state 71
    COMMA           reduce using rule 76 (empty -> .)
    ASSIGN          reduce using rule 76 (empty -> .)
    PLUS_AS         reduce using rule 76 (empty -> .)
    RPAREN          reduce using rule 76 (empty -> .)

    struct-subscript               shift and go to state 68
    subscript-star                 shift and go to state 114
    array-subscript                shift and go to state 67
    empty                          shift and go to state 69

state 69

    (234) subscript-star -> empty .

    COMMA           reduce using rule 234 (subscript-star -> empty .)
    ASSIGN          reduce using rule 234 (subscript-star -> empty .)
    PLUS_AS         reduce using rule 234 (subscript-star -> empty .)
    RPAREN          reduce using rule 234 (subscript-star -> empty .)


state 70

    (169) array-subscript -> LBRACKET . expr RBRACKET
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 116
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 71

    (170) struct-subscript -> DOT . ID

    ID              shift and go to state 150


state 72

    (24) global-const-defn -> C_GLOBAL C_CONST . var-decl SEMICOLON
    (72) var-decl -> . type-prefix var-decl-rest
    (81) type-prefix -> . type-name
    (82) type-prefix -> . param-type
    (214) type-name -> . class_INT
    (215) type-name -> . class_DOUBLE
    (216) type-name -> . class_FLOAT
    (217) type-name -> . class_VOID
    (218) type-name -> . class_UINT
    (219) type-name -> . class_BOOL
    (220) type-name -> . class_CHARACTER
    (221) type-name -> . class_String
    (222) type-name -> . collection_SET
    (223) type-name -> . collection_ARRAY
    (224) type-name -> . collection_DICT
    (225) type-name -> . ID
    (83) param-type -> . type-name LESS standalone-type GREATER

    class_INT       shift and go to state 52
    class_DOUBLE    shift and go to state 53
    class_FLOAT     shift and go to state 54
    class_VOID      shift and go to state 55
    class_UINT      shift and go to state 56
    class_BOOL      shift and go to state 57
    class_CHARACTER shift and go to state 58
    class_String    shift and go to state 59
    collection_SET  shift and go to state 60
    collection_ARRAY shift and go to state 61
    collection_DICT shift and go to state 62
    ID              shift and go to state 152

    var-decl                       shift and go to state 151
    type-prefix                    shift and go to state 39
    type-name                      shift and go to state 48
    param-type                     shift and go to state 49

state 73

    (25) import-stmt -> D_IMPORT module-path . SEMICOLON

    SEMICOLON       shift and go to state 153


state 74

    (26) import-stmt -> D_IMPORT STR_LITERAL . SEMICOLON

    SEMICOLON       shift and go to state 154


state 75

    (27) module-path -> ID . path-star
    (28) path-star -> . DOT ID path-star
    (29) path-star -> .

    DOT             shift and go to state 156
    SEMICOLON       reduce using rule 29 (path-star -> .)

    path-star                      shift and go to state 155

state 76

    (30) pragma-stmt -> C_PRAGMA ID . expr SEMICOLON
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 157
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 77

    (177) func-call -> ID LPAREN . func-call-arg-list RPAREN
    (178) func-call-arg-list -> . expr-or-kw func-call-arg-star
    (181) expr-or-kw -> . expr
    (182) expr-or-kw -> . kw-expr
    (183) expr-or-kw -> . empty
    (134) expr -> . or-expr
    (202) kw-expr -> . ID ASSIGN expr
    (76) empty -> .
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    ID              shift and go to state 158
    COMMA           reduce using rule 76 (empty -> .)
    RPAREN          reduce using rule 76 (empty -> .)
    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    func-call-arg-list             shift and go to state 159
    expr-or-kw                     shift and go to state 160
    expr                           shift and go to state 161
    kw-expr                        shift and go to state 162
    empty                          shift and go to state 163
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 78

    (90) block -> LBRACE translation-unit . RBRACE

    RBRACE          shift and go to state 164


state 79

    (106) if-stmt -> S_IF LPAREN . expr RPAREN block opt-else-block
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 165
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 80

    (104) lval-or-paren-lval -> LPAREN lval-list . RPAREN

    RPAREN          shift and go to state 166


state 81

    (231) lval-expr -> var-name . subscript-star
    (232) subscript-star -> . array-subscript subscript-star
    (233) subscript-star -> . struct-subscript subscript-star
    (234) subscript-star -> . empty
    (169) array-subscript -> . LBRACKET expr RBRACKET
    (170) struct-subscript -> . DOT ID
    (76) empty -> .

    LBRACKET        shift and go to state 70
    DOT             shift and go to state 71
    COMMA           reduce using rule 76 (empty -> .)
    RPAREN          reduce using rule 76 (empty -> .)
    ASSIGN          reduce using rule 76 (empty -> .)
    PLUS_AS         reduce using rule 76 (empty -> .)

    subscript-star                 shift and go to state 66
    array-subscript                shift and go to state 67
    struct-subscript               shift and go to state 68
    empty                          shift and go to state 69

state 82

    (227) var-name -> ID .

    LBRACKET        reduce using rule 227 (var-name -> ID .)
    DOT             reduce using rule 227 (var-name -> ID .)
    COMMA           reduce using rule 227 (var-name -> ID .)
    RPAREN          reduce using rule 227 (var-name -> ID .)
    S_IN            reduce using rule 227 (var-name -> ID .)
    LESS            reduce using rule 227 (var-name -> ID .)
    ASSIGN          reduce using rule 227 (var-name -> ID .)
    SEMICOLON       reduce using rule 227 (var-name -> ID .)
    C_GLOBAL        reduce using rule 227 (var-name -> ID .)
    D_IMPORT        reduce using rule 227 (var-name -> ID .)
    C_PRAGMA        reduce using rule 227 (var-name -> ID .)
    LBRACE          reduce using rule 227 (var-name -> ID .)
    S_IF            reduce using rule 227 (var-name -> ID .)
    S_SWITCH        reduce using rule 227 (var-name -> ID .)
    E_WAIT          reduce using rule 227 (var-name -> ID .)
    S_FOREACH       reduce using rule 227 (var-name -> ID .)
    S_FOR           reduce using rule 227 (var-name -> ID .)
    S_WHILE         reduce using rule 227 (var-name -> ID .)
    S_ITERATE       reduce using rule 227 (var-name -> ID .)
    S_ELSE          reduce using rule 227 (var-name -> ID .)
    ID              reduce using rule 227 (var-name -> ID .)
    C_APP           reduce using rule 227 (var-name -> ID .)
    LPAREN          reduce using rule 227 (var-name -> ID .)
    class_INT       reduce using rule 227 (var-name -> ID .)
    class_DOUBLE    reduce using rule 227 (var-name -> ID .)
    class_FLOAT     reduce using rule 227 (var-name -> ID .)
    class_VOID      reduce using rule 227 (var-name -> ID .)
    class_UINT      reduce using rule 227 (var-name -> ID .)
    class_BOOL      reduce using rule 227 (var-name -> ID .)
    class_CHARACTER reduce using rule 227 (var-name -> ID .)
    class_String    reduce using rule 227 (var-name -> ID .)
    collection_SET  reduce using rule 227 (var-name -> ID .)
    collection_ARRAY reduce using rule 227 (var-name -> ID .)
    collection_DICT reduce using rule 227 (var-name -> ID .)
    $end            reduce using rule 227 (var-name -> ID .)
    ARROW           reduce using rule 227 (var-name -> ID .)
    RBRACE          reduce using rule 227 (var-name -> ID .)
    S_CASE          reduce using rule 227 (var-name -> ID .)
    S_DEFAULT       reduce using rule 227 (var-name -> ID .)
    GREATER         reduce using rule 227 (var-name -> ID .)
    PLUS_AS         reduce using rule 227 (var-name -> ID .)
    AT              reduce using rule 227 (var-name -> ID .)
    STR_LITERAL     reduce using rule 227 (var-name -> ID .)
    MUL_STR_LITERAL reduce using rule 227 (var-name -> ID .)
    INT             reduce using rule 227 (var-name -> ID .)
    DOUBLE          reduce using rule 227 (var-name -> ID .)
    INF             reduce using rule 227 (var-name -> ID .)
    NAN             reduce using rule 227 (var-name -> ID .)
    E_TRUE          reduce using rule 227 (var-name -> ID .)
    E_FALSE         reduce using rule 227 (var-name -> ID .)
    E_STDIN         reduce using rule 227 (var-name -> ID .)
    E_STDOUT        reduce using rule 227 (var-name -> ID .)
    E_STDERR        reduce using rule 227 (var-name -> ID .)


state 83

    (109) switch-stmt -> S_SWITCH LPAREN . expr RPAREN LBRACE case-star opt-default RBRACE
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 167
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 84

    (116) wait-stmt -> E_WAIT opt-deep . LPAREN expr-list RPAREN block

    LPAREN          shift and go to state 168


state 85

    (117) opt-deep -> E_DEEP .

    LPAREN          reduce using rule 117 (opt-deep -> E_DEEP .)


state 86

    (118) opt-deep -> empty .

    LPAREN          reduce using rule 118 (opt-deep -> empty .)


state 87

    (119) foreach-loop -> S_FOREACH var-name . opt-comma-var-name S_IN expr block
    (120) opt-comma-var-name -> . COMMA var-name
    (121) opt-comma-var-name -> . empty
    (76) empty -> .

    COMMA           shift and go to state 170
    S_IN            reduce using rule 76 (empty -> .)

    opt-comma-var-name             shift and go to state 169
    empty                          shift and go to state 171

state 88

    (122) for-loop -> S_FOR LPAREN . for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
    (124) for-init-list -> . for-init for-init-star
    (127) for-init -> . for-assignment
    (128) for-init -> . type-prefix var-name type-suffix ASSIGN expr
    (132) for-assignment -> . var-name ASSIGN expr
    (81) type-prefix -> . type-name
    (82) type-prefix -> . param-type
    (227) var-name -> . ID
    (214) type-name -> . class_INT
    (215) type-name -> . class_DOUBLE
    (216) type-name -> . class_FLOAT
    (217) type-name -> . class_VOID
    (218) type-name -> . class_UINT
    (219) type-name -> . class_BOOL
    (220) type-name -> . class_CHARACTER
    (221) type-name -> . class_String
    (222) type-name -> . collection_SET
    (223) type-name -> . collection_ARRAY
    (224) type-name -> . collection_DICT
    (225) type-name -> . ID
    (83) param-type -> . type-name LESS standalone-type GREATER

    ID              shift and go to state 177
    class_INT       shift and go to state 52
    class_DOUBLE    shift and go to state 53
    class_FLOAT     shift and go to state 54
    class_VOID      shift and go to state 55
    class_UINT      shift and go to state 56
    class_BOOL      shift and go to state 57
    class_CHARACTER shift and go to state 58
    class_String    shift and go to state 59
    collection_SET  shift and go to state 60
    collection_ARRAY shift and go to state 61
    collection_DICT shift and go to state 62

    for-init-list                  shift and go to state 172
    for-init                       shift and go to state 173
    for-assignment                 shift and go to state 174
    type-prefix                    shift and go to state 175
    var-name                       shift and go to state 176
    type-name                      shift and go to state 48
    param-type                     shift and go to state 49

state 89

    (72) var-decl -> type-prefix var-decl-rest .

    SEMICOLON       reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    C_GLOBAL        reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    D_IMPORT        reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    C_PRAGMA        reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    LBRACE          reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    S_IF            reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    S_SWITCH        reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    E_WAIT          reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    S_FOREACH       reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    S_FOR           reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    S_WHILE         reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    S_ITERATE       reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    S_ELSE          reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    ID              reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    C_APP           reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    LPAREN          reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    class_INT       reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    class_DOUBLE    reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    class_FLOAT     reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    class_VOID      reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    class_UINT      reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    class_BOOL      reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    class_CHARACTER reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    class_String    reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    collection_SET  reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    collection_ARRAY reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    collection_DICT reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    LESS            reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    $end            reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    ARROW           reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    RBRACE          reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    S_CASE          reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)
    S_DEFAULT       reduce using rule 72 (var-decl -> type-prefix var-decl-rest .)


state 90

    (75) var-decl-rest -> var-name . type-suffix empty-or-var-mapping empty-or-assign-expr
    (84) type-suffix -> . LBRACKET empty-or-standalone-type RBRACKET type-suffix
    (85) type-suffix -> .

    LBRACKET        shift and go to state 179
    LESS            reduce using rule 85 (type-suffix -> .)
    ASSIGN          reduce using rule 85 (type-suffix -> .)
    SEMICOLON       reduce using rule 85 (type-suffix -> .)
    C_GLOBAL        reduce using rule 85 (type-suffix -> .)
    D_IMPORT        reduce using rule 85 (type-suffix -> .)
    C_PRAGMA        reduce using rule 85 (type-suffix -> .)
    LBRACE          reduce using rule 85 (type-suffix -> .)
    S_IF            reduce using rule 85 (type-suffix -> .)
    S_SWITCH        reduce using rule 85 (type-suffix -> .)
    E_WAIT          reduce using rule 85 (type-suffix -> .)
    S_FOREACH       reduce using rule 85 (type-suffix -> .)
    S_FOR           reduce using rule 85 (type-suffix -> .)
    S_WHILE         reduce using rule 85 (type-suffix -> .)
    S_ITERATE       reduce using rule 85 (type-suffix -> .)
    S_ELSE          reduce using rule 85 (type-suffix -> .)
    ID              reduce using rule 85 (type-suffix -> .)
    C_APP           reduce using rule 85 (type-suffix -> .)
    LPAREN          reduce using rule 85 (type-suffix -> .)
    class_INT       reduce using rule 85 (type-suffix -> .)
    class_DOUBLE    reduce using rule 85 (type-suffix -> .)
    class_FLOAT     reduce using rule 85 (type-suffix -> .)
    class_VOID      reduce using rule 85 (type-suffix -> .)
    class_UINT      reduce using rule 85 (type-suffix -> .)
    class_BOOL      reduce using rule 85 (type-suffix -> .)
    class_CHARACTER reduce using rule 85 (type-suffix -> .)
    class_String    reduce using rule 85 (type-suffix -> .)
    collection_SET  reduce using rule 85 (type-suffix -> .)
    collection_ARRAY reduce using rule 85 (type-suffix -> .)
    collection_DICT reduce using rule 85 (type-suffix -> .)
    $end            reduce using rule 85 (type-suffix -> .)
    ARROW           reduce using rule 85 (type-suffix -> .)
    RBRACE          reduce using rule 85 (type-suffix -> .)
    S_CASE          reduce using rule 85 (type-suffix -> .)
    S_DEFAULT       reduce using rule 85 (type-suffix -> .)

    type-suffix                    shift and go to state 178

state 91

    (123) while-loop -> S_WHILE LPAREN . expr RPAREN block
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 180
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 92

    (133) iterate-loop -> S_ITERATE var-name . block S_UNTIL LPAREN expr RPAREN
    (90) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 181

state 93

    (91) stmt-chain -> chainable-stmt semicolon-or-arrow . statement
    (4) statement -> . SEMICOLON
    (5) statement -> . global-const-defn
    (6) statement -> . import-stmt
    (7) statement -> . pragma-stmt
    (8) statement -> . func-defn
    (9) statement -> . block
    (10) statement -> . if-stmt
    (11) statement -> . switch-stmt
    (12) statement -> . wait-stmt
    (13) statement -> . foreach-loop
    (14) statement -> . for-loop
    (15) statement -> . var-decl
    (16) statement -> . while-loop
    (17) statement -> . iterate-loop
    (18) statement -> . stmt-chain
    (19) statement -> . opt-else-block
    (20) statement -> . var-name
    (21) statement -> . assignment
    (22) statement -> . func-call
    (23) statement -> . update-stmt
    (24) global-const-defn -> . C_GLOBAL C_CONST var-decl SEMICOLON
    (25) import-stmt -> . D_IMPORT module-path SEMICOLON
    (26) import-stmt -> . D_IMPORT STR_LITERAL SEMICOLON
    (30) pragma-stmt -> . C_PRAGMA ID expr SEMICOLON
    (31) func-defn -> . swift-func-defn
    (32) func-defn -> . app-func-defn
    (33) func-defn -> . foreign-func-defn
    (90) block -> . LBRACE translation-unit RBRACE
    (106) if-stmt -> . S_IF LPAREN expr RPAREN block opt-else-block
    (109) switch-stmt -> . S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE
    (116) wait-stmt -> . E_WAIT opt-deep LPAREN expr-list RPAREN block
    (119) foreach-loop -> . S_FOREACH var-name opt-comma-var-name S_IN expr block
    (122) for-loop -> . S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
    (72) var-decl -> . type-prefix var-decl-rest
    (123) while-loop -> . S_WHILE LPAREN expr RPAREN block
    (133) iterate-loop -> . S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN
    (91) stmt-chain -> . chainable-stmt semicolon-or-arrow statement
    (107) opt-else-block -> . S_ELSE block
    (108) opt-else-block -> . empty
    (227) var-name -> . ID
    (98) assignment -> . lval-or-paren-lval assign-or-plusas expr-list
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (105) update-stmt -> . var-name LESS ID GREATER UPD expr SEMICOLON
    (52) swift-func-defn -> . func-hdr ARROW block
    (53) app-func-defn -> . C_APP func-hdr LBRACE app-body RBRACE
    (64) foreign-func-defn -> . func-hdr foreign-func-body
    (81) type-prefix -> . type-name
    (82) type-prefix -> . param-type
    (94) chainable-stmt -> . var-name
    (95) chainable-stmt -> . func-call
    (96) chainable-stmt -> . var-decl
    (97) chainable-stmt -> . assignment
    (76) empty -> .
    (103) lval-or-paren-lval -> . lval-list
    (104) lval-or-paren-lval -> . LPAREN lval-list RPAREN
    (34) func-hdr -> . type-params formal-arg-list ID empty-or-arg-list
    (214) type-name -> . class_INT
    (215) type-name -> . class_DOUBLE
    (216) type-name -> . class_FLOAT
    (217) type-name -> . class_VOID
    (218) type-name -> . class_UINT
    (219) type-name -> . class_BOOL
    (220) type-name -> . class_CHARACTER
    (221) type-name -> . class_String
    (222) type-name -> . collection_SET
    (223) type-name -> . collection_ARRAY
    (224) type-name -> . collection_DICT
    (225) type-name -> . ID
    (83) param-type -> . type-name LESS standalone-type GREATER
    (228) lval-list -> . lval-expr lval-expr-star
    (37) type-params -> . LESS var-name comma-name-star GREATER
    (38) type-params -> . empty
    (231) lval-expr -> . var-name subscript-star

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for C_GLOBAL resolved as shift
  ! shift/reduce conflict for D_IMPORT resolved as shift
  ! shift/reduce conflict for C_PRAGMA resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for S_IF resolved as shift
  ! shift/reduce conflict for S_SWITCH resolved as shift
  ! shift/reduce conflict for E_WAIT resolved as shift
  ! shift/reduce conflict for S_FOREACH resolved as shift
  ! shift/reduce conflict for S_FOR resolved as shift
  ! shift/reduce conflict for S_WHILE resolved as shift
  ! shift/reduce conflict for S_ITERATE resolved as shift
  ! shift/reduce conflict for S_ELSE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for C_APP resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for class_INT resolved as shift
  ! shift/reduce conflict for class_DOUBLE resolved as shift
  ! shift/reduce conflict for class_FLOAT resolved as shift
  ! shift/reduce conflict for class_VOID resolved as shift
  ! shift/reduce conflict for class_UINT resolved as shift
  ! shift/reduce conflict for class_BOOL resolved as shift
  ! shift/reduce conflict for class_CHARACTER resolved as shift
  ! shift/reduce conflict for class_String resolved as shift
  ! shift/reduce conflict for collection_SET resolved as shift
  ! shift/reduce conflict for collection_ARRAY resolved as shift
  ! shift/reduce conflict for collection_DICT resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
    SEMICOLON       shift and go to state 5
    C_GLOBAL        shift and go to state 25
    D_IMPORT        shift and go to state 26
    C_PRAGMA        shift and go to state 27
    LBRACE          shift and go to state 32
    S_IF            shift and go to state 33
    S_SWITCH        shift and go to state 35
    E_WAIT          shift and go to state 36
    S_FOREACH       shift and go to state 37
    S_FOR           shift and go to state 38
    S_WHILE         shift and go to state 40
    S_ITERATE       shift and go to state 41
    S_ELSE          shift and go to state 43
    ID              shift and go to state 28
    C_APP           shift and go to state 47
    $end            reduce using rule 76 (empty -> .)
    RBRACE          reduce using rule 76 (empty -> .)
    S_CASE          reduce using rule 76 (empty -> .)
    S_DEFAULT       reduce using rule 76 (empty -> .)
    LPAREN          shift and go to state 34
    class_INT       shift and go to state 52
    class_DOUBLE    shift and go to state 53
    class_FLOAT     shift and go to state 54
    class_VOID      shift and go to state 55
    class_UINT      shift and go to state 56
    class_BOOL      shift and go to state 57
    class_CHARACTER shift and go to state 58
    class_String    shift and go to state 59
    collection_SET  shift and go to state 60
    collection_ARRAY shift and go to state 61
    collection_DICT shift and go to state 62
    LESS            shift and go to state 45

  ! SEMICOLON       [ reduce using rule 76 (empty -> .) ]
  ! C_GLOBAL        [ reduce using rule 76 (empty -> .) ]
  ! D_IMPORT        [ reduce using rule 76 (empty -> .) ]
  ! C_PRAGMA        [ reduce using rule 76 (empty -> .) ]
  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! S_IF            [ reduce using rule 76 (empty -> .) ]
  ! S_SWITCH        [ reduce using rule 76 (empty -> .) ]
  ! E_WAIT          [ reduce using rule 76 (empty -> .) ]
  ! S_FOREACH       [ reduce using rule 76 (empty -> .) ]
  ! S_FOR           [ reduce using rule 76 (empty -> .) ]
  ! S_WHILE         [ reduce using rule 76 (empty -> .) ]
  ! S_ITERATE       [ reduce using rule 76 (empty -> .) ]
  ! S_ELSE          [ reduce using rule 76 (empty -> .) ]
  ! ID              [ reduce using rule 76 (empty -> .) ]
  ! C_APP           [ reduce using rule 76 (empty -> .) ]
  ! LPAREN          [ reduce using rule 76 (empty -> .) ]
  ! class_INT       [ reduce using rule 76 (empty -> .) ]
  ! class_DOUBLE    [ reduce using rule 76 (empty -> .) ]
  ! class_FLOAT     [ reduce using rule 76 (empty -> .) ]
  ! class_VOID      [ reduce using rule 76 (empty -> .) ]
  ! class_UINT      [ reduce using rule 76 (empty -> .) ]
  ! class_BOOL      [ reduce using rule 76 (empty -> .) ]
  ! class_CHARACTER [ reduce using rule 76 (empty -> .) ]
  ! class_String    [ reduce using rule 76 (empty -> .) ]
  ! collection_SET  [ reduce using rule 76 (empty -> .) ]
  ! collection_ARRAY [ reduce using rule 76 (empty -> .) ]
  ! collection_DICT [ reduce using rule 76 (empty -> .) ]
  ! LESS            [ reduce using rule 76 (empty -> .) ]

    chainable-stmt                 shift and go to state 42
    statement                      shift and go to state 182
    global-const-defn              shift and go to state 6
    import-stmt                    shift and go to state 7
    pragma-stmt                    shift and go to state 8
    func-defn                      shift and go to state 9
    block                          shift and go to state 10
    if-stmt                        shift and go to state 11
    switch-stmt                    shift and go to state 12
    wait-stmt                      shift and go to state 13
    foreach-loop                   shift and go to state 14
    for-loop                       shift and go to state 15
    var-decl                       shift and go to state 16
    while-loop                     shift and go to state 17
    iterate-loop                   shift and go to state 18
    stmt-chain                     shift and go to state 19
    opt-else-block                 shift and go to state 20
    var-name                       shift and go to state 21
    assignment                     shift and go to state 22
    func-call                      shift and go to state 23
    update-stmt                    shift and go to state 24
    swift-func-defn                shift and go to state 29
    app-func-defn                  shift and go to state 30
    foreign-func-defn              shift and go to state 31
    type-prefix                    shift and go to state 39
    empty                          shift and go to state 183
    lval-or-paren-lval             shift and go to state 44
    func-hdr                       shift and go to state 46
    type-name                      shift and go to state 48
    param-type                     shift and go to state 49
    lval-list                      shift and go to state 50
    type-params                    shift and go to state 51
    lval-expr                      shift and go to state 63

state 94

    (92) semicolon-or-arrow -> SEMICOLON .

    SEMICOLON       reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    C_GLOBAL        reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    D_IMPORT        reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    C_PRAGMA        reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    LBRACE          reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    S_IF            reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    S_SWITCH        reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    E_WAIT          reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    S_FOREACH       reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    S_FOR           reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    S_WHILE         reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    S_ITERATE       reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    S_ELSE          reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    ID              reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    C_APP           reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    LPAREN          reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    class_INT       reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    class_DOUBLE    reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    class_FLOAT     reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    class_VOID      reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    class_UINT      reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    class_BOOL      reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    class_CHARACTER reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    class_String    reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    collection_SET  reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    collection_ARRAY reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    collection_DICT reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    LESS            reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    $end            reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    RBRACE          reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    S_CASE          reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)
    S_DEFAULT       reduce using rule 92 (semicolon-or-arrow -> SEMICOLON .)


state 95

    (93) semicolon-or-arrow -> ARROW .

    SEMICOLON       reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    C_GLOBAL        reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    D_IMPORT        reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    C_PRAGMA        reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    LBRACE          reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    S_IF            reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    S_SWITCH        reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    E_WAIT          reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    S_FOREACH       reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    S_FOR           reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    S_WHILE         reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    S_ITERATE       reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    S_ELSE          reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    ID              reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    C_APP           reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    LPAREN          reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    class_INT       reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    class_DOUBLE    reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    class_FLOAT     reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    class_VOID      reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    class_UINT      reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    class_BOOL      reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    class_CHARACTER reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    class_String    reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    collection_SET  reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    collection_ARRAY reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    collection_DICT reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    LESS            reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    $end            reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    RBRACE          reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    S_CASE          reduce using rule 93 (semicolon-or-arrow -> ARROW .)
    S_DEFAULT       reduce using rule 93 (semicolon-or-arrow -> ARROW .)


state 96

    (107) opt-else-block -> S_ELSE block .

    SEMICOLON       reduce using rule 107 (opt-else-block -> S_ELSE block .)
    C_GLOBAL        reduce using rule 107 (opt-else-block -> S_ELSE block .)
    D_IMPORT        reduce using rule 107 (opt-else-block -> S_ELSE block .)
    C_PRAGMA        reduce using rule 107 (opt-else-block -> S_ELSE block .)
    LBRACE          reduce using rule 107 (opt-else-block -> S_ELSE block .)
    S_IF            reduce using rule 107 (opt-else-block -> S_ELSE block .)
    S_SWITCH        reduce using rule 107 (opt-else-block -> S_ELSE block .)
    E_WAIT          reduce using rule 107 (opt-else-block -> S_ELSE block .)
    S_FOREACH       reduce using rule 107 (opt-else-block -> S_ELSE block .)
    S_FOR           reduce using rule 107 (opt-else-block -> S_ELSE block .)
    S_WHILE         reduce using rule 107 (opt-else-block -> S_ELSE block .)
    S_ITERATE       reduce using rule 107 (opt-else-block -> S_ELSE block .)
    S_ELSE          reduce using rule 107 (opt-else-block -> S_ELSE block .)
    ID              reduce using rule 107 (opt-else-block -> S_ELSE block .)
    C_APP           reduce using rule 107 (opt-else-block -> S_ELSE block .)
    LPAREN          reduce using rule 107 (opt-else-block -> S_ELSE block .)
    class_INT       reduce using rule 107 (opt-else-block -> S_ELSE block .)
    class_DOUBLE    reduce using rule 107 (opt-else-block -> S_ELSE block .)
    class_FLOAT     reduce using rule 107 (opt-else-block -> S_ELSE block .)
    class_VOID      reduce using rule 107 (opt-else-block -> S_ELSE block .)
    class_UINT      reduce using rule 107 (opt-else-block -> S_ELSE block .)
    class_BOOL      reduce using rule 107 (opt-else-block -> S_ELSE block .)
    class_CHARACTER reduce using rule 107 (opt-else-block -> S_ELSE block .)
    class_String    reduce using rule 107 (opt-else-block -> S_ELSE block .)
    collection_SET  reduce using rule 107 (opt-else-block -> S_ELSE block .)
    collection_ARRAY reduce using rule 107 (opt-else-block -> S_ELSE block .)
    collection_DICT reduce using rule 107 (opt-else-block -> S_ELSE block .)
    LESS            reduce using rule 107 (opt-else-block -> S_ELSE block .)
    $end            reduce using rule 107 (opt-else-block -> S_ELSE block .)
    RBRACE          reduce using rule 107 (opt-else-block -> S_ELSE block .)
    S_CASE          reduce using rule 107 (opt-else-block -> S_ELSE block .)
    S_DEFAULT       reduce using rule 107 (opt-else-block -> S_ELSE block .)


state 97

    (98) assignment -> lval-or-paren-lval assign-or-plusas . expr-list
    (213) expr-list -> . expr
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr-list                      shift and go to state 184
    expr                           shift and go to state 185
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 98

    (101) assign-or-plusas -> ASSIGN .

    MINUS           reduce using rule 101 (assign-or-plusas -> ASSIGN .)
    EXCLAMATION     reduce using rule 101 (assign-or-plusas -> ASSIGN .)
    LPAREN          reduce using rule 101 (assign-or-plusas -> ASSIGN .)
    STR_LITERAL     reduce using rule 101 (assign-or-plusas -> ASSIGN .)
    MUL_STR_LITERAL reduce using rule 101 (assign-or-plusas -> ASSIGN .)
    INT             reduce using rule 101 (assign-or-plusas -> ASSIGN .)
    ID              reduce using rule 101 (assign-or-plusas -> ASSIGN .)
    DOUBLE          reduce using rule 101 (assign-or-plusas -> ASSIGN .)
    INF             reduce using rule 101 (assign-or-plusas -> ASSIGN .)
    NAN             reduce using rule 101 (assign-or-plusas -> ASSIGN .)
    E_TRUE          reduce using rule 101 (assign-or-plusas -> ASSIGN .)
    E_FALSE         reduce using rule 101 (assign-or-plusas -> ASSIGN .)
    LBRACKET        reduce using rule 101 (assign-or-plusas -> ASSIGN .)
    LBRACE          reduce using rule 101 (assign-or-plusas -> ASSIGN .)


state 99

    (102) assign-or-plusas -> PLUS_AS .

    MINUS           reduce using rule 102 (assign-or-plusas -> PLUS_AS .)
    EXCLAMATION     reduce using rule 102 (assign-or-plusas -> PLUS_AS .)
    LPAREN          reduce using rule 102 (assign-or-plusas -> PLUS_AS .)
    STR_LITERAL     reduce using rule 102 (assign-or-plusas -> PLUS_AS .)
    MUL_STR_LITERAL reduce using rule 102 (assign-or-plusas -> PLUS_AS .)
    INT             reduce using rule 102 (assign-or-plusas -> PLUS_AS .)
    ID              reduce using rule 102 (assign-or-plusas -> PLUS_AS .)
    DOUBLE          reduce using rule 102 (assign-or-plusas -> PLUS_AS .)
    INF             reduce using rule 102 (assign-or-plusas -> PLUS_AS .)
    NAN             reduce using rule 102 (assign-or-plusas -> PLUS_AS .)
    E_TRUE          reduce using rule 102 (assign-or-plusas -> PLUS_AS .)
    E_FALSE         reduce using rule 102 (assign-or-plusas -> PLUS_AS .)
    LBRACKET        reduce using rule 102 (assign-or-plusas -> PLUS_AS .)
    LBRACE          reduce using rule 102 (assign-or-plusas -> PLUS_AS .)


state 100

    (37) type-params -> LESS var-name . comma-name-star GREATER
    (39) comma-name-star -> . COMMA var-name comma-name-star
    (40) comma-name-star -> .

    COMMA           shift and go to state 187
    GREATER         reduce using rule 40 (comma-name-star -> .)

    comma-name-star                shift and go to state 186

state 101

    (52) swift-func-defn -> func-hdr ARROW . block
    (90) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 188

state 102

    (64) foreign-func-defn -> func-hdr foreign-func-body .

    SEMICOLON       reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    C_GLOBAL        reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    D_IMPORT        reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    C_PRAGMA        reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    LBRACE          reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    S_IF            reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    S_SWITCH        reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    E_WAIT          reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    S_FOREACH       reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    S_FOR           reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    S_WHILE         reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    S_ITERATE       reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    S_ELSE          reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    ID              reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    C_APP           reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    LPAREN          reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    class_INT       reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    class_DOUBLE    reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    class_FLOAT     reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    class_VOID      reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    class_UINT      reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    class_BOOL      reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    class_CHARACTER reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    class_String    reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    collection_SET  reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    collection_ARRAY reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    collection_DICT reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    LESS            reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    $end            reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    RBRACE          reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    S_CASE          reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)
    S_DEFAULT       reduce using rule 64 (foreign-func-defn -> func-hdr foreign-func-body .)


state 103

    (65) foreign-func-body -> STR_LITERAL . STR_LITERAL empty-or-literal empty-or-more-literals

    STR_LITERAL     shift and go to state 189


state 104

    (53) app-func-defn -> C_APP func-hdr . LBRACE app-body RBRACE

    LBRACE          shift and go to state 190


state 105

    (38) type-params -> empty .

    LPAREN          reduce using rule 38 (type-params -> empty .)
    ID              reduce using rule 38 (type-params -> empty .)


state 106

    (83) param-type -> type-name LESS . standalone-type GREATER
    (88) standalone-type -> . type-prefix type-suffix
    (81) type-prefix -> . type-name
    (82) type-prefix -> . param-type
    (214) type-name -> . class_INT
    (215) type-name -> . class_DOUBLE
    (216) type-name -> . class_FLOAT
    (217) type-name -> . class_VOID
    (218) type-name -> . class_UINT
    (219) type-name -> . class_BOOL
    (220) type-name -> . class_CHARACTER
    (221) type-name -> . class_String
    (222) type-name -> . collection_SET
    (223) type-name -> . collection_ARRAY
    (224) type-name -> . collection_DICT
    (225) type-name -> . ID
    (83) param-type -> . type-name LESS standalone-type GREATER

    class_INT       shift and go to state 52
    class_DOUBLE    shift and go to state 53
    class_FLOAT     shift and go to state 54
    class_VOID      shift and go to state 55
    class_UINT      shift and go to state 56
    class_BOOL      shift and go to state 57
    class_CHARACTER shift and go to state 58
    class_String    shift and go to state 59
    collection_SET  shift and go to state 60
    collection_ARRAY shift and go to state 61
    collection_DICT shift and go to state 62
    ID              shift and go to state 152

    type-name                      shift and go to state 48
    standalone-type                shift and go to state 191
    type-prefix                    shift and go to state 192
    param-type                     shift and go to state 49

state 107

    (34) func-hdr -> type-params formal-arg-list . ID empty-or-arg-list

    ID              shift and go to state 193


state 108

    (41) formal-arg-list -> LPAREN . opt-formal-args RPAREN
    (43) opt-formal-args -> . formal-arg comma-args-star
    (44) opt-formal-args -> . empty
    (47) formal-arg -> . type-prefix empty-or-range var-name type-suffix empty-or-ass-expr
    (76) empty -> .
    (81) type-prefix -> . type-name
    (82) type-prefix -> . param-type
    (214) type-name -> . class_INT
    (215) type-name -> . class_DOUBLE
    (216) type-name -> . class_FLOAT
    (217) type-name -> . class_VOID
    (218) type-name -> . class_UINT
    (219) type-name -> . class_BOOL
    (220) type-name -> . class_CHARACTER
    (221) type-name -> . class_String
    (222) type-name -> . collection_SET
    (223) type-name -> . collection_ARRAY
    (224) type-name -> . collection_DICT
    (225) type-name -> . ID
    (83) param-type -> . type-name LESS standalone-type GREATER

    RPAREN          reduce using rule 76 (empty -> .)
    class_INT       shift and go to state 52
    class_DOUBLE    shift and go to state 53
    class_FLOAT     shift and go to state 54
    class_VOID      shift and go to state 55
    class_UINT      shift and go to state 56
    class_BOOL      shift and go to state 57
    class_CHARACTER shift and go to state 58
    class_String    shift and go to state 59
    collection_SET  shift and go to state 60
    collection_ARRAY shift and go to state 61
    collection_DICT shift and go to state 62
    ID              shift and go to state 152

    opt-formal-args                shift and go to state 194
    formal-arg                     shift and go to state 195
    empty                          shift and go to state 196
    type-prefix                    shift and go to state 197
    type-name                      shift and go to state 48
    param-type                     shift and go to state 49

state 109

    (42) formal-arg-list -> empty .

    ID              reduce using rule 42 (formal-arg-list -> empty .)


state 110

    (228) lval-list -> lval-expr lval-expr-star .

    ASSIGN          reduce using rule 228 (lval-list -> lval-expr lval-expr-star .)
    PLUS_AS         reduce using rule 228 (lval-list -> lval-expr lval-expr-star .)
    RPAREN          reduce using rule 228 (lval-list -> lval-expr lval-expr-star .)


state 111

    (229) lval-expr-star -> COMMA . lval-expr lval-expr-star
    (231) lval-expr -> . var-name subscript-star
    (227) var-name -> . ID

    ID              shift and go to state 82

    lval-expr                      shift and go to state 198
    var-name                       shift and go to state 81

state 112

    (105) update-stmt -> var-name LESS ID . GREATER UPD expr SEMICOLON

    GREATER         shift and go to state 199


state 113

    (232) subscript-star -> array-subscript subscript-star .

    COMMA           reduce using rule 232 (subscript-star -> array-subscript subscript-star .)
    ASSIGN          reduce using rule 232 (subscript-star -> array-subscript subscript-star .)
    PLUS_AS         reduce using rule 232 (subscript-star -> array-subscript subscript-star .)
    RPAREN          reduce using rule 232 (subscript-star -> array-subscript subscript-star .)


state 114

    (233) subscript-star -> struct-subscript subscript-star .

    COMMA           reduce using rule 233 (subscript-star -> struct-subscript subscript-star .)
    ASSIGN          reduce using rule 233 (subscript-star -> struct-subscript subscript-star .)
    PLUS_AS         reduce using rule 233 (subscript-star -> struct-subscript subscript-star .)
    RPAREN          reduce using rule 233 (subscript-star -> struct-subscript subscript-star .)


state 115

    (190) array-list-constructor -> LBRACKET . opt-expr-list RBRACKET
    (193) array-range-constructor -> LBRACKET . expr COLON expr opt-coloned-expr RBRACKET
    (191) opt-expr-list -> . expr-list
    (192) opt-expr-list -> . empty
    (134) expr -> . or-expr
    (213) expr-list -> . expr
    (76) empty -> .
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    RBRACKET        reduce using rule 76 (empty -> .)
    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    opt-expr-list                  shift and go to state 200
    expr                           shift and go to state 201
    expr-list                      shift and go to state 202
    empty                          shift and go to state 203
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 116

    (169) array-subscript -> LBRACKET expr . RBRACKET

    RBRACKET        shift and go to state 204


state 117

    (134) expr -> or-expr .
    (136) or-expr -> or-expr . LOG_OR and-expr

    RBRACKET        reduce using rule 134 (expr -> or-expr .)
    SEMICOLON       reduce using rule 134 (expr -> or-expr .)
    COMMA           reduce using rule 134 (expr -> or-expr .)
    RPAREN          reduce using rule 134 (expr -> or-expr .)
    C_GLOBAL        reduce using rule 134 (expr -> or-expr .)
    D_IMPORT        reduce using rule 134 (expr -> or-expr .)
    C_PRAGMA        reduce using rule 134 (expr -> or-expr .)
    LBRACE          reduce using rule 134 (expr -> or-expr .)
    S_IF            reduce using rule 134 (expr -> or-expr .)
    S_SWITCH        reduce using rule 134 (expr -> or-expr .)
    E_WAIT          reduce using rule 134 (expr -> or-expr .)
    S_FOREACH       reduce using rule 134 (expr -> or-expr .)
    S_FOR           reduce using rule 134 (expr -> or-expr .)
    S_WHILE         reduce using rule 134 (expr -> or-expr .)
    S_ITERATE       reduce using rule 134 (expr -> or-expr .)
    S_ELSE          reduce using rule 134 (expr -> or-expr .)
    ID              reduce using rule 134 (expr -> or-expr .)
    C_APP           reduce using rule 134 (expr -> or-expr .)
    LPAREN          reduce using rule 134 (expr -> or-expr .)
    class_INT       reduce using rule 134 (expr -> or-expr .)
    class_DOUBLE    reduce using rule 134 (expr -> or-expr .)
    class_FLOAT     reduce using rule 134 (expr -> or-expr .)
    class_VOID      reduce using rule 134 (expr -> or-expr .)
    class_UINT      reduce using rule 134 (expr -> or-expr .)
    class_BOOL      reduce using rule 134 (expr -> or-expr .)
    class_CHARACTER reduce using rule 134 (expr -> or-expr .)
    class_String    reduce using rule 134 (expr -> or-expr .)
    collection_SET  reduce using rule 134 (expr -> or-expr .)
    collection_ARRAY reduce using rule 134 (expr -> or-expr .)
    collection_DICT reduce using rule 134 (expr -> or-expr .)
    LESS            reduce using rule 134 (expr -> or-expr .)
    $end            reduce using rule 134 (expr -> or-expr .)
    ARROW           reduce using rule 134 (expr -> or-expr .)
    RBRACE          reduce using rule 134 (expr -> or-expr .)
    S_CASE          reduce using rule 134 (expr -> or-expr .)
    S_DEFAULT       reduce using rule 134 (expr -> or-expr .)
    COLON           reduce using rule 134 (expr -> or-expr .)
    GREATER         reduce using rule 134 (expr -> or-expr .)
    E_STDIN         reduce using rule 134 (expr -> or-expr .)
    E_STDOUT        reduce using rule 134 (expr -> or-expr .)
    E_STDERR        reduce using rule 134 (expr -> or-expr .)
    LOG_OR          shift and go to state 205


state 118

    (135) or-expr -> and-expr .
    (138) and-expr -> and-expr . LOG_AND eq-expr

    LOG_OR          reduce using rule 135 (or-expr -> and-expr .)
    RBRACKET        reduce using rule 135 (or-expr -> and-expr .)
    SEMICOLON       reduce using rule 135 (or-expr -> and-expr .)
    COMMA           reduce using rule 135 (or-expr -> and-expr .)
    RPAREN          reduce using rule 135 (or-expr -> and-expr .)
    C_GLOBAL        reduce using rule 135 (or-expr -> and-expr .)
    D_IMPORT        reduce using rule 135 (or-expr -> and-expr .)
    C_PRAGMA        reduce using rule 135 (or-expr -> and-expr .)
    LBRACE          reduce using rule 135 (or-expr -> and-expr .)
    S_IF            reduce using rule 135 (or-expr -> and-expr .)
    S_SWITCH        reduce using rule 135 (or-expr -> and-expr .)
    E_WAIT          reduce using rule 135 (or-expr -> and-expr .)
    S_FOREACH       reduce using rule 135 (or-expr -> and-expr .)
    S_FOR           reduce using rule 135 (or-expr -> and-expr .)
    S_WHILE         reduce using rule 135 (or-expr -> and-expr .)
    S_ITERATE       reduce using rule 135 (or-expr -> and-expr .)
    S_ELSE          reduce using rule 135 (or-expr -> and-expr .)
    ID              reduce using rule 135 (or-expr -> and-expr .)
    C_APP           reduce using rule 135 (or-expr -> and-expr .)
    LPAREN          reduce using rule 135 (or-expr -> and-expr .)
    class_INT       reduce using rule 135 (or-expr -> and-expr .)
    class_DOUBLE    reduce using rule 135 (or-expr -> and-expr .)
    class_FLOAT     reduce using rule 135 (or-expr -> and-expr .)
    class_VOID      reduce using rule 135 (or-expr -> and-expr .)
    class_UINT      reduce using rule 135 (or-expr -> and-expr .)
    class_BOOL      reduce using rule 135 (or-expr -> and-expr .)
    class_CHARACTER reduce using rule 135 (or-expr -> and-expr .)
    class_String    reduce using rule 135 (or-expr -> and-expr .)
    collection_SET  reduce using rule 135 (or-expr -> and-expr .)
    collection_ARRAY reduce using rule 135 (or-expr -> and-expr .)
    collection_DICT reduce using rule 135 (or-expr -> and-expr .)
    LESS            reduce using rule 135 (or-expr -> and-expr .)
    $end            reduce using rule 135 (or-expr -> and-expr .)
    ARROW           reduce using rule 135 (or-expr -> and-expr .)
    RBRACE          reduce using rule 135 (or-expr -> and-expr .)
    S_CASE          reduce using rule 135 (or-expr -> and-expr .)
    S_DEFAULT       reduce using rule 135 (or-expr -> and-expr .)
    COLON           reduce using rule 135 (or-expr -> and-expr .)
    GREATER         reduce using rule 135 (or-expr -> and-expr .)
    E_STDIN         reduce using rule 135 (or-expr -> and-expr .)
    E_STDOUT        reduce using rule 135 (or-expr -> and-expr .)
    E_STDERR        reduce using rule 135 (or-expr -> and-expr .)
    LOG_AND         shift and go to state 206


state 119

    (137) and-expr -> eq-expr .
    (140) eq-expr -> eq-expr . eq-or-not-eq eq-expr
    (141) eq-or-not-eq -> . EQUAL
    (142) eq-or-not-eq -> . NOT_EQUAL

    LOG_AND         reduce using rule 137 (and-expr -> eq-expr .)
    LOG_OR          reduce using rule 137 (and-expr -> eq-expr .)
    RBRACKET        reduce using rule 137 (and-expr -> eq-expr .)
    SEMICOLON       reduce using rule 137 (and-expr -> eq-expr .)
    COMMA           reduce using rule 137 (and-expr -> eq-expr .)
    RPAREN          reduce using rule 137 (and-expr -> eq-expr .)
    C_GLOBAL        reduce using rule 137 (and-expr -> eq-expr .)
    D_IMPORT        reduce using rule 137 (and-expr -> eq-expr .)
    C_PRAGMA        reduce using rule 137 (and-expr -> eq-expr .)
    LBRACE          reduce using rule 137 (and-expr -> eq-expr .)
    S_IF            reduce using rule 137 (and-expr -> eq-expr .)
    S_SWITCH        reduce using rule 137 (and-expr -> eq-expr .)
    E_WAIT          reduce using rule 137 (and-expr -> eq-expr .)
    S_FOREACH       reduce using rule 137 (and-expr -> eq-expr .)
    S_FOR           reduce using rule 137 (and-expr -> eq-expr .)
    S_WHILE         reduce using rule 137 (and-expr -> eq-expr .)
    S_ITERATE       reduce using rule 137 (and-expr -> eq-expr .)
    S_ELSE          reduce using rule 137 (and-expr -> eq-expr .)
    ID              reduce using rule 137 (and-expr -> eq-expr .)
    C_APP           reduce using rule 137 (and-expr -> eq-expr .)
    LPAREN          reduce using rule 137 (and-expr -> eq-expr .)
    class_INT       reduce using rule 137 (and-expr -> eq-expr .)
    class_DOUBLE    reduce using rule 137 (and-expr -> eq-expr .)
    class_FLOAT     reduce using rule 137 (and-expr -> eq-expr .)
    class_VOID      reduce using rule 137 (and-expr -> eq-expr .)
    class_UINT      reduce using rule 137 (and-expr -> eq-expr .)
    class_BOOL      reduce using rule 137 (and-expr -> eq-expr .)
    class_CHARACTER reduce using rule 137 (and-expr -> eq-expr .)
    class_String    reduce using rule 137 (and-expr -> eq-expr .)
    collection_SET  reduce using rule 137 (and-expr -> eq-expr .)
    collection_ARRAY reduce using rule 137 (and-expr -> eq-expr .)
    collection_DICT reduce using rule 137 (and-expr -> eq-expr .)
    LESS            reduce using rule 137 (and-expr -> eq-expr .)
    $end            reduce using rule 137 (and-expr -> eq-expr .)
    ARROW           reduce using rule 137 (and-expr -> eq-expr .)
    RBRACE          reduce using rule 137 (and-expr -> eq-expr .)
    S_CASE          reduce using rule 137 (and-expr -> eq-expr .)
    S_DEFAULT       reduce using rule 137 (and-expr -> eq-expr .)
    COLON           reduce using rule 137 (and-expr -> eq-expr .)
    GREATER         reduce using rule 137 (and-expr -> eq-expr .)
    E_STDIN         reduce using rule 137 (and-expr -> eq-expr .)
    E_STDOUT        reduce using rule 137 (and-expr -> eq-expr .)
    E_STDERR        reduce using rule 137 (and-expr -> eq-expr .)
    EQUAL           shift and go to state 208
    NOT_EQUAL       shift and go to state 209

    eq-or-not-eq                   shift and go to state 207

state 120

    (139) eq-expr -> cmp-expr .
    (144) cmp-expr -> cmp-expr . cmp-sign add-expr
    (145) cmp-sign -> . LESS
    (146) cmp-sign -> . LESS_EQ
    (147) cmp-sign -> . EQUAL
    (148) cmp-sign -> . GREATER
    (149) cmp-sign -> . GREATER_EQ

  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
    NOT_EQUAL       reduce using rule 139 (eq-expr -> cmp-expr .)
    LOG_AND         reduce using rule 139 (eq-expr -> cmp-expr .)
    LOG_OR          reduce using rule 139 (eq-expr -> cmp-expr .)
    RBRACKET        reduce using rule 139 (eq-expr -> cmp-expr .)
    SEMICOLON       reduce using rule 139 (eq-expr -> cmp-expr .)
    COMMA           reduce using rule 139 (eq-expr -> cmp-expr .)
    RPAREN          reduce using rule 139 (eq-expr -> cmp-expr .)
    C_GLOBAL        reduce using rule 139 (eq-expr -> cmp-expr .)
    D_IMPORT        reduce using rule 139 (eq-expr -> cmp-expr .)
    C_PRAGMA        reduce using rule 139 (eq-expr -> cmp-expr .)
    LBRACE          reduce using rule 139 (eq-expr -> cmp-expr .)
    S_IF            reduce using rule 139 (eq-expr -> cmp-expr .)
    S_SWITCH        reduce using rule 139 (eq-expr -> cmp-expr .)
    E_WAIT          reduce using rule 139 (eq-expr -> cmp-expr .)
    S_FOREACH       reduce using rule 139 (eq-expr -> cmp-expr .)
    S_FOR           reduce using rule 139 (eq-expr -> cmp-expr .)
    S_WHILE         reduce using rule 139 (eq-expr -> cmp-expr .)
    S_ITERATE       reduce using rule 139 (eq-expr -> cmp-expr .)
    S_ELSE          reduce using rule 139 (eq-expr -> cmp-expr .)
    ID              reduce using rule 139 (eq-expr -> cmp-expr .)
    C_APP           reduce using rule 139 (eq-expr -> cmp-expr .)
    LPAREN          reduce using rule 139 (eq-expr -> cmp-expr .)
    class_INT       reduce using rule 139 (eq-expr -> cmp-expr .)
    class_DOUBLE    reduce using rule 139 (eq-expr -> cmp-expr .)
    class_FLOAT     reduce using rule 139 (eq-expr -> cmp-expr .)
    class_VOID      reduce using rule 139 (eq-expr -> cmp-expr .)
    class_UINT      reduce using rule 139 (eq-expr -> cmp-expr .)
    class_BOOL      reduce using rule 139 (eq-expr -> cmp-expr .)
    class_CHARACTER reduce using rule 139 (eq-expr -> cmp-expr .)
    class_String    reduce using rule 139 (eq-expr -> cmp-expr .)
    collection_SET  reduce using rule 139 (eq-expr -> cmp-expr .)
    collection_ARRAY reduce using rule 139 (eq-expr -> cmp-expr .)
    collection_DICT reduce using rule 139 (eq-expr -> cmp-expr .)
    $end            reduce using rule 139 (eq-expr -> cmp-expr .)
    ARROW           reduce using rule 139 (eq-expr -> cmp-expr .)
    RBRACE          reduce using rule 139 (eq-expr -> cmp-expr .)
    S_CASE          reduce using rule 139 (eq-expr -> cmp-expr .)
    S_DEFAULT       reduce using rule 139 (eq-expr -> cmp-expr .)
    COLON           reduce using rule 139 (eq-expr -> cmp-expr .)
    E_STDIN         reduce using rule 139 (eq-expr -> cmp-expr .)
    E_STDOUT        reduce using rule 139 (eq-expr -> cmp-expr .)
    E_STDERR        reduce using rule 139 (eq-expr -> cmp-expr .)
    LESS            shift and go to state 211
    LESS_EQ         shift and go to state 212
    EQUAL           shift and go to state 213
    GREATER         shift and go to state 214
    GREATER_EQ      shift and go to state 215

  ! EQUAL           [ reduce using rule 139 (eq-expr -> cmp-expr .) ]
  ! LESS            [ reduce using rule 139 (eq-expr -> cmp-expr .) ]
  ! GREATER         [ reduce using rule 139 (eq-expr -> cmp-expr .) ]

    cmp-sign                       shift and go to state 210

state 121

    (143) cmp-expr -> add-expr .
    (151) add-expr -> add-expr . add-sign mult-expr
    (152) add-sign -> . PLUS
    (153) add-sign -> . MINUS

    LESS            reduce using rule 143 (cmp-expr -> add-expr .)
    LESS_EQ         reduce using rule 143 (cmp-expr -> add-expr .)
    EQUAL           reduce using rule 143 (cmp-expr -> add-expr .)
    GREATER         reduce using rule 143 (cmp-expr -> add-expr .)
    GREATER_EQ      reduce using rule 143 (cmp-expr -> add-expr .)
    NOT_EQUAL       reduce using rule 143 (cmp-expr -> add-expr .)
    LOG_AND         reduce using rule 143 (cmp-expr -> add-expr .)
    LOG_OR          reduce using rule 143 (cmp-expr -> add-expr .)
    RBRACKET        reduce using rule 143 (cmp-expr -> add-expr .)
    SEMICOLON       reduce using rule 143 (cmp-expr -> add-expr .)
    COMMA           reduce using rule 143 (cmp-expr -> add-expr .)
    RPAREN          reduce using rule 143 (cmp-expr -> add-expr .)
    C_GLOBAL        reduce using rule 143 (cmp-expr -> add-expr .)
    D_IMPORT        reduce using rule 143 (cmp-expr -> add-expr .)
    C_PRAGMA        reduce using rule 143 (cmp-expr -> add-expr .)
    LBRACE          reduce using rule 143 (cmp-expr -> add-expr .)
    S_IF            reduce using rule 143 (cmp-expr -> add-expr .)
    S_SWITCH        reduce using rule 143 (cmp-expr -> add-expr .)
    E_WAIT          reduce using rule 143 (cmp-expr -> add-expr .)
    S_FOREACH       reduce using rule 143 (cmp-expr -> add-expr .)
    S_FOR           reduce using rule 143 (cmp-expr -> add-expr .)
    S_WHILE         reduce using rule 143 (cmp-expr -> add-expr .)
    S_ITERATE       reduce using rule 143 (cmp-expr -> add-expr .)
    S_ELSE          reduce using rule 143 (cmp-expr -> add-expr .)
    ID              reduce using rule 143 (cmp-expr -> add-expr .)
    C_APP           reduce using rule 143 (cmp-expr -> add-expr .)
    LPAREN          reduce using rule 143 (cmp-expr -> add-expr .)
    class_INT       reduce using rule 143 (cmp-expr -> add-expr .)
    class_DOUBLE    reduce using rule 143 (cmp-expr -> add-expr .)
    class_FLOAT     reduce using rule 143 (cmp-expr -> add-expr .)
    class_VOID      reduce using rule 143 (cmp-expr -> add-expr .)
    class_UINT      reduce using rule 143 (cmp-expr -> add-expr .)
    class_BOOL      reduce using rule 143 (cmp-expr -> add-expr .)
    class_CHARACTER reduce using rule 143 (cmp-expr -> add-expr .)
    class_String    reduce using rule 143 (cmp-expr -> add-expr .)
    collection_SET  reduce using rule 143 (cmp-expr -> add-expr .)
    collection_ARRAY reduce using rule 143 (cmp-expr -> add-expr .)
    collection_DICT reduce using rule 143 (cmp-expr -> add-expr .)
    $end            reduce using rule 143 (cmp-expr -> add-expr .)
    ARROW           reduce using rule 143 (cmp-expr -> add-expr .)
    RBRACE          reduce using rule 143 (cmp-expr -> add-expr .)
    S_CASE          reduce using rule 143 (cmp-expr -> add-expr .)
    S_DEFAULT       reduce using rule 143 (cmp-expr -> add-expr .)
    COLON           reduce using rule 143 (cmp-expr -> add-expr .)
    E_STDIN         reduce using rule 143 (cmp-expr -> add-expr .)
    E_STDOUT        reduce using rule 143 (cmp-expr -> add-expr .)
    E_STDERR        reduce using rule 143 (cmp-expr -> add-expr .)
    PLUS            shift and go to state 217
    MINUS           shift and go to state 218

    add-sign                       shift and go to state 216

state 122

    (150) add-expr -> mult-expr .
    (155) mult-expr -> mult-expr . mult-sign unary-expr
    (156) mult-sign -> . MULT
    (157) mult-sign -> . DIV
    (158) mult-sign -> . MULTPER
    (159) mult-sign -> . DOUBLEPER
    (160) mult-sign -> . MOD

    PLUS            reduce using rule 150 (add-expr -> mult-expr .)
    MINUS           reduce using rule 150 (add-expr -> mult-expr .)
    LESS            reduce using rule 150 (add-expr -> mult-expr .)
    LESS_EQ         reduce using rule 150 (add-expr -> mult-expr .)
    EQUAL           reduce using rule 150 (add-expr -> mult-expr .)
    GREATER         reduce using rule 150 (add-expr -> mult-expr .)
    GREATER_EQ      reduce using rule 150 (add-expr -> mult-expr .)
    NOT_EQUAL       reduce using rule 150 (add-expr -> mult-expr .)
    LOG_AND         reduce using rule 150 (add-expr -> mult-expr .)
    LOG_OR          reduce using rule 150 (add-expr -> mult-expr .)
    RBRACKET        reduce using rule 150 (add-expr -> mult-expr .)
    SEMICOLON       reduce using rule 150 (add-expr -> mult-expr .)
    COMMA           reduce using rule 150 (add-expr -> mult-expr .)
    RPAREN          reduce using rule 150 (add-expr -> mult-expr .)
    C_GLOBAL        reduce using rule 150 (add-expr -> mult-expr .)
    D_IMPORT        reduce using rule 150 (add-expr -> mult-expr .)
    C_PRAGMA        reduce using rule 150 (add-expr -> mult-expr .)
    LBRACE          reduce using rule 150 (add-expr -> mult-expr .)
    S_IF            reduce using rule 150 (add-expr -> mult-expr .)
    S_SWITCH        reduce using rule 150 (add-expr -> mult-expr .)
    E_WAIT          reduce using rule 150 (add-expr -> mult-expr .)
    S_FOREACH       reduce using rule 150 (add-expr -> mult-expr .)
    S_FOR           reduce using rule 150 (add-expr -> mult-expr .)
    S_WHILE         reduce using rule 150 (add-expr -> mult-expr .)
    S_ITERATE       reduce using rule 150 (add-expr -> mult-expr .)
    S_ELSE          reduce using rule 150 (add-expr -> mult-expr .)
    ID              reduce using rule 150 (add-expr -> mult-expr .)
    C_APP           reduce using rule 150 (add-expr -> mult-expr .)
    LPAREN          reduce using rule 150 (add-expr -> mult-expr .)
    class_INT       reduce using rule 150 (add-expr -> mult-expr .)
    class_DOUBLE    reduce using rule 150 (add-expr -> mult-expr .)
    class_FLOAT     reduce using rule 150 (add-expr -> mult-expr .)
    class_VOID      reduce using rule 150 (add-expr -> mult-expr .)
    class_UINT      reduce using rule 150 (add-expr -> mult-expr .)
    class_BOOL      reduce using rule 150 (add-expr -> mult-expr .)
    class_CHARACTER reduce using rule 150 (add-expr -> mult-expr .)
    class_String    reduce using rule 150 (add-expr -> mult-expr .)
    collection_SET  reduce using rule 150 (add-expr -> mult-expr .)
    collection_ARRAY reduce using rule 150 (add-expr -> mult-expr .)
    collection_DICT reduce using rule 150 (add-expr -> mult-expr .)
    $end            reduce using rule 150 (add-expr -> mult-expr .)
    ARROW           reduce using rule 150 (add-expr -> mult-expr .)
    RBRACE          reduce using rule 150 (add-expr -> mult-expr .)
    S_CASE          reduce using rule 150 (add-expr -> mult-expr .)
    S_DEFAULT       reduce using rule 150 (add-expr -> mult-expr .)
    COLON           reduce using rule 150 (add-expr -> mult-expr .)
    E_STDIN         reduce using rule 150 (add-expr -> mult-expr .)
    E_STDOUT        reduce using rule 150 (add-expr -> mult-expr .)
    E_STDERR        reduce using rule 150 (add-expr -> mult-expr .)
    MULT            shift and go to state 220
    DIV             shift and go to state 221
    MULTPER         shift and go to state 222
    DOUBLEPER       shift and go to state 223
    MOD             shift and go to state 224

    mult-sign                      shift and go to state 219

state 123

    (154) mult-expr -> unary-expr .

    MULT            reduce using rule 154 (mult-expr -> unary-expr .)
    DIV             reduce using rule 154 (mult-expr -> unary-expr .)
    MULTPER         reduce using rule 154 (mult-expr -> unary-expr .)
    DOUBLEPER       reduce using rule 154 (mult-expr -> unary-expr .)
    MOD             reduce using rule 154 (mult-expr -> unary-expr .)
    PLUS            reduce using rule 154 (mult-expr -> unary-expr .)
    MINUS           reduce using rule 154 (mult-expr -> unary-expr .)
    LESS            reduce using rule 154 (mult-expr -> unary-expr .)
    LESS_EQ         reduce using rule 154 (mult-expr -> unary-expr .)
    EQUAL           reduce using rule 154 (mult-expr -> unary-expr .)
    GREATER         reduce using rule 154 (mult-expr -> unary-expr .)
    GREATER_EQ      reduce using rule 154 (mult-expr -> unary-expr .)
    NOT_EQUAL       reduce using rule 154 (mult-expr -> unary-expr .)
    LOG_AND         reduce using rule 154 (mult-expr -> unary-expr .)
    LOG_OR          reduce using rule 154 (mult-expr -> unary-expr .)
    RBRACKET        reduce using rule 154 (mult-expr -> unary-expr .)
    SEMICOLON       reduce using rule 154 (mult-expr -> unary-expr .)
    COMMA           reduce using rule 154 (mult-expr -> unary-expr .)
    RPAREN          reduce using rule 154 (mult-expr -> unary-expr .)
    C_GLOBAL        reduce using rule 154 (mult-expr -> unary-expr .)
    D_IMPORT        reduce using rule 154 (mult-expr -> unary-expr .)
    C_PRAGMA        reduce using rule 154 (mult-expr -> unary-expr .)
    LBRACE          reduce using rule 154 (mult-expr -> unary-expr .)
    S_IF            reduce using rule 154 (mult-expr -> unary-expr .)
    S_SWITCH        reduce using rule 154 (mult-expr -> unary-expr .)
    E_WAIT          reduce using rule 154 (mult-expr -> unary-expr .)
    S_FOREACH       reduce using rule 154 (mult-expr -> unary-expr .)
    S_FOR           reduce using rule 154 (mult-expr -> unary-expr .)
    S_WHILE         reduce using rule 154 (mult-expr -> unary-expr .)
    S_ITERATE       reduce using rule 154 (mult-expr -> unary-expr .)
    S_ELSE          reduce using rule 154 (mult-expr -> unary-expr .)
    ID              reduce using rule 154 (mult-expr -> unary-expr .)
    C_APP           reduce using rule 154 (mult-expr -> unary-expr .)
    LPAREN          reduce using rule 154 (mult-expr -> unary-expr .)
    class_INT       reduce using rule 154 (mult-expr -> unary-expr .)
    class_DOUBLE    reduce using rule 154 (mult-expr -> unary-expr .)
    class_FLOAT     reduce using rule 154 (mult-expr -> unary-expr .)
    class_VOID      reduce using rule 154 (mult-expr -> unary-expr .)
    class_UINT      reduce using rule 154 (mult-expr -> unary-expr .)
    class_BOOL      reduce using rule 154 (mult-expr -> unary-expr .)
    class_CHARACTER reduce using rule 154 (mult-expr -> unary-expr .)
    class_String    reduce using rule 154 (mult-expr -> unary-expr .)
    collection_SET  reduce using rule 154 (mult-expr -> unary-expr .)
    collection_ARRAY reduce using rule 154 (mult-expr -> unary-expr .)
    collection_DICT reduce using rule 154 (mult-expr -> unary-expr .)
    $end            reduce using rule 154 (mult-expr -> unary-expr .)
    ARROW           reduce using rule 154 (mult-expr -> unary-expr .)
    RBRACE          reduce using rule 154 (mult-expr -> unary-expr .)
    S_CASE          reduce using rule 154 (mult-expr -> unary-expr .)
    S_DEFAULT       reduce using rule 154 (mult-expr -> unary-expr .)
    COLON           reduce using rule 154 (mult-expr -> unary-expr .)
    E_STDIN         reduce using rule 154 (mult-expr -> unary-expr .)
    E_STDOUT        reduce using rule 154 (mult-expr -> unary-expr .)
    E_STDERR        reduce using rule 154 (mult-expr -> unary-expr .)


state 124

    (161) unary-expr -> postfix-expr .
    (166) postfix-expr -> postfix-expr . array-or-struct
    (167) array-or-struct -> . array-subscript
    (168) array-or-struct -> . struct-subscript
    (169) array-subscript -> . LBRACKET expr RBRACKET
    (170) struct-subscript -> . DOT ID

    MULT            reduce using rule 161 (unary-expr -> postfix-expr .)
    DIV             reduce using rule 161 (unary-expr -> postfix-expr .)
    MULTPER         reduce using rule 161 (unary-expr -> postfix-expr .)
    DOUBLEPER       reduce using rule 161 (unary-expr -> postfix-expr .)
    MOD             reduce using rule 161 (unary-expr -> postfix-expr .)
    PLUS            reduce using rule 161 (unary-expr -> postfix-expr .)
    MINUS           reduce using rule 161 (unary-expr -> postfix-expr .)
    LESS            reduce using rule 161 (unary-expr -> postfix-expr .)
    LESS_EQ         reduce using rule 161 (unary-expr -> postfix-expr .)
    EQUAL           reduce using rule 161 (unary-expr -> postfix-expr .)
    GREATER         reduce using rule 161 (unary-expr -> postfix-expr .)
    GREATER_EQ      reduce using rule 161 (unary-expr -> postfix-expr .)
    NOT_EQUAL       reduce using rule 161 (unary-expr -> postfix-expr .)
    LOG_AND         reduce using rule 161 (unary-expr -> postfix-expr .)
    LOG_OR          reduce using rule 161 (unary-expr -> postfix-expr .)
    RBRACKET        reduce using rule 161 (unary-expr -> postfix-expr .)
    SEMICOLON       reduce using rule 161 (unary-expr -> postfix-expr .)
    COMMA           reduce using rule 161 (unary-expr -> postfix-expr .)
    RPAREN          reduce using rule 161 (unary-expr -> postfix-expr .)
    C_GLOBAL        reduce using rule 161 (unary-expr -> postfix-expr .)
    D_IMPORT        reduce using rule 161 (unary-expr -> postfix-expr .)
    C_PRAGMA        reduce using rule 161 (unary-expr -> postfix-expr .)
    LBRACE          reduce using rule 161 (unary-expr -> postfix-expr .)
    S_IF            reduce using rule 161 (unary-expr -> postfix-expr .)
    S_SWITCH        reduce using rule 161 (unary-expr -> postfix-expr .)
    E_WAIT          reduce using rule 161 (unary-expr -> postfix-expr .)
    S_FOREACH       reduce using rule 161 (unary-expr -> postfix-expr .)
    S_FOR           reduce using rule 161 (unary-expr -> postfix-expr .)
    S_WHILE         reduce using rule 161 (unary-expr -> postfix-expr .)
    S_ITERATE       reduce using rule 161 (unary-expr -> postfix-expr .)
    S_ELSE          reduce using rule 161 (unary-expr -> postfix-expr .)
    ID              reduce using rule 161 (unary-expr -> postfix-expr .)
    C_APP           reduce using rule 161 (unary-expr -> postfix-expr .)
    LPAREN          reduce using rule 161 (unary-expr -> postfix-expr .)
    class_INT       reduce using rule 161 (unary-expr -> postfix-expr .)
    class_DOUBLE    reduce using rule 161 (unary-expr -> postfix-expr .)
    class_FLOAT     reduce using rule 161 (unary-expr -> postfix-expr .)
    class_VOID      reduce using rule 161 (unary-expr -> postfix-expr .)
    class_UINT      reduce using rule 161 (unary-expr -> postfix-expr .)
    class_BOOL      reduce using rule 161 (unary-expr -> postfix-expr .)
    class_CHARACTER reduce using rule 161 (unary-expr -> postfix-expr .)
    class_String    reduce using rule 161 (unary-expr -> postfix-expr .)
    collection_SET  reduce using rule 161 (unary-expr -> postfix-expr .)
    collection_ARRAY reduce using rule 161 (unary-expr -> postfix-expr .)
    collection_DICT reduce using rule 161 (unary-expr -> postfix-expr .)
    $end            reduce using rule 161 (unary-expr -> postfix-expr .)
    ARROW           reduce using rule 161 (unary-expr -> postfix-expr .)
    RBRACE          reduce using rule 161 (unary-expr -> postfix-expr .)
    S_CASE          reduce using rule 161 (unary-expr -> postfix-expr .)
    S_DEFAULT       reduce using rule 161 (unary-expr -> postfix-expr .)
    COLON           reduce using rule 161 (unary-expr -> postfix-expr .)
    E_STDIN         reduce using rule 161 (unary-expr -> postfix-expr .)
    E_STDOUT        reduce using rule 161 (unary-expr -> postfix-expr .)
    E_STDERR        reduce using rule 161 (unary-expr -> postfix-expr .)
    LBRACKET        shift and go to state 70
    DOT             shift and go to state 71

    array-or-struct                shift and go to state 225
    array-subscript                shift and go to state 226
    struct-subscript               shift and go to state 227

state 125

    (162) unary-expr -> minus-or-excl . postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    postfix-expr                   shift and go to state 228
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 126

    (165) postfix-expr -> base-expr .

    LBRACKET        reduce using rule 165 (postfix-expr -> base-expr .)
    DOT             reduce using rule 165 (postfix-expr -> base-expr .)
    MULT            reduce using rule 165 (postfix-expr -> base-expr .)
    DIV             reduce using rule 165 (postfix-expr -> base-expr .)
    MULTPER         reduce using rule 165 (postfix-expr -> base-expr .)
    DOUBLEPER       reduce using rule 165 (postfix-expr -> base-expr .)
    MOD             reduce using rule 165 (postfix-expr -> base-expr .)
    PLUS            reduce using rule 165 (postfix-expr -> base-expr .)
    MINUS           reduce using rule 165 (postfix-expr -> base-expr .)
    LESS            reduce using rule 165 (postfix-expr -> base-expr .)
    LESS_EQ         reduce using rule 165 (postfix-expr -> base-expr .)
    EQUAL           reduce using rule 165 (postfix-expr -> base-expr .)
    GREATER         reduce using rule 165 (postfix-expr -> base-expr .)
    GREATER_EQ      reduce using rule 165 (postfix-expr -> base-expr .)
    NOT_EQUAL       reduce using rule 165 (postfix-expr -> base-expr .)
    LOG_AND         reduce using rule 165 (postfix-expr -> base-expr .)
    LOG_OR          reduce using rule 165 (postfix-expr -> base-expr .)
    RBRACKET        reduce using rule 165 (postfix-expr -> base-expr .)
    SEMICOLON       reduce using rule 165 (postfix-expr -> base-expr .)
    COMMA           reduce using rule 165 (postfix-expr -> base-expr .)
    RPAREN          reduce using rule 165 (postfix-expr -> base-expr .)
    C_GLOBAL        reduce using rule 165 (postfix-expr -> base-expr .)
    D_IMPORT        reduce using rule 165 (postfix-expr -> base-expr .)
    C_PRAGMA        reduce using rule 165 (postfix-expr -> base-expr .)
    LBRACE          reduce using rule 165 (postfix-expr -> base-expr .)
    S_IF            reduce using rule 165 (postfix-expr -> base-expr .)
    S_SWITCH        reduce using rule 165 (postfix-expr -> base-expr .)
    E_WAIT          reduce using rule 165 (postfix-expr -> base-expr .)
    S_FOREACH       reduce using rule 165 (postfix-expr -> base-expr .)
    S_FOR           reduce using rule 165 (postfix-expr -> base-expr .)
    S_WHILE         reduce using rule 165 (postfix-expr -> base-expr .)
    S_ITERATE       reduce using rule 165 (postfix-expr -> base-expr .)
    S_ELSE          reduce using rule 165 (postfix-expr -> base-expr .)
    ID              reduce using rule 165 (postfix-expr -> base-expr .)
    C_APP           reduce using rule 165 (postfix-expr -> base-expr .)
    LPAREN          reduce using rule 165 (postfix-expr -> base-expr .)
    class_INT       reduce using rule 165 (postfix-expr -> base-expr .)
    class_DOUBLE    reduce using rule 165 (postfix-expr -> base-expr .)
    class_FLOAT     reduce using rule 165 (postfix-expr -> base-expr .)
    class_VOID      reduce using rule 165 (postfix-expr -> base-expr .)
    class_UINT      reduce using rule 165 (postfix-expr -> base-expr .)
    class_BOOL      reduce using rule 165 (postfix-expr -> base-expr .)
    class_CHARACTER reduce using rule 165 (postfix-expr -> base-expr .)
    class_String    reduce using rule 165 (postfix-expr -> base-expr .)
    collection_SET  reduce using rule 165 (postfix-expr -> base-expr .)
    collection_ARRAY reduce using rule 165 (postfix-expr -> base-expr .)
    collection_DICT reduce using rule 165 (postfix-expr -> base-expr .)
    $end            reduce using rule 165 (postfix-expr -> base-expr .)
    ARROW           reduce using rule 165 (postfix-expr -> base-expr .)
    RBRACE          reduce using rule 165 (postfix-expr -> base-expr .)
    S_CASE          reduce using rule 165 (postfix-expr -> base-expr .)
    S_DEFAULT       reduce using rule 165 (postfix-expr -> base-expr .)
    COLON           reduce using rule 165 (postfix-expr -> base-expr .)
    E_STDIN         reduce using rule 165 (postfix-expr -> base-expr .)
    E_STDOUT        reduce using rule 165 (postfix-expr -> base-expr .)
    E_STDERR        reduce using rule 165 (postfix-expr -> base-expr .)


state 127

    (163) minus-or-excl -> MINUS .

    LPAREN          reduce using rule 163 (minus-or-excl -> MINUS .)
    STR_LITERAL     reduce using rule 163 (minus-or-excl -> MINUS .)
    MUL_STR_LITERAL reduce using rule 163 (minus-or-excl -> MINUS .)
    INT             reduce using rule 163 (minus-or-excl -> MINUS .)
    ID              reduce using rule 163 (minus-or-excl -> MINUS .)
    DOUBLE          reduce using rule 163 (minus-or-excl -> MINUS .)
    INF             reduce using rule 163 (minus-or-excl -> MINUS .)
    NAN             reduce using rule 163 (minus-or-excl -> MINUS .)
    E_TRUE          reduce using rule 163 (minus-or-excl -> MINUS .)
    E_FALSE         reduce using rule 163 (minus-or-excl -> MINUS .)
    LBRACKET        reduce using rule 163 (minus-or-excl -> MINUS .)
    LBRACE          reduce using rule 163 (minus-or-excl -> MINUS .)


state 128

    (164) minus-or-excl -> EXCLAMATION .

    LPAREN          reduce using rule 164 (minus-or-excl -> EXCLAMATION .)
    STR_LITERAL     reduce using rule 164 (minus-or-excl -> EXCLAMATION .)
    MUL_STR_LITERAL reduce using rule 164 (minus-or-excl -> EXCLAMATION .)
    INT             reduce using rule 164 (minus-or-excl -> EXCLAMATION .)
    ID              reduce using rule 164 (minus-or-excl -> EXCLAMATION .)
    DOUBLE          reduce using rule 164 (minus-or-excl -> EXCLAMATION .)
    INF             reduce using rule 164 (minus-or-excl -> EXCLAMATION .)
    NAN             reduce using rule 164 (minus-or-excl -> EXCLAMATION .)
    E_TRUE          reduce using rule 164 (minus-or-excl -> EXCLAMATION .)
    E_FALSE         reduce using rule 164 (minus-or-excl -> EXCLAMATION .)
    LBRACKET        reduce using rule 164 (minus-or-excl -> EXCLAMATION .)
    LBRACE          reduce using rule 164 (minus-or-excl -> EXCLAMATION .)


state 129

    (171) base-expr -> literal .

    LBRACKET        reduce using rule 171 (base-expr -> literal .)
    DOT             reduce using rule 171 (base-expr -> literal .)
    MULT            reduce using rule 171 (base-expr -> literal .)
    DIV             reduce using rule 171 (base-expr -> literal .)
    MULTPER         reduce using rule 171 (base-expr -> literal .)
    DOUBLEPER       reduce using rule 171 (base-expr -> literal .)
    MOD             reduce using rule 171 (base-expr -> literal .)
    PLUS            reduce using rule 171 (base-expr -> literal .)
    MINUS           reduce using rule 171 (base-expr -> literal .)
    LESS            reduce using rule 171 (base-expr -> literal .)
    LESS_EQ         reduce using rule 171 (base-expr -> literal .)
    EQUAL           reduce using rule 171 (base-expr -> literal .)
    GREATER         reduce using rule 171 (base-expr -> literal .)
    GREATER_EQ      reduce using rule 171 (base-expr -> literal .)
    NOT_EQUAL       reduce using rule 171 (base-expr -> literal .)
    LOG_AND         reduce using rule 171 (base-expr -> literal .)
    LOG_OR          reduce using rule 171 (base-expr -> literal .)
    RBRACKET        reduce using rule 171 (base-expr -> literal .)
    SEMICOLON       reduce using rule 171 (base-expr -> literal .)
    COMMA           reduce using rule 171 (base-expr -> literal .)
    RPAREN          reduce using rule 171 (base-expr -> literal .)
    C_GLOBAL        reduce using rule 171 (base-expr -> literal .)
    D_IMPORT        reduce using rule 171 (base-expr -> literal .)
    C_PRAGMA        reduce using rule 171 (base-expr -> literal .)
    LBRACE          reduce using rule 171 (base-expr -> literal .)
    S_IF            reduce using rule 171 (base-expr -> literal .)
    S_SWITCH        reduce using rule 171 (base-expr -> literal .)
    E_WAIT          reduce using rule 171 (base-expr -> literal .)
    S_FOREACH       reduce using rule 171 (base-expr -> literal .)
    S_FOR           reduce using rule 171 (base-expr -> literal .)
    S_WHILE         reduce using rule 171 (base-expr -> literal .)
    S_ITERATE       reduce using rule 171 (base-expr -> literal .)
    S_ELSE          reduce using rule 171 (base-expr -> literal .)
    ID              reduce using rule 171 (base-expr -> literal .)
    C_APP           reduce using rule 171 (base-expr -> literal .)
    LPAREN          reduce using rule 171 (base-expr -> literal .)
    class_INT       reduce using rule 171 (base-expr -> literal .)
    class_DOUBLE    reduce using rule 171 (base-expr -> literal .)
    class_FLOAT     reduce using rule 171 (base-expr -> literal .)
    class_VOID      reduce using rule 171 (base-expr -> literal .)
    class_UINT      reduce using rule 171 (base-expr -> literal .)
    class_BOOL      reduce using rule 171 (base-expr -> literal .)
    class_CHARACTER reduce using rule 171 (base-expr -> literal .)
    class_String    reduce using rule 171 (base-expr -> literal .)
    collection_SET  reduce using rule 171 (base-expr -> literal .)
    collection_ARRAY reduce using rule 171 (base-expr -> literal .)
    collection_DICT reduce using rule 171 (base-expr -> literal .)
    $end            reduce using rule 171 (base-expr -> literal .)
    ARROW           reduce using rule 171 (base-expr -> literal .)
    RBRACE          reduce using rule 171 (base-expr -> literal .)
    S_CASE          reduce using rule 171 (base-expr -> literal .)
    S_DEFAULT       reduce using rule 171 (base-expr -> literal .)
    COLON           reduce using rule 171 (base-expr -> literal .)
    E_STDIN         reduce using rule 171 (base-expr -> literal .)
    E_STDOUT        reduce using rule 171 (base-expr -> literal .)
    E_STDERR        reduce using rule 171 (base-expr -> literal .)


state 130

    (172) base-expr -> func-call .

    LBRACKET        reduce using rule 172 (base-expr -> func-call .)
    DOT             reduce using rule 172 (base-expr -> func-call .)
    MULT            reduce using rule 172 (base-expr -> func-call .)
    DIV             reduce using rule 172 (base-expr -> func-call .)
    MULTPER         reduce using rule 172 (base-expr -> func-call .)
    DOUBLEPER       reduce using rule 172 (base-expr -> func-call .)
    MOD             reduce using rule 172 (base-expr -> func-call .)
    PLUS            reduce using rule 172 (base-expr -> func-call .)
    MINUS           reduce using rule 172 (base-expr -> func-call .)
    LESS            reduce using rule 172 (base-expr -> func-call .)
    LESS_EQ         reduce using rule 172 (base-expr -> func-call .)
    EQUAL           reduce using rule 172 (base-expr -> func-call .)
    GREATER         reduce using rule 172 (base-expr -> func-call .)
    GREATER_EQ      reduce using rule 172 (base-expr -> func-call .)
    NOT_EQUAL       reduce using rule 172 (base-expr -> func-call .)
    LOG_AND         reduce using rule 172 (base-expr -> func-call .)
    LOG_OR          reduce using rule 172 (base-expr -> func-call .)
    RBRACKET        reduce using rule 172 (base-expr -> func-call .)
    SEMICOLON       reduce using rule 172 (base-expr -> func-call .)
    COMMA           reduce using rule 172 (base-expr -> func-call .)
    RPAREN          reduce using rule 172 (base-expr -> func-call .)
    C_GLOBAL        reduce using rule 172 (base-expr -> func-call .)
    D_IMPORT        reduce using rule 172 (base-expr -> func-call .)
    C_PRAGMA        reduce using rule 172 (base-expr -> func-call .)
    LBRACE          reduce using rule 172 (base-expr -> func-call .)
    S_IF            reduce using rule 172 (base-expr -> func-call .)
    S_SWITCH        reduce using rule 172 (base-expr -> func-call .)
    E_WAIT          reduce using rule 172 (base-expr -> func-call .)
    S_FOREACH       reduce using rule 172 (base-expr -> func-call .)
    S_FOR           reduce using rule 172 (base-expr -> func-call .)
    S_WHILE         reduce using rule 172 (base-expr -> func-call .)
    S_ITERATE       reduce using rule 172 (base-expr -> func-call .)
    S_ELSE          reduce using rule 172 (base-expr -> func-call .)
    ID              reduce using rule 172 (base-expr -> func-call .)
    C_APP           reduce using rule 172 (base-expr -> func-call .)
    LPAREN          reduce using rule 172 (base-expr -> func-call .)
    class_INT       reduce using rule 172 (base-expr -> func-call .)
    class_DOUBLE    reduce using rule 172 (base-expr -> func-call .)
    class_FLOAT     reduce using rule 172 (base-expr -> func-call .)
    class_VOID      reduce using rule 172 (base-expr -> func-call .)
    class_UINT      reduce using rule 172 (base-expr -> func-call .)
    class_BOOL      reduce using rule 172 (base-expr -> func-call .)
    class_CHARACTER reduce using rule 172 (base-expr -> func-call .)
    class_String    reduce using rule 172 (base-expr -> func-call .)
    collection_SET  reduce using rule 172 (base-expr -> func-call .)
    collection_ARRAY reduce using rule 172 (base-expr -> func-call .)
    collection_DICT reduce using rule 172 (base-expr -> func-call .)
    $end            reduce using rule 172 (base-expr -> func-call .)
    ARROW           reduce using rule 172 (base-expr -> func-call .)
    RBRACE          reduce using rule 172 (base-expr -> func-call .)
    S_CASE          reduce using rule 172 (base-expr -> func-call .)
    S_DEFAULT       reduce using rule 172 (base-expr -> func-call .)
    COLON           reduce using rule 172 (base-expr -> func-call .)
    E_STDIN         reduce using rule 172 (base-expr -> func-call .)
    E_STDOUT        reduce using rule 172 (base-expr -> func-call .)
    E_STDERR        reduce using rule 172 (base-expr -> func-call .)


state 131

    (173) base-expr -> var-name .

    LBRACKET        reduce using rule 173 (base-expr -> var-name .)
    DOT             reduce using rule 173 (base-expr -> var-name .)
    MULT            reduce using rule 173 (base-expr -> var-name .)
    DIV             reduce using rule 173 (base-expr -> var-name .)
    MULTPER         reduce using rule 173 (base-expr -> var-name .)
    DOUBLEPER       reduce using rule 173 (base-expr -> var-name .)
    MOD             reduce using rule 173 (base-expr -> var-name .)
    PLUS            reduce using rule 173 (base-expr -> var-name .)
    MINUS           reduce using rule 173 (base-expr -> var-name .)
    LESS            reduce using rule 173 (base-expr -> var-name .)
    LESS_EQ         reduce using rule 173 (base-expr -> var-name .)
    EQUAL           reduce using rule 173 (base-expr -> var-name .)
    GREATER         reduce using rule 173 (base-expr -> var-name .)
    GREATER_EQ      reduce using rule 173 (base-expr -> var-name .)
    NOT_EQUAL       reduce using rule 173 (base-expr -> var-name .)
    LOG_AND         reduce using rule 173 (base-expr -> var-name .)
    LOG_OR          reduce using rule 173 (base-expr -> var-name .)
    RBRACKET        reduce using rule 173 (base-expr -> var-name .)
    SEMICOLON       reduce using rule 173 (base-expr -> var-name .)
    COMMA           reduce using rule 173 (base-expr -> var-name .)
    RPAREN          reduce using rule 173 (base-expr -> var-name .)
    C_GLOBAL        reduce using rule 173 (base-expr -> var-name .)
    D_IMPORT        reduce using rule 173 (base-expr -> var-name .)
    C_PRAGMA        reduce using rule 173 (base-expr -> var-name .)
    LBRACE          reduce using rule 173 (base-expr -> var-name .)
    S_IF            reduce using rule 173 (base-expr -> var-name .)
    S_SWITCH        reduce using rule 173 (base-expr -> var-name .)
    E_WAIT          reduce using rule 173 (base-expr -> var-name .)
    S_FOREACH       reduce using rule 173 (base-expr -> var-name .)
    S_FOR           reduce using rule 173 (base-expr -> var-name .)
    S_WHILE         reduce using rule 173 (base-expr -> var-name .)
    S_ITERATE       reduce using rule 173 (base-expr -> var-name .)
    S_ELSE          reduce using rule 173 (base-expr -> var-name .)
    ID              reduce using rule 173 (base-expr -> var-name .)
    C_APP           reduce using rule 173 (base-expr -> var-name .)
    LPAREN          reduce using rule 173 (base-expr -> var-name .)
    class_INT       reduce using rule 173 (base-expr -> var-name .)
    class_DOUBLE    reduce using rule 173 (base-expr -> var-name .)
    class_FLOAT     reduce using rule 173 (base-expr -> var-name .)
    class_VOID      reduce using rule 173 (base-expr -> var-name .)
    class_UINT      reduce using rule 173 (base-expr -> var-name .)
    class_BOOL      reduce using rule 173 (base-expr -> var-name .)
    class_CHARACTER reduce using rule 173 (base-expr -> var-name .)
    class_String    reduce using rule 173 (base-expr -> var-name .)
    collection_SET  reduce using rule 173 (base-expr -> var-name .)
    collection_ARRAY reduce using rule 173 (base-expr -> var-name .)
    collection_DICT reduce using rule 173 (base-expr -> var-name .)
    $end            reduce using rule 173 (base-expr -> var-name .)
    ARROW           reduce using rule 173 (base-expr -> var-name .)
    RBRACE          reduce using rule 173 (base-expr -> var-name .)
    S_CASE          reduce using rule 173 (base-expr -> var-name .)
    S_DEFAULT       reduce using rule 173 (base-expr -> var-name .)
    COLON           reduce using rule 173 (base-expr -> var-name .)
    E_STDIN         reduce using rule 173 (base-expr -> var-name .)
    E_STDOUT        reduce using rule 173 (base-expr -> var-name .)
    E_STDERR        reduce using rule 173 (base-expr -> var-name .)


state 132

    (174) base-expr -> LPAREN . expr RPAREN
    (184) -constructor -> LPAREN . expr COMMA expr comma-expr-star RPAREN
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 229
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 133

    (175) base-expr -> -constructor .

    LBRACKET        reduce using rule 175 (base-expr -> -constructor .)
    DOT             reduce using rule 175 (base-expr -> -constructor .)
    MULT            reduce using rule 175 (base-expr -> -constructor .)
    DIV             reduce using rule 175 (base-expr -> -constructor .)
    MULTPER         reduce using rule 175 (base-expr -> -constructor .)
    DOUBLEPER       reduce using rule 175 (base-expr -> -constructor .)
    MOD             reduce using rule 175 (base-expr -> -constructor .)
    PLUS            reduce using rule 175 (base-expr -> -constructor .)
    MINUS           reduce using rule 175 (base-expr -> -constructor .)
    LESS            reduce using rule 175 (base-expr -> -constructor .)
    LESS_EQ         reduce using rule 175 (base-expr -> -constructor .)
    EQUAL           reduce using rule 175 (base-expr -> -constructor .)
    GREATER         reduce using rule 175 (base-expr -> -constructor .)
    GREATER_EQ      reduce using rule 175 (base-expr -> -constructor .)
    NOT_EQUAL       reduce using rule 175 (base-expr -> -constructor .)
    LOG_AND         reduce using rule 175 (base-expr -> -constructor .)
    LOG_OR          reduce using rule 175 (base-expr -> -constructor .)
    RBRACKET        reduce using rule 175 (base-expr -> -constructor .)
    SEMICOLON       reduce using rule 175 (base-expr -> -constructor .)
    COMMA           reduce using rule 175 (base-expr -> -constructor .)
    RPAREN          reduce using rule 175 (base-expr -> -constructor .)
    C_GLOBAL        reduce using rule 175 (base-expr -> -constructor .)
    D_IMPORT        reduce using rule 175 (base-expr -> -constructor .)
    C_PRAGMA        reduce using rule 175 (base-expr -> -constructor .)
    LBRACE          reduce using rule 175 (base-expr -> -constructor .)
    S_IF            reduce using rule 175 (base-expr -> -constructor .)
    S_SWITCH        reduce using rule 175 (base-expr -> -constructor .)
    E_WAIT          reduce using rule 175 (base-expr -> -constructor .)
    S_FOREACH       reduce using rule 175 (base-expr -> -constructor .)
    S_FOR           reduce using rule 175 (base-expr -> -constructor .)
    S_WHILE         reduce using rule 175 (base-expr -> -constructor .)
    S_ITERATE       reduce using rule 175 (base-expr -> -constructor .)
    S_ELSE          reduce using rule 175 (base-expr -> -constructor .)
    ID              reduce using rule 175 (base-expr -> -constructor .)
    C_APP           reduce using rule 175 (base-expr -> -constructor .)
    LPAREN          reduce using rule 175 (base-expr -> -constructor .)
    class_INT       reduce using rule 175 (base-expr -> -constructor .)
    class_DOUBLE    reduce using rule 175 (base-expr -> -constructor .)
    class_FLOAT     reduce using rule 175 (base-expr -> -constructor .)
    class_VOID      reduce using rule 175 (base-expr -> -constructor .)
    class_UINT      reduce using rule 175 (base-expr -> -constructor .)
    class_BOOL      reduce using rule 175 (base-expr -> -constructor .)
    class_CHARACTER reduce using rule 175 (base-expr -> -constructor .)
    class_String    reduce using rule 175 (base-expr -> -constructor .)
    collection_SET  reduce using rule 175 (base-expr -> -constructor .)
    collection_ARRAY reduce using rule 175 (base-expr -> -constructor .)
    collection_DICT reduce using rule 175 (base-expr -> -constructor .)
    $end            reduce using rule 175 (base-expr -> -constructor .)
    ARROW           reduce using rule 175 (base-expr -> -constructor .)
    RBRACE          reduce using rule 175 (base-expr -> -constructor .)
    S_CASE          reduce using rule 175 (base-expr -> -constructor .)
    S_DEFAULT       reduce using rule 175 (base-expr -> -constructor .)
    COLON           reduce using rule 175 (base-expr -> -constructor .)
    E_STDIN         reduce using rule 175 (base-expr -> -constructor .)
    E_STDOUT        reduce using rule 175 (base-expr -> -constructor .)
    E_STDERR        reduce using rule 175 (base-expr -> -constructor .)


state 134

    (176) base-expr -> array-constructor .

    LBRACKET        reduce using rule 176 (base-expr -> array-constructor .)
    DOT             reduce using rule 176 (base-expr -> array-constructor .)
    MULT            reduce using rule 176 (base-expr -> array-constructor .)
    DIV             reduce using rule 176 (base-expr -> array-constructor .)
    MULTPER         reduce using rule 176 (base-expr -> array-constructor .)
    DOUBLEPER       reduce using rule 176 (base-expr -> array-constructor .)
    MOD             reduce using rule 176 (base-expr -> array-constructor .)
    PLUS            reduce using rule 176 (base-expr -> array-constructor .)
    MINUS           reduce using rule 176 (base-expr -> array-constructor .)
    LESS            reduce using rule 176 (base-expr -> array-constructor .)
    LESS_EQ         reduce using rule 176 (base-expr -> array-constructor .)
    EQUAL           reduce using rule 176 (base-expr -> array-constructor .)
    GREATER         reduce using rule 176 (base-expr -> array-constructor .)
    GREATER_EQ      reduce using rule 176 (base-expr -> array-constructor .)
    NOT_EQUAL       reduce using rule 176 (base-expr -> array-constructor .)
    LOG_AND         reduce using rule 176 (base-expr -> array-constructor .)
    LOG_OR          reduce using rule 176 (base-expr -> array-constructor .)
    RBRACKET        reduce using rule 176 (base-expr -> array-constructor .)
    SEMICOLON       reduce using rule 176 (base-expr -> array-constructor .)
    COMMA           reduce using rule 176 (base-expr -> array-constructor .)
    RPAREN          reduce using rule 176 (base-expr -> array-constructor .)
    C_GLOBAL        reduce using rule 176 (base-expr -> array-constructor .)
    D_IMPORT        reduce using rule 176 (base-expr -> array-constructor .)
    C_PRAGMA        reduce using rule 176 (base-expr -> array-constructor .)
    LBRACE          reduce using rule 176 (base-expr -> array-constructor .)
    S_IF            reduce using rule 176 (base-expr -> array-constructor .)
    S_SWITCH        reduce using rule 176 (base-expr -> array-constructor .)
    E_WAIT          reduce using rule 176 (base-expr -> array-constructor .)
    S_FOREACH       reduce using rule 176 (base-expr -> array-constructor .)
    S_FOR           reduce using rule 176 (base-expr -> array-constructor .)
    S_WHILE         reduce using rule 176 (base-expr -> array-constructor .)
    S_ITERATE       reduce using rule 176 (base-expr -> array-constructor .)
    S_ELSE          reduce using rule 176 (base-expr -> array-constructor .)
    ID              reduce using rule 176 (base-expr -> array-constructor .)
    C_APP           reduce using rule 176 (base-expr -> array-constructor .)
    LPAREN          reduce using rule 176 (base-expr -> array-constructor .)
    class_INT       reduce using rule 176 (base-expr -> array-constructor .)
    class_DOUBLE    reduce using rule 176 (base-expr -> array-constructor .)
    class_FLOAT     reduce using rule 176 (base-expr -> array-constructor .)
    class_VOID      reduce using rule 176 (base-expr -> array-constructor .)
    class_UINT      reduce using rule 176 (base-expr -> array-constructor .)
    class_BOOL      reduce using rule 176 (base-expr -> array-constructor .)
    class_CHARACTER reduce using rule 176 (base-expr -> array-constructor .)
    class_String    reduce using rule 176 (base-expr -> array-constructor .)
    collection_SET  reduce using rule 176 (base-expr -> array-constructor .)
    collection_ARRAY reduce using rule 176 (base-expr -> array-constructor .)
    collection_DICT reduce using rule 176 (base-expr -> array-constructor .)
    $end            reduce using rule 176 (base-expr -> array-constructor .)
    ARROW           reduce using rule 176 (base-expr -> array-constructor .)
    RBRACE          reduce using rule 176 (base-expr -> array-constructor .)
    S_CASE          reduce using rule 176 (base-expr -> array-constructor .)
    S_DEFAULT       reduce using rule 176 (base-expr -> array-constructor .)
    COLON           reduce using rule 176 (base-expr -> array-constructor .)
    E_STDIN         reduce using rule 176 (base-expr -> array-constructor .)
    E_STDOUT        reduce using rule 176 (base-expr -> array-constructor .)
    E_STDERR        reduce using rule 176 (base-expr -> array-constructor .)


state 135

    (203) literal -> STR_LITERAL .

    LBRACKET        reduce using rule 203 (literal -> STR_LITERAL .)
    DOT             reduce using rule 203 (literal -> STR_LITERAL .)
    MULT            reduce using rule 203 (literal -> STR_LITERAL .)
    DIV             reduce using rule 203 (literal -> STR_LITERAL .)
    MULTPER         reduce using rule 203 (literal -> STR_LITERAL .)
    DOUBLEPER       reduce using rule 203 (literal -> STR_LITERAL .)
    MOD             reduce using rule 203 (literal -> STR_LITERAL .)
    PLUS            reduce using rule 203 (literal -> STR_LITERAL .)
    MINUS           reduce using rule 203 (literal -> STR_LITERAL .)
    LESS            reduce using rule 203 (literal -> STR_LITERAL .)
    LESS_EQ         reduce using rule 203 (literal -> STR_LITERAL .)
    EQUAL           reduce using rule 203 (literal -> STR_LITERAL .)
    GREATER         reduce using rule 203 (literal -> STR_LITERAL .)
    GREATER_EQ      reduce using rule 203 (literal -> STR_LITERAL .)
    NOT_EQUAL       reduce using rule 203 (literal -> STR_LITERAL .)
    LOG_AND         reduce using rule 203 (literal -> STR_LITERAL .)
    LOG_OR          reduce using rule 203 (literal -> STR_LITERAL .)
    RBRACKET        reduce using rule 203 (literal -> STR_LITERAL .)
    SEMICOLON       reduce using rule 203 (literal -> STR_LITERAL .)
    COMMA           reduce using rule 203 (literal -> STR_LITERAL .)
    RPAREN          reduce using rule 203 (literal -> STR_LITERAL .)
    C_GLOBAL        reduce using rule 203 (literal -> STR_LITERAL .)
    D_IMPORT        reduce using rule 203 (literal -> STR_LITERAL .)
    C_PRAGMA        reduce using rule 203 (literal -> STR_LITERAL .)
    LBRACE          reduce using rule 203 (literal -> STR_LITERAL .)
    S_IF            reduce using rule 203 (literal -> STR_LITERAL .)
    S_SWITCH        reduce using rule 203 (literal -> STR_LITERAL .)
    E_WAIT          reduce using rule 203 (literal -> STR_LITERAL .)
    S_FOREACH       reduce using rule 203 (literal -> STR_LITERAL .)
    S_FOR           reduce using rule 203 (literal -> STR_LITERAL .)
    S_WHILE         reduce using rule 203 (literal -> STR_LITERAL .)
    S_ITERATE       reduce using rule 203 (literal -> STR_LITERAL .)
    S_ELSE          reduce using rule 203 (literal -> STR_LITERAL .)
    ID              reduce using rule 203 (literal -> STR_LITERAL .)
    C_APP           reduce using rule 203 (literal -> STR_LITERAL .)
    LPAREN          reduce using rule 203 (literal -> STR_LITERAL .)
    class_INT       reduce using rule 203 (literal -> STR_LITERAL .)
    class_DOUBLE    reduce using rule 203 (literal -> STR_LITERAL .)
    class_FLOAT     reduce using rule 203 (literal -> STR_LITERAL .)
    class_VOID      reduce using rule 203 (literal -> STR_LITERAL .)
    class_UINT      reduce using rule 203 (literal -> STR_LITERAL .)
    class_BOOL      reduce using rule 203 (literal -> STR_LITERAL .)
    class_CHARACTER reduce using rule 203 (literal -> STR_LITERAL .)
    class_String    reduce using rule 203 (literal -> STR_LITERAL .)
    collection_SET  reduce using rule 203 (literal -> STR_LITERAL .)
    collection_ARRAY reduce using rule 203 (literal -> STR_LITERAL .)
    collection_DICT reduce using rule 203 (literal -> STR_LITERAL .)
    $end            reduce using rule 203 (literal -> STR_LITERAL .)
    ARROW           reduce using rule 203 (literal -> STR_LITERAL .)
    RBRACE          reduce using rule 203 (literal -> STR_LITERAL .)
    S_CASE          reduce using rule 203 (literal -> STR_LITERAL .)
    S_DEFAULT       reduce using rule 203 (literal -> STR_LITERAL .)
    COLON           reduce using rule 203 (literal -> STR_LITERAL .)
    E_STDIN         reduce using rule 203 (literal -> STR_LITERAL .)
    E_STDOUT        reduce using rule 203 (literal -> STR_LITERAL .)
    E_STDERR        reduce using rule 203 (literal -> STR_LITERAL .)
    AT              reduce using rule 203 (literal -> STR_LITERAL .)
    STR_LITERAL     reduce using rule 203 (literal -> STR_LITERAL .)
    MUL_STR_LITERAL reduce using rule 203 (literal -> STR_LITERAL .)
    INT             reduce using rule 203 (literal -> STR_LITERAL .)
    DOUBLE          reduce using rule 203 (literal -> STR_LITERAL .)
    INF             reduce using rule 203 (literal -> STR_LITERAL .)
    NAN             reduce using rule 203 (literal -> STR_LITERAL .)
    E_TRUE          reduce using rule 203 (literal -> STR_LITERAL .)
    E_FALSE         reduce using rule 203 (literal -> STR_LITERAL .)


state 136

    (204) literal -> MUL_STR_LITERAL .

    LBRACKET        reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    DOT             reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    MULT            reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    DIV             reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    MULTPER         reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    DOUBLEPER       reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    MOD             reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    PLUS            reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    MINUS           reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    LESS            reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    LESS_EQ         reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    EQUAL           reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    GREATER         reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    GREATER_EQ      reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    NOT_EQUAL       reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    LOG_AND         reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    LOG_OR          reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    RBRACKET        reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    SEMICOLON       reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    COMMA           reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    RPAREN          reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    C_GLOBAL        reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    D_IMPORT        reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    C_PRAGMA        reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    LBRACE          reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    S_IF            reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    S_SWITCH        reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    E_WAIT          reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    S_FOREACH       reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    S_FOR           reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    S_WHILE         reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    S_ITERATE       reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    S_ELSE          reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    ID              reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    C_APP           reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    LPAREN          reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    class_INT       reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    class_DOUBLE    reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    class_FLOAT     reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    class_VOID      reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    class_UINT      reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    class_BOOL      reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    class_CHARACTER reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    class_String    reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    collection_SET  reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    collection_ARRAY reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    collection_DICT reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    $end            reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    ARROW           reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    RBRACE          reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    S_CASE          reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    S_DEFAULT       reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    COLON           reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    E_STDIN         reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    E_STDOUT        reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    E_STDERR        reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    AT              reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    STR_LITERAL     reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    MUL_STR_LITERAL reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    INT             reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    DOUBLE          reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    INF             reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    NAN             reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    E_TRUE          reduce using rule 204 (literal -> MUL_STR_LITERAL .)
    E_FALSE         reduce using rule 204 (literal -> MUL_STR_LITERAL .)


state 137

    (205) literal -> INT .

    LBRACKET        reduce using rule 205 (literal -> INT .)
    DOT             reduce using rule 205 (literal -> INT .)
    MULT            reduce using rule 205 (literal -> INT .)
    DIV             reduce using rule 205 (literal -> INT .)
    MULTPER         reduce using rule 205 (literal -> INT .)
    DOUBLEPER       reduce using rule 205 (literal -> INT .)
    MOD             reduce using rule 205 (literal -> INT .)
    PLUS            reduce using rule 205 (literal -> INT .)
    MINUS           reduce using rule 205 (literal -> INT .)
    LESS            reduce using rule 205 (literal -> INT .)
    LESS_EQ         reduce using rule 205 (literal -> INT .)
    EQUAL           reduce using rule 205 (literal -> INT .)
    GREATER         reduce using rule 205 (literal -> INT .)
    GREATER_EQ      reduce using rule 205 (literal -> INT .)
    NOT_EQUAL       reduce using rule 205 (literal -> INT .)
    LOG_AND         reduce using rule 205 (literal -> INT .)
    LOG_OR          reduce using rule 205 (literal -> INT .)
    RBRACKET        reduce using rule 205 (literal -> INT .)
    SEMICOLON       reduce using rule 205 (literal -> INT .)
    COMMA           reduce using rule 205 (literal -> INT .)
    RPAREN          reduce using rule 205 (literal -> INT .)
    C_GLOBAL        reduce using rule 205 (literal -> INT .)
    D_IMPORT        reduce using rule 205 (literal -> INT .)
    C_PRAGMA        reduce using rule 205 (literal -> INT .)
    LBRACE          reduce using rule 205 (literal -> INT .)
    S_IF            reduce using rule 205 (literal -> INT .)
    S_SWITCH        reduce using rule 205 (literal -> INT .)
    E_WAIT          reduce using rule 205 (literal -> INT .)
    S_FOREACH       reduce using rule 205 (literal -> INT .)
    S_FOR           reduce using rule 205 (literal -> INT .)
    S_WHILE         reduce using rule 205 (literal -> INT .)
    S_ITERATE       reduce using rule 205 (literal -> INT .)
    S_ELSE          reduce using rule 205 (literal -> INT .)
    ID              reduce using rule 205 (literal -> INT .)
    C_APP           reduce using rule 205 (literal -> INT .)
    LPAREN          reduce using rule 205 (literal -> INT .)
    class_INT       reduce using rule 205 (literal -> INT .)
    class_DOUBLE    reduce using rule 205 (literal -> INT .)
    class_FLOAT     reduce using rule 205 (literal -> INT .)
    class_VOID      reduce using rule 205 (literal -> INT .)
    class_UINT      reduce using rule 205 (literal -> INT .)
    class_BOOL      reduce using rule 205 (literal -> INT .)
    class_CHARACTER reduce using rule 205 (literal -> INT .)
    class_String    reduce using rule 205 (literal -> INT .)
    collection_SET  reduce using rule 205 (literal -> INT .)
    collection_ARRAY reduce using rule 205 (literal -> INT .)
    collection_DICT reduce using rule 205 (literal -> INT .)
    $end            reduce using rule 205 (literal -> INT .)
    ARROW           reduce using rule 205 (literal -> INT .)
    RBRACE          reduce using rule 205 (literal -> INT .)
    S_CASE          reduce using rule 205 (literal -> INT .)
    S_DEFAULT       reduce using rule 205 (literal -> INT .)
    COLON           reduce using rule 205 (literal -> INT .)
    E_STDIN         reduce using rule 205 (literal -> INT .)
    E_STDOUT        reduce using rule 205 (literal -> INT .)
    E_STDERR        reduce using rule 205 (literal -> INT .)
    AT              reduce using rule 205 (literal -> INT .)
    STR_LITERAL     reduce using rule 205 (literal -> INT .)
    MUL_STR_LITERAL reduce using rule 205 (literal -> INT .)
    INT             reduce using rule 205 (literal -> INT .)
    DOUBLE          reduce using rule 205 (literal -> INT .)
    INF             reduce using rule 205 (literal -> INT .)
    NAN             reduce using rule 205 (literal -> INT .)
    E_TRUE          reduce using rule 205 (literal -> INT .)
    E_FALSE         reduce using rule 205 (literal -> INT .)


state 138

    (206) literal -> float-literal .

    LBRACKET        reduce using rule 206 (literal -> float-literal .)
    DOT             reduce using rule 206 (literal -> float-literal .)
    MULT            reduce using rule 206 (literal -> float-literal .)
    DIV             reduce using rule 206 (literal -> float-literal .)
    MULTPER         reduce using rule 206 (literal -> float-literal .)
    DOUBLEPER       reduce using rule 206 (literal -> float-literal .)
    MOD             reduce using rule 206 (literal -> float-literal .)
    PLUS            reduce using rule 206 (literal -> float-literal .)
    MINUS           reduce using rule 206 (literal -> float-literal .)
    LESS            reduce using rule 206 (literal -> float-literal .)
    LESS_EQ         reduce using rule 206 (literal -> float-literal .)
    EQUAL           reduce using rule 206 (literal -> float-literal .)
    GREATER         reduce using rule 206 (literal -> float-literal .)
    GREATER_EQ      reduce using rule 206 (literal -> float-literal .)
    NOT_EQUAL       reduce using rule 206 (literal -> float-literal .)
    LOG_AND         reduce using rule 206 (literal -> float-literal .)
    LOG_OR          reduce using rule 206 (literal -> float-literal .)
    RBRACKET        reduce using rule 206 (literal -> float-literal .)
    SEMICOLON       reduce using rule 206 (literal -> float-literal .)
    COMMA           reduce using rule 206 (literal -> float-literal .)
    RPAREN          reduce using rule 206 (literal -> float-literal .)
    C_GLOBAL        reduce using rule 206 (literal -> float-literal .)
    D_IMPORT        reduce using rule 206 (literal -> float-literal .)
    C_PRAGMA        reduce using rule 206 (literal -> float-literal .)
    LBRACE          reduce using rule 206 (literal -> float-literal .)
    S_IF            reduce using rule 206 (literal -> float-literal .)
    S_SWITCH        reduce using rule 206 (literal -> float-literal .)
    E_WAIT          reduce using rule 206 (literal -> float-literal .)
    S_FOREACH       reduce using rule 206 (literal -> float-literal .)
    S_FOR           reduce using rule 206 (literal -> float-literal .)
    S_WHILE         reduce using rule 206 (literal -> float-literal .)
    S_ITERATE       reduce using rule 206 (literal -> float-literal .)
    S_ELSE          reduce using rule 206 (literal -> float-literal .)
    ID              reduce using rule 206 (literal -> float-literal .)
    C_APP           reduce using rule 206 (literal -> float-literal .)
    LPAREN          reduce using rule 206 (literal -> float-literal .)
    class_INT       reduce using rule 206 (literal -> float-literal .)
    class_DOUBLE    reduce using rule 206 (literal -> float-literal .)
    class_FLOAT     reduce using rule 206 (literal -> float-literal .)
    class_VOID      reduce using rule 206 (literal -> float-literal .)
    class_UINT      reduce using rule 206 (literal -> float-literal .)
    class_BOOL      reduce using rule 206 (literal -> float-literal .)
    class_CHARACTER reduce using rule 206 (literal -> float-literal .)
    class_String    reduce using rule 206 (literal -> float-literal .)
    collection_SET  reduce using rule 206 (literal -> float-literal .)
    collection_ARRAY reduce using rule 206 (literal -> float-literal .)
    collection_DICT reduce using rule 206 (literal -> float-literal .)
    $end            reduce using rule 206 (literal -> float-literal .)
    ARROW           reduce using rule 206 (literal -> float-literal .)
    RBRACE          reduce using rule 206 (literal -> float-literal .)
    S_CASE          reduce using rule 206 (literal -> float-literal .)
    S_DEFAULT       reduce using rule 206 (literal -> float-literal .)
    COLON           reduce using rule 206 (literal -> float-literal .)
    E_STDIN         reduce using rule 206 (literal -> float-literal .)
    E_STDOUT        reduce using rule 206 (literal -> float-literal .)
    E_STDERR        reduce using rule 206 (literal -> float-literal .)
    AT              reduce using rule 206 (literal -> float-literal .)
    STR_LITERAL     reduce using rule 206 (literal -> float-literal .)
    MUL_STR_LITERAL reduce using rule 206 (literal -> float-literal .)
    INT             reduce using rule 206 (literal -> float-literal .)
    DOUBLE          reduce using rule 206 (literal -> float-literal .)
    INF             reduce using rule 206 (literal -> float-literal .)
    NAN             reduce using rule 206 (literal -> float-literal .)
    E_TRUE          reduce using rule 206 (literal -> float-literal .)
    E_FALSE         reduce using rule 206 (literal -> float-literal .)


state 139

    (207) literal -> bool-literal .

    LBRACKET        reduce using rule 207 (literal -> bool-literal .)
    DOT             reduce using rule 207 (literal -> bool-literal .)
    MULT            reduce using rule 207 (literal -> bool-literal .)
    DIV             reduce using rule 207 (literal -> bool-literal .)
    MULTPER         reduce using rule 207 (literal -> bool-literal .)
    DOUBLEPER       reduce using rule 207 (literal -> bool-literal .)
    MOD             reduce using rule 207 (literal -> bool-literal .)
    PLUS            reduce using rule 207 (literal -> bool-literal .)
    MINUS           reduce using rule 207 (literal -> bool-literal .)
    LESS            reduce using rule 207 (literal -> bool-literal .)
    LESS_EQ         reduce using rule 207 (literal -> bool-literal .)
    EQUAL           reduce using rule 207 (literal -> bool-literal .)
    GREATER         reduce using rule 207 (literal -> bool-literal .)
    GREATER_EQ      reduce using rule 207 (literal -> bool-literal .)
    NOT_EQUAL       reduce using rule 207 (literal -> bool-literal .)
    LOG_AND         reduce using rule 207 (literal -> bool-literal .)
    LOG_OR          reduce using rule 207 (literal -> bool-literal .)
    RBRACKET        reduce using rule 207 (literal -> bool-literal .)
    SEMICOLON       reduce using rule 207 (literal -> bool-literal .)
    COMMA           reduce using rule 207 (literal -> bool-literal .)
    RPAREN          reduce using rule 207 (literal -> bool-literal .)
    C_GLOBAL        reduce using rule 207 (literal -> bool-literal .)
    D_IMPORT        reduce using rule 207 (literal -> bool-literal .)
    C_PRAGMA        reduce using rule 207 (literal -> bool-literal .)
    LBRACE          reduce using rule 207 (literal -> bool-literal .)
    S_IF            reduce using rule 207 (literal -> bool-literal .)
    S_SWITCH        reduce using rule 207 (literal -> bool-literal .)
    E_WAIT          reduce using rule 207 (literal -> bool-literal .)
    S_FOREACH       reduce using rule 207 (literal -> bool-literal .)
    S_FOR           reduce using rule 207 (literal -> bool-literal .)
    S_WHILE         reduce using rule 207 (literal -> bool-literal .)
    S_ITERATE       reduce using rule 207 (literal -> bool-literal .)
    S_ELSE          reduce using rule 207 (literal -> bool-literal .)
    ID              reduce using rule 207 (literal -> bool-literal .)
    C_APP           reduce using rule 207 (literal -> bool-literal .)
    LPAREN          reduce using rule 207 (literal -> bool-literal .)
    class_INT       reduce using rule 207 (literal -> bool-literal .)
    class_DOUBLE    reduce using rule 207 (literal -> bool-literal .)
    class_FLOAT     reduce using rule 207 (literal -> bool-literal .)
    class_VOID      reduce using rule 207 (literal -> bool-literal .)
    class_UINT      reduce using rule 207 (literal -> bool-literal .)
    class_BOOL      reduce using rule 207 (literal -> bool-literal .)
    class_CHARACTER reduce using rule 207 (literal -> bool-literal .)
    class_String    reduce using rule 207 (literal -> bool-literal .)
    collection_SET  reduce using rule 207 (literal -> bool-literal .)
    collection_ARRAY reduce using rule 207 (literal -> bool-literal .)
    collection_DICT reduce using rule 207 (literal -> bool-literal .)
    $end            reduce using rule 207 (literal -> bool-literal .)
    ARROW           reduce using rule 207 (literal -> bool-literal .)
    RBRACE          reduce using rule 207 (literal -> bool-literal .)
    S_CASE          reduce using rule 207 (literal -> bool-literal .)
    S_DEFAULT       reduce using rule 207 (literal -> bool-literal .)
    COLON           reduce using rule 207 (literal -> bool-literal .)
    E_STDIN         reduce using rule 207 (literal -> bool-literal .)
    E_STDOUT        reduce using rule 207 (literal -> bool-literal .)
    E_STDERR        reduce using rule 207 (literal -> bool-literal .)
    AT              reduce using rule 207 (literal -> bool-literal .)
    STR_LITERAL     reduce using rule 207 (literal -> bool-literal .)
    MUL_STR_LITERAL reduce using rule 207 (literal -> bool-literal .)
    INT             reduce using rule 207 (literal -> bool-literal .)
    DOUBLE          reduce using rule 207 (literal -> bool-literal .)
    INF             reduce using rule 207 (literal -> bool-literal .)
    NAN             reduce using rule 207 (literal -> bool-literal .)
    E_TRUE          reduce using rule 207 (literal -> bool-literal .)
    E_FALSE         reduce using rule 207 (literal -> bool-literal .)


state 140

    (177) func-call -> ID . LPAREN func-call-arg-list RPAREN
    (227) var-name -> ID .

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 77
    LBRACKET        reduce using rule 227 (var-name -> ID .)
    DOT             reduce using rule 227 (var-name -> ID .)
    MULT            reduce using rule 227 (var-name -> ID .)
    DIV             reduce using rule 227 (var-name -> ID .)
    MULTPER         reduce using rule 227 (var-name -> ID .)
    DOUBLEPER       reduce using rule 227 (var-name -> ID .)
    MOD             reduce using rule 227 (var-name -> ID .)
    PLUS            reduce using rule 227 (var-name -> ID .)
    MINUS           reduce using rule 227 (var-name -> ID .)
    LESS            reduce using rule 227 (var-name -> ID .)
    LESS_EQ         reduce using rule 227 (var-name -> ID .)
    EQUAL           reduce using rule 227 (var-name -> ID .)
    GREATER         reduce using rule 227 (var-name -> ID .)
    GREATER_EQ      reduce using rule 227 (var-name -> ID .)
    NOT_EQUAL       reduce using rule 227 (var-name -> ID .)
    LOG_AND         reduce using rule 227 (var-name -> ID .)
    LOG_OR          reduce using rule 227 (var-name -> ID .)
    RBRACKET        reduce using rule 227 (var-name -> ID .)
    SEMICOLON       reduce using rule 227 (var-name -> ID .)
    RPAREN          reduce using rule 227 (var-name -> ID .)
    C_GLOBAL        reduce using rule 227 (var-name -> ID .)
    D_IMPORT        reduce using rule 227 (var-name -> ID .)
    C_PRAGMA        reduce using rule 227 (var-name -> ID .)
    LBRACE          reduce using rule 227 (var-name -> ID .)
    S_IF            reduce using rule 227 (var-name -> ID .)
    S_SWITCH        reduce using rule 227 (var-name -> ID .)
    E_WAIT          reduce using rule 227 (var-name -> ID .)
    S_FOREACH       reduce using rule 227 (var-name -> ID .)
    S_FOR           reduce using rule 227 (var-name -> ID .)
    S_WHILE         reduce using rule 227 (var-name -> ID .)
    S_ITERATE       reduce using rule 227 (var-name -> ID .)
    S_ELSE          reduce using rule 227 (var-name -> ID .)
    ID              reduce using rule 227 (var-name -> ID .)
    C_APP           reduce using rule 227 (var-name -> ID .)
    class_INT       reduce using rule 227 (var-name -> ID .)
    class_DOUBLE    reduce using rule 227 (var-name -> ID .)
    class_FLOAT     reduce using rule 227 (var-name -> ID .)
    class_VOID      reduce using rule 227 (var-name -> ID .)
    class_UINT      reduce using rule 227 (var-name -> ID .)
    class_BOOL      reduce using rule 227 (var-name -> ID .)
    class_CHARACTER reduce using rule 227 (var-name -> ID .)
    class_String    reduce using rule 227 (var-name -> ID .)
    collection_SET  reduce using rule 227 (var-name -> ID .)
    collection_ARRAY reduce using rule 227 (var-name -> ID .)
    collection_DICT reduce using rule 227 (var-name -> ID .)
    $end            reduce using rule 227 (var-name -> ID .)
    ARROW           reduce using rule 227 (var-name -> ID .)
    RBRACE          reduce using rule 227 (var-name -> ID .)
    S_CASE          reduce using rule 227 (var-name -> ID .)
    S_DEFAULT       reduce using rule 227 (var-name -> ID .)
    COLON           reduce using rule 227 (var-name -> ID .)
    COMMA           reduce using rule 227 (var-name -> ID .)
    E_STDIN         reduce using rule 227 (var-name -> ID .)
    E_STDOUT        reduce using rule 227 (var-name -> ID .)
    E_STDERR        reduce using rule 227 (var-name -> ID .)

  ! LPAREN          [ reduce using rule 227 (var-name -> ID .) ]


state 141

    (187) array-constructor -> array-list-constructor .

    LBRACKET        reduce using rule 187 (array-constructor -> array-list-constructor .)
    DOT             reduce using rule 187 (array-constructor -> array-list-constructor .)
    MULT            reduce using rule 187 (array-constructor -> array-list-constructor .)
    DIV             reduce using rule 187 (array-constructor -> array-list-constructor .)
    MULTPER         reduce using rule 187 (array-constructor -> array-list-constructor .)
    DOUBLEPER       reduce using rule 187 (array-constructor -> array-list-constructor .)
    MOD             reduce using rule 187 (array-constructor -> array-list-constructor .)
    PLUS            reduce using rule 187 (array-constructor -> array-list-constructor .)
    MINUS           reduce using rule 187 (array-constructor -> array-list-constructor .)
    LESS            reduce using rule 187 (array-constructor -> array-list-constructor .)
    LESS_EQ         reduce using rule 187 (array-constructor -> array-list-constructor .)
    EQUAL           reduce using rule 187 (array-constructor -> array-list-constructor .)
    GREATER         reduce using rule 187 (array-constructor -> array-list-constructor .)
    GREATER_EQ      reduce using rule 187 (array-constructor -> array-list-constructor .)
    NOT_EQUAL       reduce using rule 187 (array-constructor -> array-list-constructor .)
    LOG_AND         reduce using rule 187 (array-constructor -> array-list-constructor .)
    LOG_OR          reduce using rule 187 (array-constructor -> array-list-constructor .)
    RBRACKET        reduce using rule 187 (array-constructor -> array-list-constructor .)
    SEMICOLON       reduce using rule 187 (array-constructor -> array-list-constructor .)
    COMMA           reduce using rule 187 (array-constructor -> array-list-constructor .)
    RPAREN          reduce using rule 187 (array-constructor -> array-list-constructor .)
    C_GLOBAL        reduce using rule 187 (array-constructor -> array-list-constructor .)
    D_IMPORT        reduce using rule 187 (array-constructor -> array-list-constructor .)
    C_PRAGMA        reduce using rule 187 (array-constructor -> array-list-constructor .)
    LBRACE          reduce using rule 187 (array-constructor -> array-list-constructor .)
    S_IF            reduce using rule 187 (array-constructor -> array-list-constructor .)
    S_SWITCH        reduce using rule 187 (array-constructor -> array-list-constructor .)
    E_WAIT          reduce using rule 187 (array-constructor -> array-list-constructor .)
    S_FOREACH       reduce using rule 187 (array-constructor -> array-list-constructor .)
    S_FOR           reduce using rule 187 (array-constructor -> array-list-constructor .)
    S_WHILE         reduce using rule 187 (array-constructor -> array-list-constructor .)
    S_ITERATE       reduce using rule 187 (array-constructor -> array-list-constructor .)
    S_ELSE          reduce using rule 187 (array-constructor -> array-list-constructor .)
    ID              reduce using rule 187 (array-constructor -> array-list-constructor .)
    C_APP           reduce using rule 187 (array-constructor -> array-list-constructor .)
    LPAREN          reduce using rule 187 (array-constructor -> array-list-constructor .)
    class_INT       reduce using rule 187 (array-constructor -> array-list-constructor .)
    class_DOUBLE    reduce using rule 187 (array-constructor -> array-list-constructor .)
    class_FLOAT     reduce using rule 187 (array-constructor -> array-list-constructor .)
    class_VOID      reduce using rule 187 (array-constructor -> array-list-constructor .)
    class_UINT      reduce using rule 187 (array-constructor -> array-list-constructor .)
    class_BOOL      reduce using rule 187 (array-constructor -> array-list-constructor .)
    class_CHARACTER reduce using rule 187 (array-constructor -> array-list-constructor .)
    class_String    reduce using rule 187 (array-constructor -> array-list-constructor .)
    collection_SET  reduce using rule 187 (array-constructor -> array-list-constructor .)
    collection_ARRAY reduce using rule 187 (array-constructor -> array-list-constructor .)
    collection_DICT reduce using rule 187 (array-constructor -> array-list-constructor .)
    $end            reduce using rule 187 (array-constructor -> array-list-constructor .)
    ARROW           reduce using rule 187 (array-constructor -> array-list-constructor .)
    RBRACE          reduce using rule 187 (array-constructor -> array-list-constructor .)
    S_CASE          reduce using rule 187 (array-constructor -> array-list-constructor .)
    S_DEFAULT       reduce using rule 187 (array-constructor -> array-list-constructor .)
    COLON           reduce using rule 187 (array-constructor -> array-list-constructor .)
    E_STDIN         reduce using rule 187 (array-constructor -> array-list-constructor .)
    E_STDOUT        reduce using rule 187 (array-constructor -> array-list-constructor .)
    E_STDERR        reduce using rule 187 (array-constructor -> array-list-constructor .)
    AT              reduce using rule 187 (array-constructor -> array-list-constructor .)
    STR_LITERAL     reduce using rule 187 (array-constructor -> array-list-constructor .)
    MUL_STR_LITERAL reduce using rule 187 (array-constructor -> array-list-constructor .)
    INT             reduce using rule 187 (array-constructor -> array-list-constructor .)
    DOUBLE          reduce using rule 187 (array-constructor -> array-list-constructor .)
    INF             reduce using rule 187 (array-constructor -> array-list-constructor .)
    NAN             reduce using rule 187 (array-constructor -> array-list-constructor .)
    E_TRUE          reduce using rule 187 (array-constructor -> array-list-constructor .)
    E_FALSE         reduce using rule 187 (array-constructor -> array-list-constructor .)


state 142

    (188) array-constructor -> array-range-constructor .

    LBRACKET        reduce using rule 188 (array-constructor -> array-range-constructor .)
    DOT             reduce using rule 188 (array-constructor -> array-range-constructor .)
    MULT            reduce using rule 188 (array-constructor -> array-range-constructor .)
    DIV             reduce using rule 188 (array-constructor -> array-range-constructor .)
    MULTPER         reduce using rule 188 (array-constructor -> array-range-constructor .)
    DOUBLEPER       reduce using rule 188 (array-constructor -> array-range-constructor .)
    MOD             reduce using rule 188 (array-constructor -> array-range-constructor .)
    PLUS            reduce using rule 188 (array-constructor -> array-range-constructor .)
    MINUS           reduce using rule 188 (array-constructor -> array-range-constructor .)
    LESS            reduce using rule 188 (array-constructor -> array-range-constructor .)
    LESS_EQ         reduce using rule 188 (array-constructor -> array-range-constructor .)
    EQUAL           reduce using rule 188 (array-constructor -> array-range-constructor .)
    GREATER         reduce using rule 188 (array-constructor -> array-range-constructor .)
    GREATER_EQ      reduce using rule 188 (array-constructor -> array-range-constructor .)
    NOT_EQUAL       reduce using rule 188 (array-constructor -> array-range-constructor .)
    LOG_AND         reduce using rule 188 (array-constructor -> array-range-constructor .)
    LOG_OR          reduce using rule 188 (array-constructor -> array-range-constructor .)
    RBRACKET        reduce using rule 188 (array-constructor -> array-range-constructor .)
    SEMICOLON       reduce using rule 188 (array-constructor -> array-range-constructor .)
    COMMA           reduce using rule 188 (array-constructor -> array-range-constructor .)
    RPAREN          reduce using rule 188 (array-constructor -> array-range-constructor .)
    C_GLOBAL        reduce using rule 188 (array-constructor -> array-range-constructor .)
    D_IMPORT        reduce using rule 188 (array-constructor -> array-range-constructor .)
    C_PRAGMA        reduce using rule 188 (array-constructor -> array-range-constructor .)
    LBRACE          reduce using rule 188 (array-constructor -> array-range-constructor .)
    S_IF            reduce using rule 188 (array-constructor -> array-range-constructor .)
    S_SWITCH        reduce using rule 188 (array-constructor -> array-range-constructor .)
    E_WAIT          reduce using rule 188 (array-constructor -> array-range-constructor .)
    S_FOREACH       reduce using rule 188 (array-constructor -> array-range-constructor .)
    S_FOR           reduce using rule 188 (array-constructor -> array-range-constructor .)
    S_WHILE         reduce using rule 188 (array-constructor -> array-range-constructor .)
    S_ITERATE       reduce using rule 188 (array-constructor -> array-range-constructor .)
    S_ELSE          reduce using rule 188 (array-constructor -> array-range-constructor .)
    ID              reduce using rule 188 (array-constructor -> array-range-constructor .)
    C_APP           reduce using rule 188 (array-constructor -> array-range-constructor .)
    LPAREN          reduce using rule 188 (array-constructor -> array-range-constructor .)
    class_INT       reduce using rule 188 (array-constructor -> array-range-constructor .)
    class_DOUBLE    reduce using rule 188 (array-constructor -> array-range-constructor .)
    class_FLOAT     reduce using rule 188 (array-constructor -> array-range-constructor .)
    class_VOID      reduce using rule 188 (array-constructor -> array-range-constructor .)
    class_UINT      reduce using rule 188 (array-constructor -> array-range-constructor .)
    class_BOOL      reduce using rule 188 (array-constructor -> array-range-constructor .)
    class_CHARACTER reduce using rule 188 (array-constructor -> array-range-constructor .)
    class_String    reduce using rule 188 (array-constructor -> array-range-constructor .)
    collection_SET  reduce using rule 188 (array-constructor -> array-range-constructor .)
    collection_ARRAY reduce using rule 188 (array-constructor -> array-range-constructor .)
    collection_DICT reduce using rule 188 (array-constructor -> array-range-constructor .)
    $end            reduce using rule 188 (array-constructor -> array-range-constructor .)
    ARROW           reduce using rule 188 (array-constructor -> array-range-constructor .)
    RBRACE          reduce using rule 188 (array-constructor -> array-range-constructor .)
    S_CASE          reduce using rule 188 (array-constructor -> array-range-constructor .)
    S_DEFAULT       reduce using rule 188 (array-constructor -> array-range-constructor .)
    COLON           reduce using rule 188 (array-constructor -> array-range-constructor .)
    E_STDIN         reduce using rule 188 (array-constructor -> array-range-constructor .)
    E_STDOUT        reduce using rule 188 (array-constructor -> array-range-constructor .)
    E_STDERR        reduce using rule 188 (array-constructor -> array-range-constructor .)
    AT              reduce using rule 188 (array-constructor -> array-range-constructor .)
    STR_LITERAL     reduce using rule 188 (array-constructor -> array-range-constructor .)
    MUL_STR_LITERAL reduce using rule 188 (array-constructor -> array-range-constructor .)
    INT             reduce using rule 188 (array-constructor -> array-range-constructor .)
    DOUBLE          reduce using rule 188 (array-constructor -> array-range-constructor .)
    INF             reduce using rule 188 (array-constructor -> array-range-constructor .)
    NAN             reduce using rule 188 (array-constructor -> array-range-constructor .)
    E_TRUE          reduce using rule 188 (array-constructor -> array-range-constructor .)
    E_FALSE         reduce using rule 188 (array-constructor -> array-range-constructor .)


state 143

    (189) array-constructor -> array-kv-constructor .

    LBRACKET        reduce using rule 189 (array-constructor -> array-kv-constructor .)
    DOT             reduce using rule 189 (array-constructor -> array-kv-constructor .)
    MULT            reduce using rule 189 (array-constructor -> array-kv-constructor .)
    DIV             reduce using rule 189 (array-constructor -> array-kv-constructor .)
    MULTPER         reduce using rule 189 (array-constructor -> array-kv-constructor .)
    DOUBLEPER       reduce using rule 189 (array-constructor -> array-kv-constructor .)
    MOD             reduce using rule 189 (array-constructor -> array-kv-constructor .)
    PLUS            reduce using rule 189 (array-constructor -> array-kv-constructor .)
    MINUS           reduce using rule 189 (array-constructor -> array-kv-constructor .)
    LESS            reduce using rule 189 (array-constructor -> array-kv-constructor .)
    LESS_EQ         reduce using rule 189 (array-constructor -> array-kv-constructor .)
    EQUAL           reduce using rule 189 (array-constructor -> array-kv-constructor .)
    GREATER         reduce using rule 189 (array-constructor -> array-kv-constructor .)
    GREATER_EQ      reduce using rule 189 (array-constructor -> array-kv-constructor .)
    NOT_EQUAL       reduce using rule 189 (array-constructor -> array-kv-constructor .)
    LOG_AND         reduce using rule 189 (array-constructor -> array-kv-constructor .)
    LOG_OR          reduce using rule 189 (array-constructor -> array-kv-constructor .)
    RBRACKET        reduce using rule 189 (array-constructor -> array-kv-constructor .)
    SEMICOLON       reduce using rule 189 (array-constructor -> array-kv-constructor .)
    COMMA           reduce using rule 189 (array-constructor -> array-kv-constructor .)
    RPAREN          reduce using rule 189 (array-constructor -> array-kv-constructor .)
    C_GLOBAL        reduce using rule 189 (array-constructor -> array-kv-constructor .)
    D_IMPORT        reduce using rule 189 (array-constructor -> array-kv-constructor .)
    C_PRAGMA        reduce using rule 189 (array-constructor -> array-kv-constructor .)
    LBRACE          reduce using rule 189 (array-constructor -> array-kv-constructor .)
    S_IF            reduce using rule 189 (array-constructor -> array-kv-constructor .)
    S_SWITCH        reduce using rule 189 (array-constructor -> array-kv-constructor .)
    E_WAIT          reduce using rule 189 (array-constructor -> array-kv-constructor .)
    S_FOREACH       reduce using rule 189 (array-constructor -> array-kv-constructor .)
    S_FOR           reduce using rule 189 (array-constructor -> array-kv-constructor .)
    S_WHILE         reduce using rule 189 (array-constructor -> array-kv-constructor .)
    S_ITERATE       reduce using rule 189 (array-constructor -> array-kv-constructor .)
    S_ELSE          reduce using rule 189 (array-constructor -> array-kv-constructor .)
    ID              reduce using rule 189 (array-constructor -> array-kv-constructor .)
    C_APP           reduce using rule 189 (array-constructor -> array-kv-constructor .)
    LPAREN          reduce using rule 189 (array-constructor -> array-kv-constructor .)
    class_INT       reduce using rule 189 (array-constructor -> array-kv-constructor .)
    class_DOUBLE    reduce using rule 189 (array-constructor -> array-kv-constructor .)
    class_FLOAT     reduce using rule 189 (array-constructor -> array-kv-constructor .)
    class_VOID      reduce using rule 189 (array-constructor -> array-kv-constructor .)
    class_UINT      reduce using rule 189 (array-constructor -> array-kv-constructor .)
    class_BOOL      reduce using rule 189 (array-constructor -> array-kv-constructor .)
    class_CHARACTER reduce using rule 189 (array-constructor -> array-kv-constructor .)
    class_String    reduce using rule 189 (array-constructor -> array-kv-constructor .)
    collection_SET  reduce using rule 189 (array-constructor -> array-kv-constructor .)
    collection_ARRAY reduce using rule 189 (array-constructor -> array-kv-constructor .)
    collection_DICT reduce using rule 189 (array-constructor -> array-kv-constructor .)
    $end            reduce using rule 189 (array-constructor -> array-kv-constructor .)
    ARROW           reduce using rule 189 (array-constructor -> array-kv-constructor .)
    RBRACE          reduce using rule 189 (array-constructor -> array-kv-constructor .)
    S_CASE          reduce using rule 189 (array-constructor -> array-kv-constructor .)
    S_DEFAULT       reduce using rule 189 (array-constructor -> array-kv-constructor .)
    COLON           reduce using rule 189 (array-constructor -> array-kv-constructor .)
    E_STDIN         reduce using rule 189 (array-constructor -> array-kv-constructor .)
    E_STDOUT        reduce using rule 189 (array-constructor -> array-kv-constructor .)
    E_STDERR        reduce using rule 189 (array-constructor -> array-kv-constructor .)
    AT              reduce using rule 189 (array-constructor -> array-kv-constructor .)
    STR_LITERAL     reduce using rule 189 (array-constructor -> array-kv-constructor .)
    MUL_STR_LITERAL reduce using rule 189 (array-constructor -> array-kv-constructor .)
    INT             reduce using rule 189 (array-constructor -> array-kv-constructor .)
    DOUBLE          reduce using rule 189 (array-constructor -> array-kv-constructor .)
    INF             reduce using rule 189 (array-constructor -> array-kv-constructor .)
    NAN             reduce using rule 189 (array-constructor -> array-kv-constructor .)
    E_TRUE          reduce using rule 189 (array-constructor -> array-kv-constructor .)
    E_FALSE         reduce using rule 189 (array-constructor -> array-kv-constructor .)


state 144

    (208) float-literal -> DOUBLE .

    LBRACKET        reduce using rule 208 (float-literal -> DOUBLE .)
    DOT             reduce using rule 208 (float-literal -> DOUBLE .)
    MULT            reduce using rule 208 (float-literal -> DOUBLE .)
    DIV             reduce using rule 208 (float-literal -> DOUBLE .)
    MULTPER         reduce using rule 208 (float-literal -> DOUBLE .)
    DOUBLEPER       reduce using rule 208 (float-literal -> DOUBLE .)
    MOD             reduce using rule 208 (float-literal -> DOUBLE .)
    PLUS            reduce using rule 208 (float-literal -> DOUBLE .)
    MINUS           reduce using rule 208 (float-literal -> DOUBLE .)
    LESS            reduce using rule 208 (float-literal -> DOUBLE .)
    LESS_EQ         reduce using rule 208 (float-literal -> DOUBLE .)
    EQUAL           reduce using rule 208 (float-literal -> DOUBLE .)
    GREATER         reduce using rule 208 (float-literal -> DOUBLE .)
    GREATER_EQ      reduce using rule 208 (float-literal -> DOUBLE .)
    NOT_EQUAL       reduce using rule 208 (float-literal -> DOUBLE .)
    LOG_AND         reduce using rule 208 (float-literal -> DOUBLE .)
    LOG_OR          reduce using rule 208 (float-literal -> DOUBLE .)
    RBRACKET        reduce using rule 208 (float-literal -> DOUBLE .)
    SEMICOLON       reduce using rule 208 (float-literal -> DOUBLE .)
    COMMA           reduce using rule 208 (float-literal -> DOUBLE .)
    RPAREN          reduce using rule 208 (float-literal -> DOUBLE .)
    C_GLOBAL        reduce using rule 208 (float-literal -> DOUBLE .)
    D_IMPORT        reduce using rule 208 (float-literal -> DOUBLE .)
    C_PRAGMA        reduce using rule 208 (float-literal -> DOUBLE .)
    LBRACE          reduce using rule 208 (float-literal -> DOUBLE .)
    S_IF            reduce using rule 208 (float-literal -> DOUBLE .)
    S_SWITCH        reduce using rule 208 (float-literal -> DOUBLE .)
    E_WAIT          reduce using rule 208 (float-literal -> DOUBLE .)
    S_FOREACH       reduce using rule 208 (float-literal -> DOUBLE .)
    S_FOR           reduce using rule 208 (float-literal -> DOUBLE .)
    S_WHILE         reduce using rule 208 (float-literal -> DOUBLE .)
    S_ITERATE       reduce using rule 208 (float-literal -> DOUBLE .)
    S_ELSE          reduce using rule 208 (float-literal -> DOUBLE .)
    ID              reduce using rule 208 (float-literal -> DOUBLE .)
    C_APP           reduce using rule 208 (float-literal -> DOUBLE .)
    LPAREN          reduce using rule 208 (float-literal -> DOUBLE .)
    class_INT       reduce using rule 208 (float-literal -> DOUBLE .)
    class_DOUBLE    reduce using rule 208 (float-literal -> DOUBLE .)
    class_FLOAT     reduce using rule 208 (float-literal -> DOUBLE .)
    class_VOID      reduce using rule 208 (float-literal -> DOUBLE .)
    class_UINT      reduce using rule 208 (float-literal -> DOUBLE .)
    class_BOOL      reduce using rule 208 (float-literal -> DOUBLE .)
    class_CHARACTER reduce using rule 208 (float-literal -> DOUBLE .)
    class_String    reduce using rule 208 (float-literal -> DOUBLE .)
    collection_SET  reduce using rule 208 (float-literal -> DOUBLE .)
    collection_ARRAY reduce using rule 208 (float-literal -> DOUBLE .)
    collection_DICT reduce using rule 208 (float-literal -> DOUBLE .)
    $end            reduce using rule 208 (float-literal -> DOUBLE .)
    ARROW           reduce using rule 208 (float-literal -> DOUBLE .)
    RBRACE          reduce using rule 208 (float-literal -> DOUBLE .)
    S_CASE          reduce using rule 208 (float-literal -> DOUBLE .)
    S_DEFAULT       reduce using rule 208 (float-literal -> DOUBLE .)
    COLON           reduce using rule 208 (float-literal -> DOUBLE .)
    E_STDIN         reduce using rule 208 (float-literal -> DOUBLE .)
    E_STDOUT        reduce using rule 208 (float-literal -> DOUBLE .)
    E_STDERR        reduce using rule 208 (float-literal -> DOUBLE .)
    AT              reduce using rule 208 (float-literal -> DOUBLE .)
    STR_LITERAL     reduce using rule 208 (float-literal -> DOUBLE .)
    MUL_STR_LITERAL reduce using rule 208 (float-literal -> DOUBLE .)
    INT             reduce using rule 208 (float-literal -> DOUBLE .)
    DOUBLE          reduce using rule 208 (float-literal -> DOUBLE .)
    INF             reduce using rule 208 (float-literal -> DOUBLE .)
    NAN             reduce using rule 208 (float-literal -> DOUBLE .)
    E_TRUE          reduce using rule 208 (float-literal -> DOUBLE .)
    E_FALSE         reduce using rule 208 (float-literal -> DOUBLE .)


state 145

    (209) float-literal -> INF .

    LBRACKET        reduce using rule 209 (float-literal -> INF .)
    DOT             reduce using rule 209 (float-literal -> INF .)
    MULT            reduce using rule 209 (float-literal -> INF .)
    DIV             reduce using rule 209 (float-literal -> INF .)
    MULTPER         reduce using rule 209 (float-literal -> INF .)
    DOUBLEPER       reduce using rule 209 (float-literal -> INF .)
    MOD             reduce using rule 209 (float-literal -> INF .)
    PLUS            reduce using rule 209 (float-literal -> INF .)
    MINUS           reduce using rule 209 (float-literal -> INF .)
    LESS            reduce using rule 209 (float-literal -> INF .)
    LESS_EQ         reduce using rule 209 (float-literal -> INF .)
    EQUAL           reduce using rule 209 (float-literal -> INF .)
    GREATER         reduce using rule 209 (float-literal -> INF .)
    GREATER_EQ      reduce using rule 209 (float-literal -> INF .)
    NOT_EQUAL       reduce using rule 209 (float-literal -> INF .)
    LOG_AND         reduce using rule 209 (float-literal -> INF .)
    LOG_OR          reduce using rule 209 (float-literal -> INF .)
    RBRACKET        reduce using rule 209 (float-literal -> INF .)
    SEMICOLON       reduce using rule 209 (float-literal -> INF .)
    COMMA           reduce using rule 209 (float-literal -> INF .)
    RPAREN          reduce using rule 209 (float-literal -> INF .)
    C_GLOBAL        reduce using rule 209 (float-literal -> INF .)
    D_IMPORT        reduce using rule 209 (float-literal -> INF .)
    C_PRAGMA        reduce using rule 209 (float-literal -> INF .)
    LBRACE          reduce using rule 209 (float-literal -> INF .)
    S_IF            reduce using rule 209 (float-literal -> INF .)
    S_SWITCH        reduce using rule 209 (float-literal -> INF .)
    E_WAIT          reduce using rule 209 (float-literal -> INF .)
    S_FOREACH       reduce using rule 209 (float-literal -> INF .)
    S_FOR           reduce using rule 209 (float-literal -> INF .)
    S_WHILE         reduce using rule 209 (float-literal -> INF .)
    S_ITERATE       reduce using rule 209 (float-literal -> INF .)
    S_ELSE          reduce using rule 209 (float-literal -> INF .)
    ID              reduce using rule 209 (float-literal -> INF .)
    C_APP           reduce using rule 209 (float-literal -> INF .)
    LPAREN          reduce using rule 209 (float-literal -> INF .)
    class_INT       reduce using rule 209 (float-literal -> INF .)
    class_DOUBLE    reduce using rule 209 (float-literal -> INF .)
    class_FLOAT     reduce using rule 209 (float-literal -> INF .)
    class_VOID      reduce using rule 209 (float-literal -> INF .)
    class_UINT      reduce using rule 209 (float-literal -> INF .)
    class_BOOL      reduce using rule 209 (float-literal -> INF .)
    class_CHARACTER reduce using rule 209 (float-literal -> INF .)
    class_String    reduce using rule 209 (float-literal -> INF .)
    collection_SET  reduce using rule 209 (float-literal -> INF .)
    collection_ARRAY reduce using rule 209 (float-literal -> INF .)
    collection_DICT reduce using rule 209 (float-literal -> INF .)
    $end            reduce using rule 209 (float-literal -> INF .)
    ARROW           reduce using rule 209 (float-literal -> INF .)
    RBRACE          reduce using rule 209 (float-literal -> INF .)
    S_CASE          reduce using rule 209 (float-literal -> INF .)
    S_DEFAULT       reduce using rule 209 (float-literal -> INF .)
    COLON           reduce using rule 209 (float-literal -> INF .)
    E_STDIN         reduce using rule 209 (float-literal -> INF .)
    E_STDOUT        reduce using rule 209 (float-literal -> INF .)
    E_STDERR        reduce using rule 209 (float-literal -> INF .)
    AT              reduce using rule 209 (float-literal -> INF .)
    STR_LITERAL     reduce using rule 209 (float-literal -> INF .)
    MUL_STR_LITERAL reduce using rule 209 (float-literal -> INF .)
    INT             reduce using rule 209 (float-literal -> INF .)
    DOUBLE          reduce using rule 209 (float-literal -> INF .)
    INF             reduce using rule 209 (float-literal -> INF .)
    NAN             reduce using rule 209 (float-literal -> INF .)
    E_TRUE          reduce using rule 209 (float-literal -> INF .)
    E_FALSE         reduce using rule 209 (float-literal -> INF .)


state 146

    (210) float-literal -> NAN .

    LBRACKET        reduce using rule 210 (float-literal -> NAN .)
    DOT             reduce using rule 210 (float-literal -> NAN .)
    MULT            reduce using rule 210 (float-literal -> NAN .)
    DIV             reduce using rule 210 (float-literal -> NAN .)
    MULTPER         reduce using rule 210 (float-literal -> NAN .)
    DOUBLEPER       reduce using rule 210 (float-literal -> NAN .)
    MOD             reduce using rule 210 (float-literal -> NAN .)
    PLUS            reduce using rule 210 (float-literal -> NAN .)
    MINUS           reduce using rule 210 (float-literal -> NAN .)
    LESS            reduce using rule 210 (float-literal -> NAN .)
    LESS_EQ         reduce using rule 210 (float-literal -> NAN .)
    EQUAL           reduce using rule 210 (float-literal -> NAN .)
    GREATER         reduce using rule 210 (float-literal -> NAN .)
    GREATER_EQ      reduce using rule 210 (float-literal -> NAN .)
    NOT_EQUAL       reduce using rule 210 (float-literal -> NAN .)
    LOG_AND         reduce using rule 210 (float-literal -> NAN .)
    LOG_OR          reduce using rule 210 (float-literal -> NAN .)
    RBRACKET        reduce using rule 210 (float-literal -> NAN .)
    SEMICOLON       reduce using rule 210 (float-literal -> NAN .)
    COMMA           reduce using rule 210 (float-literal -> NAN .)
    RPAREN          reduce using rule 210 (float-literal -> NAN .)
    C_GLOBAL        reduce using rule 210 (float-literal -> NAN .)
    D_IMPORT        reduce using rule 210 (float-literal -> NAN .)
    C_PRAGMA        reduce using rule 210 (float-literal -> NAN .)
    LBRACE          reduce using rule 210 (float-literal -> NAN .)
    S_IF            reduce using rule 210 (float-literal -> NAN .)
    S_SWITCH        reduce using rule 210 (float-literal -> NAN .)
    E_WAIT          reduce using rule 210 (float-literal -> NAN .)
    S_FOREACH       reduce using rule 210 (float-literal -> NAN .)
    S_FOR           reduce using rule 210 (float-literal -> NAN .)
    S_WHILE         reduce using rule 210 (float-literal -> NAN .)
    S_ITERATE       reduce using rule 210 (float-literal -> NAN .)
    S_ELSE          reduce using rule 210 (float-literal -> NAN .)
    ID              reduce using rule 210 (float-literal -> NAN .)
    C_APP           reduce using rule 210 (float-literal -> NAN .)
    LPAREN          reduce using rule 210 (float-literal -> NAN .)
    class_INT       reduce using rule 210 (float-literal -> NAN .)
    class_DOUBLE    reduce using rule 210 (float-literal -> NAN .)
    class_FLOAT     reduce using rule 210 (float-literal -> NAN .)
    class_VOID      reduce using rule 210 (float-literal -> NAN .)
    class_UINT      reduce using rule 210 (float-literal -> NAN .)
    class_BOOL      reduce using rule 210 (float-literal -> NAN .)
    class_CHARACTER reduce using rule 210 (float-literal -> NAN .)
    class_String    reduce using rule 210 (float-literal -> NAN .)
    collection_SET  reduce using rule 210 (float-literal -> NAN .)
    collection_ARRAY reduce using rule 210 (float-literal -> NAN .)
    collection_DICT reduce using rule 210 (float-literal -> NAN .)
    $end            reduce using rule 210 (float-literal -> NAN .)
    ARROW           reduce using rule 210 (float-literal -> NAN .)
    RBRACE          reduce using rule 210 (float-literal -> NAN .)
    S_CASE          reduce using rule 210 (float-literal -> NAN .)
    S_DEFAULT       reduce using rule 210 (float-literal -> NAN .)
    COLON           reduce using rule 210 (float-literal -> NAN .)
    E_STDIN         reduce using rule 210 (float-literal -> NAN .)
    E_STDOUT        reduce using rule 210 (float-literal -> NAN .)
    E_STDERR        reduce using rule 210 (float-literal -> NAN .)
    AT              reduce using rule 210 (float-literal -> NAN .)
    STR_LITERAL     reduce using rule 210 (float-literal -> NAN .)
    MUL_STR_LITERAL reduce using rule 210 (float-literal -> NAN .)
    INT             reduce using rule 210 (float-literal -> NAN .)
    DOUBLE          reduce using rule 210 (float-literal -> NAN .)
    INF             reduce using rule 210 (float-literal -> NAN .)
    NAN             reduce using rule 210 (float-literal -> NAN .)
    E_TRUE          reduce using rule 210 (float-literal -> NAN .)
    E_FALSE         reduce using rule 210 (float-literal -> NAN .)


state 147

    (211) bool-literal -> E_TRUE .

    LBRACKET        reduce using rule 211 (bool-literal -> E_TRUE .)
    DOT             reduce using rule 211 (bool-literal -> E_TRUE .)
    MULT            reduce using rule 211 (bool-literal -> E_TRUE .)
    DIV             reduce using rule 211 (bool-literal -> E_TRUE .)
    MULTPER         reduce using rule 211 (bool-literal -> E_TRUE .)
    DOUBLEPER       reduce using rule 211 (bool-literal -> E_TRUE .)
    MOD             reduce using rule 211 (bool-literal -> E_TRUE .)
    PLUS            reduce using rule 211 (bool-literal -> E_TRUE .)
    MINUS           reduce using rule 211 (bool-literal -> E_TRUE .)
    LESS            reduce using rule 211 (bool-literal -> E_TRUE .)
    LESS_EQ         reduce using rule 211 (bool-literal -> E_TRUE .)
    EQUAL           reduce using rule 211 (bool-literal -> E_TRUE .)
    GREATER         reduce using rule 211 (bool-literal -> E_TRUE .)
    GREATER_EQ      reduce using rule 211 (bool-literal -> E_TRUE .)
    NOT_EQUAL       reduce using rule 211 (bool-literal -> E_TRUE .)
    LOG_AND         reduce using rule 211 (bool-literal -> E_TRUE .)
    LOG_OR          reduce using rule 211 (bool-literal -> E_TRUE .)
    RBRACKET        reduce using rule 211 (bool-literal -> E_TRUE .)
    SEMICOLON       reduce using rule 211 (bool-literal -> E_TRUE .)
    COMMA           reduce using rule 211 (bool-literal -> E_TRUE .)
    RPAREN          reduce using rule 211 (bool-literal -> E_TRUE .)
    C_GLOBAL        reduce using rule 211 (bool-literal -> E_TRUE .)
    D_IMPORT        reduce using rule 211 (bool-literal -> E_TRUE .)
    C_PRAGMA        reduce using rule 211 (bool-literal -> E_TRUE .)
    LBRACE          reduce using rule 211 (bool-literal -> E_TRUE .)
    S_IF            reduce using rule 211 (bool-literal -> E_TRUE .)
    S_SWITCH        reduce using rule 211 (bool-literal -> E_TRUE .)
    E_WAIT          reduce using rule 211 (bool-literal -> E_TRUE .)
    S_FOREACH       reduce using rule 211 (bool-literal -> E_TRUE .)
    S_FOR           reduce using rule 211 (bool-literal -> E_TRUE .)
    S_WHILE         reduce using rule 211 (bool-literal -> E_TRUE .)
    S_ITERATE       reduce using rule 211 (bool-literal -> E_TRUE .)
    S_ELSE          reduce using rule 211 (bool-literal -> E_TRUE .)
    ID              reduce using rule 211 (bool-literal -> E_TRUE .)
    C_APP           reduce using rule 211 (bool-literal -> E_TRUE .)
    LPAREN          reduce using rule 211 (bool-literal -> E_TRUE .)
    class_INT       reduce using rule 211 (bool-literal -> E_TRUE .)
    class_DOUBLE    reduce using rule 211 (bool-literal -> E_TRUE .)
    class_FLOAT     reduce using rule 211 (bool-literal -> E_TRUE .)
    class_VOID      reduce using rule 211 (bool-literal -> E_TRUE .)
    class_UINT      reduce using rule 211 (bool-literal -> E_TRUE .)
    class_BOOL      reduce using rule 211 (bool-literal -> E_TRUE .)
    class_CHARACTER reduce using rule 211 (bool-literal -> E_TRUE .)
    class_String    reduce using rule 211 (bool-literal -> E_TRUE .)
    collection_SET  reduce using rule 211 (bool-literal -> E_TRUE .)
    collection_ARRAY reduce using rule 211 (bool-literal -> E_TRUE .)
    collection_DICT reduce using rule 211 (bool-literal -> E_TRUE .)
    $end            reduce using rule 211 (bool-literal -> E_TRUE .)
    ARROW           reduce using rule 211 (bool-literal -> E_TRUE .)
    RBRACE          reduce using rule 211 (bool-literal -> E_TRUE .)
    S_CASE          reduce using rule 211 (bool-literal -> E_TRUE .)
    S_DEFAULT       reduce using rule 211 (bool-literal -> E_TRUE .)
    COLON           reduce using rule 211 (bool-literal -> E_TRUE .)
    E_STDIN         reduce using rule 211 (bool-literal -> E_TRUE .)
    E_STDOUT        reduce using rule 211 (bool-literal -> E_TRUE .)
    E_STDERR        reduce using rule 211 (bool-literal -> E_TRUE .)
    AT              reduce using rule 211 (bool-literal -> E_TRUE .)
    STR_LITERAL     reduce using rule 211 (bool-literal -> E_TRUE .)
    MUL_STR_LITERAL reduce using rule 211 (bool-literal -> E_TRUE .)
    INT             reduce using rule 211 (bool-literal -> E_TRUE .)
    DOUBLE          reduce using rule 211 (bool-literal -> E_TRUE .)
    INF             reduce using rule 211 (bool-literal -> E_TRUE .)
    NAN             reduce using rule 211 (bool-literal -> E_TRUE .)
    E_TRUE          reduce using rule 211 (bool-literal -> E_TRUE .)
    E_FALSE         reduce using rule 211 (bool-literal -> E_TRUE .)


state 148

    (212) bool-literal -> E_FALSE .

    LBRACKET        reduce using rule 212 (bool-literal -> E_FALSE .)
    DOT             reduce using rule 212 (bool-literal -> E_FALSE .)
    MULT            reduce using rule 212 (bool-literal -> E_FALSE .)
    DIV             reduce using rule 212 (bool-literal -> E_FALSE .)
    MULTPER         reduce using rule 212 (bool-literal -> E_FALSE .)
    DOUBLEPER       reduce using rule 212 (bool-literal -> E_FALSE .)
    MOD             reduce using rule 212 (bool-literal -> E_FALSE .)
    PLUS            reduce using rule 212 (bool-literal -> E_FALSE .)
    MINUS           reduce using rule 212 (bool-literal -> E_FALSE .)
    LESS            reduce using rule 212 (bool-literal -> E_FALSE .)
    LESS_EQ         reduce using rule 212 (bool-literal -> E_FALSE .)
    EQUAL           reduce using rule 212 (bool-literal -> E_FALSE .)
    GREATER         reduce using rule 212 (bool-literal -> E_FALSE .)
    GREATER_EQ      reduce using rule 212 (bool-literal -> E_FALSE .)
    NOT_EQUAL       reduce using rule 212 (bool-literal -> E_FALSE .)
    LOG_AND         reduce using rule 212 (bool-literal -> E_FALSE .)
    LOG_OR          reduce using rule 212 (bool-literal -> E_FALSE .)
    RBRACKET        reduce using rule 212 (bool-literal -> E_FALSE .)
    SEMICOLON       reduce using rule 212 (bool-literal -> E_FALSE .)
    COMMA           reduce using rule 212 (bool-literal -> E_FALSE .)
    RPAREN          reduce using rule 212 (bool-literal -> E_FALSE .)
    C_GLOBAL        reduce using rule 212 (bool-literal -> E_FALSE .)
    D_IMPORT        reduce using rule 212 (bool-literal -> E_FALSE .)
    C_PRAGMA        reduce using rule 212 (bool-literal -> E_FALSE .)
    LBRACE          reduce using rule 212 (bool-literal -> E_FALSE .)
    S_IF            reduce using rule 212 (bool-literal -> E_FALSE .)
    S_SWITCH        reduce using rule 212 (bool-literal -> E_FALSE .)
    E_WAIT          reduce using rule 212 (bool-literal -> E_FALSE .)
    S_FOREACH       reduce using rule 212 (bool-literal -> E_FALSE .)
    S_FOR           reduce using rule 212 (bool-literal -> E_FALSE .)
    S_WHILE         reduce using rule 212 (bool-literal -> E_FALSE .)
    S_ITERATE       reduce using rule 212 (bool-literal -> E_FALSE .)
    S_ELSE          reduce using rule 212 (bool-literal -> E_FALSE .)
    ID              reduce using rule 212 (bool-literal -> E_FALSE .)
    C_APP           reduce using rule 212 (bool-literal -> E_FALSE .)
    LPAREN          reduce using rule 212 (bool-literal -> E_FALSE .)
    class_INT       reduce using rule 212 (bool-literal -> E_FALSE .)
    class_DOUBLE    reduce using rule 212 (bool-literal -> E_FALSE .)
    class_FLOAT     reduce using rule 212 (bool-literal -> E_FALSE .)
    class_VOID      reduce using rule 212 (bool-literal -> E_FALSE .)
    class_UINT      reduce using rule 212 (bool-literal -> E_FALSE .)
    class_BOOL      reduce using rule 212 (bool-literal -> E_FALSE .)
    class_CHARACTER reduce using rule 212 (bool-literal -> E_FALSE .)
    class_String    reduce using rule 212 (bool-literal -> E_FALSE .)
    collection_SET  reduce using rule 212 (bool-literal -> E_FALSE .)
    collection_ARRAY reduce using rule 212 (bool-literal -> E_FALSE .)
    collection_DICT reduce using rule 212 (bool-literal -> E_FALSE .)
    $end            reduce using rule 212 (bool-literal -> E_FALSE .)
    ARROW           reduce using rule 212 (bool-literal -> E_FALSE .)
    RBRACE          reduce using rule 212 (bool-literal -> E_FALSE .)
    S_CASE          reduce using rule 212 (bool-literal -> E_FALSE .)
    S_DEFAULT       reduce using rule 212 (bool-literal -> E_FALSE .)
    COLON           reduce using rule 212 (bool-literal -> E_FALSE .)
    E_STDIN         reduce using rule 212 (bool-literal -> E_FALSE .)
    E_STDOUT        reduce using rule 212 (bool-literal -> E_FALSE .)
    E_STDERR        reduce using rule 212 (bool-literal -> E_FALSE .)
    AT              reduce using rule 212 (bool-literal -> E_FALSE .)
    STR_LITERAL     reduce using rule 212 (bool-literal -> E_FALSE .)
    MUL_STR_LITERAL reduce using rule 212 (bool-literal -> E_FALSE .)
    INT             reduce using rule 212 (bool-literal -> E_FALSE .)
    DOUBLE          reduce using rule 212 (bool-literal -> E_FALSE .)
    INF             reduce using rule 212 (bool-literal -> E_FALSE .)
    NAN             reduce using rule 212 (bool-literal -> E_FALSE .)
    E_TRUE          reduce using rule 212 (bool-literal -> E_FALSE .)
    E_FALSE         reduce using rule 212 (bool-literal -> E_FALSE .)


state 149

    (196) array-kv-constructor -> LBRACE . opt-array-constructor RBRACE
    (197) opt-array-constructor -> . array-kv-elem comma-array-kv-elem-star
    (198) opt-array-constructor -> . empty
    (201) array-kv-elem -> . expr COLON expr
    (76) empty -> .
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    RBRACE          reduce using rule 76 (empty -> .)
    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    opt-array-constructor          shift and go to state 230
    array-kv-elem                  shift and go to state 231
    empty                          shift and go to state 232
    expr                           shift and go to state 233
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 150

    (170) struct-subscript -> DOT ID .

    LBRACKET        reduce using rule 170 (struct-subscript -> DOT ID .)
    DOT             reduce using rule 170 (struct-subscript -> DOT ID .)
    COMMA           reduce using rule 170 (struct-subscript -> DOT ID .)
    ASSIGN          reduce using rule 170 (struct-subscript -> DOT ID .)
    PLUS_AS         reduce using rule 170 (struct-subscript -> DOT ID .)
    RPAREN          reduce using rule 170 (struct-subscript -> DOT ID .)
    MULT            reduce using rule 170 (struct-subscript -> DOT ID .)
    DIV             reduce using rule 170 (struct-subscript -> DOT ID .)
    MULTPER         reduce using rule 170 (struct-subscript -> DOT ID .)
    DOUBLEPER       reduce using rule 170 (struct-subscript -> DOT ID .)
    MOD             reduce using rule 170 (struct-subscript -> DOT ID .)
    PLUS            reduce using rule 170 (struct-subscript -> DOT ID .)
    MINUS           reduce using rule 170 (struct-subscript -> DOT ID .)
    LESS            reduce using rule 170 (struct-subscript -> DOT ID .)
    LESS_EQ         reduce using rule 170 (struct-subscript -> DOT ID .)
    EQUAL           reduce using rule 170 (struct-subscript -> DOT ID .)
    GREATER         reduce using rule 170 (struct-subscript -> DOT ID .)
    GREATER_EQ      reduce using rule 170 (struct-subscript -> DOT ID .)
    NOT_EQUAL       reduce using rule 170 (struct-subscript -> DOT ID .)
    LOG_AND         reduce using rule 170 (struct-subscript -> DOT ID .)
    LOG_OR          reduce using rule 170 (struct-subscript -> DOT ID .)
    RBRACKET        reduce using rule 170 (struct-subscript -> DOT ID .)
    SEMICOLON       reduce using rule 170 (struct-subscript -> DOT ID .)
    C_GLOBAL        reduce using rule 170 (struct-subscript -> DOT ID .)
    D_IMPORT        reduce using rule 170 (struct-subscript -> DOT ID .)
    C_PRAGMA        reduce using rule 170 (struct-subscript -> DOT ID .)
    LBRACE          reduce using rule 170 (struct-subscript -> DOT ID .)
    S_IF            reduce using rule 170 (struct-subscript -> DOT ID .)
    S_SWITCH        reduce using rule 170 (struct-subscript -> DOT ID .)
    E_WAIT          reduce using rule 170 (struct-subscript -> DOT ID .)
    S_FOREACH       reduce using rule 170 (struct-subscript -> DOT ID .)
    S_FOR           reduce using rule 170 (struct-subscript -> DOT ID .)
    S_WHILE         reduce using rule 170 (struct-subscript -> DOT ID .)
    S_ITERATE       reduce using rule 170 (struct-subscript -> DOT ID .)
    S_ELSE          reduce using rule 170 (struct-subscript -> DOT ID .)
    ID              reduce using rule 170 (struct-subscript -> DOT ID .)
    C_APP           reduce using rule 170 (struct-subscript -> DOT ID .)
    LPAREN          reduce using rule 170 (struct-subscript -> DOT ID .)
    class_INT       reduce using rule 170 (struct-subscript -> DOT ID .)
    class_DOUBLE    reduce using rule 170 (struct-subscript -> DOT ID .)
    class_FLOAT     reduce using rule 170 (struct-subscript -> DOT ID .)
    class_VOID      reduce using rule 170 (struct-subscript -> DOT ID .)
    class_UINT      reduce using rule 170 (struct-subscript -> DOT ID .)
    class_BOOL      reduce using rule 170 (struct-subscript -> DOT ID .)
    class_CHARACTER reduce using rule 170 (struct-subscript -> DOT ID .)
    class_String    reduce using rule 170 (struct-subscript -> DOT ID .)
    collection_SET  reduce using rule 170 (struct-subscript -> DOT ID .)
    collection_ARRAY reduce using rule 170 (struct-subscript -> DOT ID .)
    collection_DICT reduce using rule 170 (struct-subscript -> DOT ID .)
    $end            reduce using rule 170 (struct-subscript -> DOT ID .)
    ARROW           reduce using rule 170 (struct-subscript -> DOT ID .)
    RBRACE          reduce using rule 170 (struct-subscript -> DOT ID .)
    S_CASE          reduce using rule 170 (struct-subscript -> DOT ID .)
    S_DEFAULT       reduce using rule 170 (struct-subscript -> DOT ID .)
    COLON           reduce using rule 170 (struct-subscript -> DOT ID .)
    E_STDIN         reduce using rule 170 (struct-subscript -> DOT ID .)
    E_STDOUT        reduce using rule 170 (struct-subscript -> DOT ID .)
    E_STDERR        reduce using rule 170 (struct-subscript -> DOT ID .)


state 151

    (24) global-const-defn -> C_GLOBAL C_CONST var-decl . SEMICOLON

    SEMICOLON       shift and go to state 234


state 152

    (225) type-name -> ID .

    LESS            reduce using rule 225 (type-name -> ID .)
    ID              reduce using rule 225 (type-name -> ID .)
    LBRACKET        reduce using rule 225 (type-name -> ID .)
    GREATER         reduce using rule 225 (type-name -> ID .)
    RANGE           reduce using rule 225 (type-name -> ID .)
    RBRACKET        reduce using rule 225 (type-name -> ID .)


state 153

    (25) import-stmt -> D_IMPORT module-path SEMICOLON .

    SEMICOLON       reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    C_GLOBAL        reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    D_IMPORT        reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    C_PRAGMA        reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    LBRACE          reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_IF            reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_SWITCH        reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    E_WAIT          reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_FOREACH       reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_FOR           reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_WHILE         reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_ITERATE       reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_ELSE          reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    ID              reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    C_APP           reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    LPAREN          reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_INT       reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_DOUBLE    reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_FLOAT     reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_VOID      reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_UINT      reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_BOOL      reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_CHARACTER reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_String    reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    collection_SET  reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    collection_ARRAY reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    collection_DICT reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    LESS            reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    $end            reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    RBRACE          reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_CASE          reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_DEFAULT       reduce using rule 25 (import-stmt -> D_IMPORT module-path SEMICOLON .)


state 154

    (26) import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .

    SEMICOLON       reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    C_GLOBAL        reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    D_IMPORT        reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    C_PRAGMA        reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    LBRACE          reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_IF            reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_SWITCH        reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    E_WAIT          reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_FOREACH       reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_FOR           reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_WHILE         reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_ITERATE       reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_ELSE          reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    ID              reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    C_APP           reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    LPAREN          reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_INT       reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_DOUBLE    reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_FLOAT     reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_VOID      reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_UINT      reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_BOOL      reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_CHARACTER reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_String    reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    collection_SET  reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    collection_ARRAY reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    collection_DICT reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    LESS            reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    $end            reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    RBRACE          reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_CASE          reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_DEFAULT       reduce using rule 26 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)


state 155

    (27) module-path -> ID path-star .

    SEMICOLON       reduce using rule 27 (module-path -> ID path-star .)


state 156

    (28) path-star -> DOT . ID path-star

    ID              shift and go to state 235


state 157

    (30) pragma-stmt -> C_PRAGMA ID expr . SEMICOLON

    SEMICOLON       shift and go to state 236


state 158

    (202) kw-expr -> ID . ASSIGN expr
    (177) func-call -> ID . LPAREN func-call-arg-list RPAREN
    (227) var-name -> ID .

    ASSIGN          shift and go to state 237
    LPAREN          shift and go to state 77
    LBRACKET        reduce using rule 227 (var-name -> ID .)
    DOT             reduce using rule 227 (var-name -> ID .)
    MULT            reduce using rule 227 (var-name -> ID .)
    DIV             reduce using rule 227 (var-name -> ID .)
    MULTPER         reduce using rule 227 (var-name -> ID .)
    DOUBLEPER       reduce using rule 227 (var-name -> ID .)
    MOD             reduce using rule 227 (var-name -> ID .)
    PLUS            reduce using rule 227 (var-name -> ID .)
    MINUS           reduce using rule 227 (var-name -> ID .)
    LESS            reduce using rule 227 (var-name -> ID .)
    LESS_EQ         reduce using rule 227 (var-name -> ID .)
    EQUAL           reduce using rule 227 (var-name -> ID .)
    GREATER         reduce using rule 227 (var-name -> ID .)
    GREATER_EQ      reduce using rule 227 (var-name -> ID .)
    NOT_EQUAL       reduce using rule 227 (var-name -> ID .)
    LOG_AND         reduce using rule 227 (var-name -> ID .)
    LOG_OR          reduce using rule 227 (var-name -> ID .)
    COMMA           reduce using rule 227 (var-name -> ID .)
    RPAREN          reduce using rule 227 (var-name -> ID .)


state 159

    (177) func-call -> ID LPAREN func-call-arg-list . RPAREN

    RPAREN          shift and go to state 238


state 160

    (178) func-call-arg-list -> expr-or-kw . func-call-arg-star
    (179) func-call-arg-star -> . COMMA expr-or-kw func-call-arg-star
    (180) func-call-arg-star -> . empty
    (76) empty -> .

    COMMA           shift and go to state 240
    RPAREN          reduce using rule 76 (empty -> .)

    func-call-arg-star             shift and go to state 239
    empty                          shift and go to state 241

state 161

    (181) expr-or-kw -> expr .

    COMMA           reduce using rule 181 (expr-or-kw -> expr .)
    RPAREN          reduce using rule 181 (expr-or-kw -> expr .)


state 162

    (182) expr-or-kw -> kw-expr .

    COMMA           reduce using rule 182 (expr-or-kw -> kw-expr .)
    RPAREN          reduce using rule 182 (expr-or-kw -> kw-expr .)


state 163

    (183) expr-or-kw -> empty .

    COMMA           reduce using rule 183 (expr-or-kw -> empty .)
    RPAREN          reduce using rule 183 (expr-or-kw -> empty .)


state 164

    (90) block -> LBRACE translation-unit RBRACE .

    SEMICOLON       reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    C_GLOBAL        reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    D_IMPORT        reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    C_PRAGMA        reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    LBRACE          reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    S_IF            reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    S_SWITCH        reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    E_WAIT          reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    S_FOREACH       reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    S_FOR           reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    S_WHILE         reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    S_ITERATE       reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    S_ELSE          reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    ID              reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    C_APP           reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    LPAREN          reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    class_INT       reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    class_DOUBLE    reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    class_FLOAT     reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    class_VOID      reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    class_UINT      reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    class_BOOL      reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    class_CHARACTER reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    class_String    reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    collection_SET  reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    collection_ARRAY reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    collection_DICT reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    LESS            reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    $end            reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    RBRACE          reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    S_CASE          reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    S_DEFAULT       reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)
    S_UNTIL         reduce using rule 90 (block -> LBRACE translation-unit RBRACE .)


state 165

    (106) if-stmt -> S_IF LPAREN expr . RPAREN block opt-else-block

    RPAREN          shift and go to state 242


state 166

    (104) lval-or-paren-lval -> LPAREN lval-list RPAREN .

    ASSIGN          reduce using rule 104 (lval-or-paren-lval -> LPAREN lval-list RPAREN .)
    PLUS_AS         reduce using rule 104 (lval-or-paren-lval -> LPAREN lval-list RPAREN .)


state 167

    (109) switch-stmt -> S_SWITCH LPAREN expr . RPAREN LBRACE case-star opt-default RBRACE

    RPAREN          shift and go to state 243


state 168

    (116) wait-stmt -> E_WAIT opt-deep LPAREN . expr-list RPAREN block
    (213) expr-list -> . expr
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr-list                      shift and go to state 244
    expr                           shift and go to state 185
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 169

    (119) foreach-loop -> S_FOREACH var-name opt-comma-var-name . S_IN expr block

    S_IN            shift and go to state 245


state 170

    (120) opt-comma-var-name -> COMMA . var-name
    (227) var-name -> . ID

    ID              shift and go to state 82

    var-name                       shift and go to state 246

state 171

    (121) opt-comma-var-name -> empty .

    S_IN            reduce using rule 121 (opt-comma-var-name -> empty .)


state 172

    (122) for-loop -> S_FOR LPAREN for-init-list . SEMICOLON expr SEMICOLON for-update-list RPAREN block

    SEMICOLON       shift and go to state 247


state 173

    (124) for-init-list -> for-init . for-init-star
    (125) for-init-star -> . COMMA for-init for-init-star
    (126) for-init-star -> .

    COMMA           shift and go to state 249
    SEMICOLON       reduce using rule 126 (for-init-star -> .)

    for-init-star                  shift and go to state 248

state 174

    (127) for-init -> for-assignment .

    COMMA           reduce using rule 127 (for-init -> for-assignment .)
    SEMICOLON       reduce using rule 127 (for-init -> for-assignment .)


state 175

    (128) for-init -> type-prefix . var-name type-suffix ASSIGN expr
    (227) var-name -> . ID

    ID              shift and go to state 82

    var-name                       shift and go to state 250

state 176

    (132) for-assignment -> var-name . ASSIGN expr

    ASSIGN          shift and go to state 251


state 177

    (227) var-name -> ID .
    (225) type-name -> ID .

    ASSIGN          reduce using rule 227 (var-name -> ID .)
    LESS            reduce using rule 225 (type-name -> ID .)
    ID              reduce using rule 225 (type-name -> ID .)


state 178

    (75) var-decl-rest -> var-name type-suffix . empty-or-var-mapping empty-or-assign-expr
    (77) empty-or-var-mapping -> . var-mapping
    (78) empty-or-var-mapping -> . empty
    (89) var-mapping -> . LESS expr GREATER
    (76) empty -> .

  ! shift/reduce conflict for LESS resolved as shift
    LESS            shift and go to state 255
    ASSIGN          reduce using rule 76 (empty -> .)
    SEMICOLON       reduce using rule 76 (empty -> .)
    C_GLOBAL        reduce using rule 76 (empty -> .)
    D_IMPORT        reduce using rule 76 (empty -> .)
    C_PRAGMA        reduce using rule 76 (empty -> .)
    LBRACE          reduce using rule 76 (empty -> .)
    S_IF            reduce using rule 76 (empty -> .)
    S_SWITCH        reduce using rule 76 (empty -> .)
    E_WAIT          reduce using rule 76 (empty -> .)
    S_FOREACH       reduce using rule 76 (empty -> .)
    S_FOR           reduce using rule 76 (empty -> .)
    S_WHILE         reduce using rule 76 (empty -> .)
    S_ITERATE       reduce using rule 76 (empty -> .)
    S_ELSE          reduce using rule 76 (empty -> .)
    ID              reduce using rule 76 (empty -> .)
    C_APP           reduce using rule 76 (empty -> .)
    LPAREN          reduce using rule 76 (empty -> .)
    class_INT       reduce using rule 76 (empty -> .)
    class_DOUBLE    reduce using rule 76 (empty -> .)
    class_FLOAT     reduce using rule 76 (empty -> .)
    class_VOID      reduce using rule 76 (empty -> .)
    class_UINT      reduce using rule 76 (empty -> .)
    class_BOOL      reduce using rule 76 (empty -> .)
    class_CHARACTER reduce using rule 76 (empty -> .)
    class_String    reduce using rule 76 (empty -> .)
    collection_SET  reduce using rule 76 (empty -> .)
    collection_ARRAY reduce using rule 76 (empty -> .)
    collection_DICT reduce using rule 76 (empty -> .)
    $end            reduce using rule 76 (empty -> .)
    ARROW           reduce using rule 76 (empty -> .)
    RBRACE          reduce using rule 76 (empty -> .)
    S_CASE          reduce using rule 76 (empty -> .)
    S_DEFAULT       reduce using rule 76 (empty -> .)

  ! LESS            [ reduce using rule 76 (empty -> .) ]

    empty-or-var-mapping           shift and go to state 252
    var-mapping                    shift and go to state 253
    empty                          shift and go to state 254

state 179

    (84) type-suffix -> LBRACKET . empty-or-standalone-type RBRACKET type-suffix
    (86) empty-or-standalone-type -> . standalone-type
    (87) empty-or-standalone-type -> .
    (88) standalone-type -> . type-prefix type-suffix
    (81) type-prefix -> . type-name
    (82) type-prefix -> . param-type
    (214) type-name -> . class_INT
    (215) type-name -> . class_DOUBLE
    (216) type-name -> . class_FLOAT
    (217) type-name -> . class_VOID
    (218) type-name -> . class_UINT
    (219) type-name -> . class_BOOL
    (220) type-name -> . class_CHARACTER
    (221) type-name -> . class_String
    (222) type-name -> . collection_SET
    (223) type-name -> . collection_ARRAY
    (224) type-name -> . collection_DICT
    (225) type-name -> . ID
    (83) param-type -> . type-name LESS standalone-type GREATER

    RBRACKET        reduce using rule 87 (empty-or-standalone-type -> .)
    class_INT       shift and go to state 52
    class_DOUBLE    shift and go to state 53
    class_FLOAT     shift and go to state 54
    class_VOID      shift and go to state 55
    class_UINT      shift and go to state 56
    class_BOOL      shift and go to state 57
    class_CHARACTER shift and go to state 58
    class_String    shift and go to state 59
    collection_SET  shift and go to state 60
    collection_ARRAY shift and go to state 61
    collection_DICT shift and go to state 62
    ID              shift and go to state 152

    empty-or-standalone-type       shift and go to state 256
    standalone-type                shift and go to state 257
    type-prefix                    shift and go to state 192
    type-name                      shift and go to state 48
    param-type                     shift and go to state 49

state 180

    (123) while-loop -> S_WHILE LPAREN expr . RPAREN block

    RPAREN          shift and go to state 258


state 181

    (133) iterate-loop -> S_ITERATE var-name block . S_UNTIL LPAREN expr RPAREN

    S_UNTIL         shift and go to state 259


state 182

    (91) stmt-chain -> chainable-stmt semicolon-or-arrow statement .

    SEMICOLON       reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    C_GLOBAL        reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    D_IMPORT        reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    C_PRAGMA        reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    LBRACE          reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_IF            reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_SWITCH        reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    E_WAIT          reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_FOREACH       reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_FOR           reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_WHILE         reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_ITERATE       reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_ELSE          reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    ID              reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    C_APP           reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    LPAREN          reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_INT       reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_DOUBLE    reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_FLOAT     reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_VOID      reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_UINT      reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_BOOL      reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_CHARACTER reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_String    reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    collection_SET  reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    collection_ARRAY reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    collection_DICT reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    LESS            reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    $end            reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    RBRACE          reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_CASE          reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_DEFAULT       reduce using rule 91 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)


state 183

    (108) opt-else-block -> empty .
    (38) type-params -> empty .

  ! reduce/reduce conflict for LPAREN resolved using rule 38 (type-params -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 38 (type-params -> empty .)
    SEMICOLON       reduce using rule 108 (opt-else-block -> empty .)
    C_GLOBAL        reduce using rule 108 (opt-else-block -> empty .)
    D_IMPORT        reduce using rule 108 (opt-else-block -> empty .)
    C_PRAGMA        reduce using rule 108 (opt-else-block -> empty .)
    LBRACE          reduce using rule 108 (opt-else-block -> empty .)
    S_IF            reduce using rule 108 (opt-else-block -> empty .)
    S_SWITCH        reduce using rule 108 (opt-else-block -> empty .)
    E_WAIT          reduce using rule 108 (opt-else-block -> empty .)
    S_FOREACH       reduce using rule 108 (opt-else-block -> empty .)
    S_FOR           reduce using rule 108 (opt-else-block -> empty .)
    S_WHILE         reduce using rule 108 (opt-else-block -> empty .)
    S_ITERATE       reduce using rule 108 (opt-else-block -> empty .)
    S_ELSE          reduce using rule 108 (opt-else-block -> empty .)
    C_APP           reduce using rule 108 (opt-else-block -> empty .)
    class_INT       reduce using rule 108 (opt-else-block -> empty .)
    class_DOUBLE    reduce using rule 108 (opt-else-block -> empty .)
    class_FLOAT     reduce using rule 108 (opt-else-block -> empty .)
    class_VOID      reduce using rule 108 (opt-else-block -> empty .)
    class_UINT      reduce using rule 108 (opt-else-block -> empty .)
    class_BOOL      reduce using rule 108 (opt-else-block -> empty .)
    class_CHARACTER reduce using rule 108 (opt-else-block -> empty .)
    class_String    reduce using rule 108 (opt-else-block -> empty .)
    collection_SET  reduce using rule 108 (opt-else-block -> empty .)
    collection_ARRAY reduce using rule 108 (opt-else-block -> empty .)
    collection_DICT reduce using rule 108 (opt-else-block -> empty .)
    LESS            reduce using rule 108 (opt-else-block -> empty .)
    $end            reduce using rule 108 (opt-else-block -> empty .)
    RBRACE          reduce using rule 108 (opt-else-block -> empty .)
    S_CASE          reduce using rule 108 (opt-else-block -> empty .)
    S_DEFAULT       reduce using rule 108 (opt-else-block -> empty .)
    LPAREN          reduce using rule 38 (type-params -> empty .)
    ID              reduce using rule 38 (type-params -> empty .)

  ! ID              [ reduce using rule 108 (opt-else-block -> empty .) ]
  ! LPAREN          [ reduce using rule 108 (opt-else-block -> empty .) ]


state 184

    (98) assignment -> lval-or-paren-lval assign-or-plusas expr-list .

    SEMICOLON       reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    C_GLOBAL        reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    D_IMPORT        reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    C_PRAGMA        reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    LBRACE          reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    S_IF            reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    S_SWITCH        reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    E_WAIT          reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    S_FOREACH       reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    S_FOR           reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    S_WHILE         reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    S_ITERATE       reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    S_ELSE          reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    ID              reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    C_APP           reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    LPAREN          reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    class_INT       reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    class_DOUBLE    reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    class_FLOAT     reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    class_VOID      reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    class_UINT      reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    class_BOOL      reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    class_CHARACTER reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    class_String    reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    collection_SET  reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    collection_ARRAY reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    collection_DICT reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    LESS            reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    $end            reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    ARROW           reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    RBRACE          reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    S_CASE          reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    S_DEFAULT       reduce using rule 98 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)


state 185

    (213) expr-list -> expr .

    SEMICOLON       reduce using rule 213 (expr-list -> expr .)
    C_GLOBAL        reduce using rule 213 (expr-list -> expr .)
    D_IMPORT        reduce using rule 213 (expr-list -> expr .)
    C_PRAGMA        reduce using rule 213 (expr-list -> expr .)
    LBRACE          reduce using rule 213 (expr-list -> expr .)
    S_IF            reduce using rule 213 (expr-list -> expr .)
    S_SWITCH        reduce using rule 213 (expr-list -> expr .)
    E_WAIT          reduce using rule 213 (expr-list -> expr .)
    S_FOREACH       reduce using rule 213 (expr-list -> expr .)
    S_FOR           reduce using rule 213 (expr-list -> expr .)
    S_WHILE         reduce using rule 213 (expr-list -> expr .)
    S_ITERATE       reduce using rule 213 (expr-list -> expr .)
    S_ELSE          reduce using rule 213 (expr-list -> expr .)
    ID              reduce using rule 213 (expr-list -> expr .)
    C_APP           reduce using rule 213 (expr-list -> expr .)
    LPAREN          reduce using rule 213 (expr-list -> expr .)
    class_INT       reduce using rule 213 (expr-list -> expr .)
    class_DOUBLE    reduce using rule 213 (expr-list -> expr .)
    class_FLOAT     reduce using rule 213 (expr-list -> expr .)
    class_VOID      reduce using rule 213 (expr-list -> expr .)
    class_UINT      reduce using rule 213 (expr-list -> expr .)
    class_BOOL      reduce using rule 213 (expr-list -> expr .)
    class_CHARACTER reduce using rule 213 (expr-list -> expr .)
    class_String    reduce using rule 213 (expr-list -> expr .)
    collection_SET  reduce using rule 213 (expr-list -> expr .)
    collection_ARRAY reduce using rule 213 (expr-list -> expr .)
    collection_DICT reduce using rule 213 (expr-list -> expr .)
    LESS            reduce using rule 213 (expr-list -> expr .)
    $end            reduce using rule 213 (expr-list -> expr .)
    ARROW           reduce using rule 213 (expr-list -> expr .)
    RBRACE          reduce using rule 213 (expr-list -> expr .)
    S_CASE          reduce using rule 213 (expr-list -> expr .)
    S_DEFAULT       reduce using rule 213 (expr-list -> expr .)
    RPAREN          reduce using rule 213 (expr-list -> expr .)


state 186

    (37) type-params -> LESS var-name comma-name-star . GREATER

    GREATER         shift and go to state 260


state 187

    (39) comma-name-star -> COMMA . var-name comma-name-star
    (227) var-name -> . ID

    ID              shift and go to state 82

    var-name                       shift and go to state 261

state 188

    (52) swift-func-defn -> func-hdr ARROW block .

    SEMICOLON       reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    C_GLOBAL        reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    D_IMPORT        reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    C_PRAGMA        reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    LBRACE          reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    S_IF            reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    S_SWITCH        reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    E_WAIT          reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    S_FOREACH       reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    S_FOR           reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    S_WHILE         reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    S_ITERATE       reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    S_ELSE          reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    ID              reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    C_APP           reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    LPAREN          reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    class_INT       reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    class_DOUBLE    reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    class_FLOAT     reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    class_VOID      reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    class_UINT      reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    class_BOOL      reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    class_CHARACTER reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    class_String    reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    collection_SET  reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    collection_ARRAY reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    collection_DICT reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    LESS            reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    $end            reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    RBRACE          reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    S_CASE          reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)
    S_DEFAULT       reduce using rule 52 (swift-func-defn -> func-hdr ARROW block .)


state 189

    (65) foreign-func-body -> STR_LITERAL STR_LITERAL . empty-or-literal empty-or-more-literals
    (66) empty-or-literal -> . STR_LITERAL
    (67) empty-or-literal -> . empty
    (76) empty -> .

    STR_LITERAL     shift and go to state 262
    LBRACKET        reduce using rule 76 (empty -> .)
    SEMICOLON       reduce using rule 76 (empty -> .)
    C_GLOBAL        reduce using rule 76 (empty -> .)
    D_IMPORT        reduce using rule 76 (empty -> .)
    C_PRAGMA        reduce using rule 76 (empty -> .)
    LBRACE          reduce using rule 76 (empty -> .)
    S_IF            reduce using rule 76 (empty -> .)
    S_SWITCH        reduce using rule 76 (empty -> .)
    E_WAIT          reduce using rule 76 (empty -> .)
    S_FOREACH       reduce using rule 76 (empty -> .)
    S_FOR           reduce using rule 76 (empty -> .)
    S_WHILE         reduce using rule 76 (empty -> .)
    S_ITERATE       reduce using rule 76 (empty -> .)
    S_ELSE          reduce using rule 76 (empty -> .)
    ID              reduce using rule 76 (empty -> .)
    C_APP           reduce using rule 76 (empty -> .)
    LPAREN          reduce using rule 76 (empty -> .)
    class_INT       reduce using rule 76 (empty -> .)
    class_DOUBLE    reduce using rule 76 (empty -> .)
    class_FLOAT     reduce using rule 76 (empty -> .)
    class_VOID      reduce using rule 76 (empty -> .)
    class_UINT      reduce using rule 76 (empty -> .)
    class_BOOL      reduce using rule 76 (empty -> .)
    class_CHARACTER reduce using rule 76 (empty -> .)
    class_String    reduce using rule 76 (empty -> .)
    collection_SET  reduce using rule 76 (empty -> .)
    collection_ARRAY reduce using rule 76 (empty -> .)
    collection_DICT reduce using rule 76 (empty -> .)
    LESS            reduce using rule 76 (empty -> .)
    $end            reduce using rule 76 (empty -> .)
    RBRACE          reduce using rule 76 (empty -> .)
    S_CASE          reduce using rule 76 (empty -> .)
    S_DEFAULT       reduce using rule 76 (empty -> .)

    empty-or-literal               shift and go to state 263
    empty                          shift and go to state 264

state 190

    (53) app-func-defn -> C_APP func-hdr LBRACE . app-body RBRACE
    (54) app-body -> . app-arg-expr app-arg-expr-star app-out-star empty-or-semicolon
    (235) app-arg-expr -> . opt-at var-name
    (236) app-arg-expr -> . literal
    (237) app-arg-expr -> . array-constructor
    (238) app-arg-expr -> . LPAREN expr RPAREN
    (239) opt-at -> . AT
    (240) opt-at -> . empty
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (76) empty -> .
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    LPAREN          shift and go to state 270
    AT              shift and go to state 271
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              reduce using rule 76 (empty -> .)
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    app-body                       shift and go to state 265
    app-arg-expr                   shift and go to state 266
    opt-at                         shift and go to state 267
    literal                        shift and go to state 268
    array-constructor              shift and go to state 269
    empty                          shift and go to state 272
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 191

    (83) param-type -> type-name LESS standalone-type . GREATER

    GREATER         shift and go to state 273


state 192

    (88) standalone-type -> type-prefix . type-suffix
    (84) type-suffix -> . LBRACKET empty-or-standalone-type RBRACKET type-suffix
    (85) type-suffix -> .

    LBRACKET        shift and go to state 179
    GREATER         reduce using rule 85 (type-suffix -> .)
    RBRACKET        reduce using rule 85 (type-suffix -> .)

    type-suffix                    shift and go to state 274

state 193

    (34) func-hdr -> type-params formal-arg-list ID . empty-or-arg-list
    (35) empty-or-arg-list -> . formal-arg-list
    (36) empty-or-arg-list -> . empty
    (41) formal-arg-list -> . LPAREN opt-formal-args RPAREN
    (42) formal-arg-list -> . empty
    (76) empty -> .

    LPAREN          shift and go to state 108
    ARROW           reduce using rule 76 (empty -> .)
    STR_LITERAL     reduce using rule 76 (empty -> .)
    LBRACE          reduce using rule 76 (empty -> .)

    formal-arg-list                shift and go to state 275
    empty-or-arg-list              shift and go to state 276
    empty                          shift and go to state 277

state 194

    (41) formal-arg-list -> LPAREN opt-formal-args . RPAREN

    RPAREN          shift and go to state 278


state 195

    (43) opt-formal-args -> formal-arg . comma-args-star
    (45) comma-args-star -> . COMMA formal-arg comma-args-star
    (46) comma-args-star -> . empty
    (76) empty -> .

    COMMA           shift and go to state 280
    RPAREN          reduce using rule 76 (empty -> .)

    comma-args-star                shift and go to state 279
    empty                          shift and go to state 281

state 196

    (44) opt-formal-args -> empty .

    RPAREN          reduce using rule 44 (opt-formal-args -> empty .)


state 197

    (47) formal-arg -> type-prefix . empty-or-range var-name type-suffix empty-or-ass-expr
    (48) empty-or-range -> . RANGE
    (49) empty-or-range -> . empty
    (76) empty -> .

    RANGE           shift and go to state 283
    ID              reduce using rule 76 (empty -> .)

    empty-or-range                 shift and go to state 282
    empty                          shift and go to state 284

state 198

    (229) lval-expr-star -> COMMA lval-expr . lval-expr-star
    (229) lval-expr-star -> . COMMA lval-expr lval-expr-star
    (230) lval-expr-star -> .

    COMMA           shift and go to state 111
    ASSIGN          reduce using rule 230 (lval-expr-star -> .)
    PLUS_AS         reduce using rule 230 (lval-expr-star -> .)
    RPAREN          reduce using rule 230 (lval-expr-star -> .)

    lval-expr-star                 shift and go to state 285

state 199

    (105) update-stmt -> var-name LESS ID GREATER . UPD expr SEMICOLON

    UPD             shift and go to state 286


state 200

    (190) array-list-constructor -> LBRACKET opt-expr-list . RBRACKET

    RBRACKET        shift and go to state 287


state 201

    (193) array-range-constructor -> LBRACKET expr . COLON expr opt-coloned-expr RBRACKET
    (213) expr-list -> expr .

    COLON           shift and go to state 288
    RBRACKET        reduce using rule 213 (expr-list -> expr .)


state 202

    (191) opt-expr-list -> expr-list .

    RBRACKET        reduce using rule 191 (opt-expr-list -> expr-list .)


state 203

    (192) opt-expr-list -> empty .

    RBRACKET        reduce using rule 192 (opt-expr-list -> empty .)


state 204

    (169) array-subscript -> LBRACKET expr RBRACKET .

    LBRACKET        reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    DOT             reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    ASSIGN          reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    PLUS_AS         reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    MULT            reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    DIV             reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    MULTPER         reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    DOUBLEPER       reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    MOD             reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    LESS            reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    LESS_EQ         reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    EQUAL           reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    GREATER         reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    GREATER_EQ      reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    NOT_EQUAL       reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    LOG_AND         reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    LOG_OR          reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    SEMICOLON       reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    C_GLOBAL        reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    D_IMPORT        reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    C_PRAGMA        reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    LBRACE          reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    S_IF            reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    S_SWITCH        reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    E_WAIT          reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    S_FOREACH       reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    S_FOR           reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    S_WHILE         reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    S_ITERATE       reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    S_ELSE          reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    ID              reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    C_APP           reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    LPAREN          reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    class_INT       reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    class_DOUBLE    reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    class_FLOAT     reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    class_VOID      reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    class_UINT      reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    class_BOOL      reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    class_CHARACTER reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    class_String    reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    collection_SET  reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    collection_ARRAY reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    collection_DICT reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    $end            reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    ARROW           reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    RBRACE          reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    S_CASE          reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    S_DEFAULT       reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    COLON           reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    E_STDIN         reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    E_STDOUT        reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)
    E_STDERR        reduce using rule 169 (array-subscript -> LBRACKET expr RBRACKET .)


state 205

    (136) or-expr -> or-expr LOG_OR . and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    and-expr                       shift and go to state 289
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 206

    (138) and-expr -> and-expr LOG_AND . eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    eq-expr                        shift and go to state 290
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 207

    (140) eq-expr -> eq-expr eq-or-not-eq . eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    eq-expr                        shift and go to state 291
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 208

    (141) eq-or-not-eq -> EQUAL .

    MINUS           reduce using rule 141 (eq-or-not-eq -> EQUAL .)
    EXCLAMATION     reduce using rule 141 (eq-or-not-eq -> EQUAL .)
    LPAREN          reduce using rule 141 (eq-or-not-eq -> EQUAL .)
    STR_LITERAL     reduce using rule 141 (eq-or-not-eq -> EQUAL .)
    MUL_STR_LITERAL reduce using rule 141 (eq-or-not-eq -> EQUAL .)
    INT             reduce using rule 141 (eq-or-not-eq -> EQUAL .)
    ID              reduce using rule 141 (eq-or-not-eq -> EQUAL .)
    DOUBLE          reduce using rule 141 (eq-or-not-eq -> EQUAL .)
    INF             reduce using rule 141 (eq-or-not-eq -> EQUAL .)
    NAN             reduce using rule 141 (eq-or-not-eq -> EQUAL .)
    E_TRUE          reduce using rule 141 (eq-or-not-eq -> EQUAL .)
    E_FALSE         reduce using rule 141 (eq-or-not-eq -> EQUAL .)
    LBRACKET        reduce using rule 141 (eq-or-not-eq -> EQUAL .)
    LBRACE          reduce using rule 141 (eq-or-not-eq -> EQUAL .)


state 209

    (142) eq-or-not-eq -> NOT_EQUAL .

    MINUS           reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)
    EXCLAMATION     reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)
    LPAREN          reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)
    STR_LITERAL     reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)
    MUL_STR_LITERAL reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)
    INT             reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)
    ID              reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)
    DOUBLE          reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)
    INF             reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)
    NAN             reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)
    E_TRUE          reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)
    E_FALSE         reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)
    LBRACKET        reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)
    LBRACE          reduce using rule 142 (eq-or-not-eq -> NOT_EQUAL .)


state 210

    (144) cmp-expr -> cmp-expr cmp-sign . add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    add-expr                       shift and go to state 292
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 211

    (145) cmp-sign -> LESS .

    MINUS           reduce using rule 145 (cmp-sign -> LESS .)
    EXCLAMATION     reduce using rule 145 (cmp-sign -> LESS .)
    LPAREN          reduce using rule 145 (cmp-sign -> LESS .)
    STR_LITERAL     reduce using rule 145 (cmp-sign -> LESS .)
    MUL_STR_LITERAL reduce using rule 145 (cmp-sign -> LESS .)
    INT             reduce using rule 145 (cmp-sign -> LESS .)
    ID              reduce using rule 145 (cmp-sign -> LESS .)
    DOUBLE          reduce using rule 145 (cmp-sign -> LESS .)
    INF             reduce using rule 145 (cmp-sign -> LESS .)
    NAN             reduce using rule 145 (cmp-sign -> LESS .)
    E_TRUE          reduce using rule 145 (cmp-sign -> LESS .)
    E_FALSE         reduce using rule 145 (cmp-sign -> LESS .)
    LBRACKET        reduce using rule 145 (cmp-sign -> LESS .)
    LBRACE          reduce using rule 145 (cmp-sign -> LESS .)


state 212

    (146) cmp-sign -> LESS_EQ .

    MINUS           reduce using rule 146 (cmp-sign -> LESS_EQ .)
    EXCLAMATION     reduce using rule 146 (cmp-sign -> LESS_EQ .)
    LPAREN          reduce using rule 146 (cmp-sign -> LESS_EQ .)
    STR_LITERAL     reduce using rule 146 (cmp-sign -> LESS_EQ .)
    MUL_STR_LITERAL reduce using rule 146 (cmp-sign -> LESS_EQ .)
    INT             reduce using rule 146 (cmp-sign -> LESS_EQ .)
    ID              reduce using rule 146 (cmp-sign -> LESS_EQ .)
    DOUBLE          reduce using rule 146 (cmp-sign -> LESS_EQ .)
    INF             reduce using rule 146 (cmp-sign -> LESS_EQ .)
    NAN             reduce using rule 146 (cmp-sign -> LESS_EQ .)
    E_TRUE          reduce using rule 146 (cmp-sign -> LESS_EQ .)
    E_FALSE         reduce using rule 146 (cmp-sign -> LESS_EQ .)
    LBRACKET        reduce using rule 146 (cmp-sign -> LESS_EQ .)
    LBRACE          reduce using rule 146 (cmp-sign -> LESS_EQ .)


state 213

    (147) cmp-sign -> EQUAL .

    MINUS           reduce using rule 147 (cmp-sign -> EQUAL .)
    EXCLAMATION     reduce using rule 147 (cmp-sign -> EQUAL .)
    LPAREN          reduce using rule 147 (cmp-sign -> EQUAL .)
    STR_LITERAL     reduce using rule 147 (cmp-sign -> EQUAL .)
    MUL_STR_LITERAL reduce using rule 147 (cmp-sign -> EQUAL .)
    INT             reduce using rule 147 (cmp-sign -> EQUAL .)
    ID              reduce using rule 147 (cmp-sign -> EQUAL .)
    DOUBLE          reduce using rule 147 (cmp-sign -> EQUAL .)
    INF             reduce using rule 147 (cmp-sign -> EQUAL .)
    NAN             reduce using rule 147 (cmp-sign -> EQUAL .)
    E_TRUE          reduce using rule 147 (cmp-sign -> EQUAL .)
    E_FALSE         reduce using rule 147 (cmp-sign -> EQUAL .)
    LBRACKET        reduce using rule 147 (cmp-sign -> EQUAL .)
    LBRACE          reduce using rule 147 (cmp-sign -> EQUAL .)


state 214

    (148) cmp-sign -> GREATER .

    MINUS           reduce using rule 148 (cmp-sign -> GREATER .)
    EXCLAMATION     reduce using rule 148 (cmp-sign -> GREATER .)
    LPAREN          reduce using rule 148 (cmp-sign -> GREATER .)
    STR_LITERAL     reduce using rule 148 (cmp-sign -> GREATER .)
    MUL_STR_LITERAL reduce using rule 148 (cmp-sign -> GREATER .)
    INT             reduce using rule 148 (cmp-sign -> GREATER .)
    ID              reduce using rule 148 (cmp-sign -> GREATER .)
    DOUBLE          reduce using rule 148 (cmp-sign -> GREATER .)
    INF             reduce using rule 148 (cmp-sign -> GREATER .)
    NAN             reduce using rule 148 (cmp-sign -> GREATER .)
    E_TRUE          reduce using rule 148 (cmp-sign -> GREATER .)
    E_FALSE         reduce using rule 148 (cmp-sign -> GREATER .)
    LBRACKET        reduce using rule 148 (cmp-sign -> GREATER .)
    LBRACE          reduce using rule 148 (cmp-sign -> GREATER .)


state 215

    (149) cmp-sign -> GREATER_EQ .

    MINUS           reduce using rule 149 (cmp-sign -> GREATER_EQ .)
    EXCLAMATION     reduce using rule 149 (cmp-sign -> GREATER_EQ .)
    LPAREN          reduce using rule 149 (cmp-sign -> GREATER_EQ .)
    STR_LITERAL     reduce using rule 149 (cmp-sign -> GREATER_EQ .)
    MUL_STR_LITERAL reduce using rule 149 (cmp-sign -> GREATER_EQ .)
    INT             reduce using rule 149 (cmp-sign -> GREATER_EQ .)
    ID              reduce using rule 149 (cmp-sign -> GREATER_EQ .)
    DOUBLE          reduce using rule 149 (cmp-sign -> GREATER_EQ .)
    INF             reduce using rule 149 (cmp-sign -> GREATER_EQ .)
    NAN             reduce using rule 149 (cmp-sign -> GREATER_EQ .)
    E_TRUE          reduce using rule 149 (cmp-sign -> GREATER_EQ .)
    E_FALSE         reduce using rule 149 (cmp-sign -> GREATER_EQ .)
    LBRACKET        reduce using rule 149 (cmp-sign -> GREATER_EQ .)
    LBRACE          reduce using rule 149 (cmp-sign -> GREATER_EQ .)


state 216

    (151) add-expr -> add-expr add-sign . mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    mult-expr                      shift and go to state 293
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 217

    (152) add-sign -> PLUS .

    MINUS           reduce using rule 152 (add-sign -> PLUS .)
    EXCLAMATION     reduce using rule 152 (add-sign -> PLUS .)
    LPAREN          reduce using rule 152 (add-sign -> PLUS .)
    STR_LITERAL     reduce using rule 152 (add-sign -> PLUS .)
    MUL_STR_LITERAL reduce using rule 152 (add-sign -> PLUS .)
    INT             reduce using rule 152 (add-sign -> PLUS .)
    ID              reduce using rule 152 (add-sign -> PLUS .)
    DOUBLE          reduce using rule 152 (add-sign -> PLUS .)
    INF             reduce using rule 152 (add-sign -> PLUS .)
    NAN             reduce using rule 152 (add-sign -> PLUS .)
    E_TRUE          reduce using rule 152 (add-sign -> PLUS .)
    E_FALSE         reduce using rule 152 (add-sign -> PLUS .)
    LBRACKET        reduce using rule 152 (add-sign -> PLUS .)
    LBRACE          reduce using rule 152 (add-sign -> PLUS .)


state 218

    (153) add-sign -> MINUS .

    MINUS           reduce using rule 153 (add-sign -> MINUS .)
    EXCLAMATION     reduce using rule 153 (add-sign -> MINUS .)
    LPAREN          reduce using rule 153 (add-sign -> MINUS .)
    STR_LITERAL     reduce using rule 153 (add-sign -> MINUS .)
    MUL_STR_LITERAL reduce using rule 153 (add-sign -> MINUS .)
    INT             reduce using rule 153 (add-sign -> MINUS .)
    ID              reduce using rule 153 (add-sign -> MINUS .)
    DOUBLE          reduce using rule 153 (add-sign -> MINUS .)
    INF             reduce using rule 153 (add-sign -> MINUS .)
    NAN             reduce using rule 153 (add-sign -> MINUS .)
    E_TRUE          reduce using rule 153 (add-sign -> MINUS .)
    E_FALSE         reduce using rule 153 (add-sign -> MINUS .)
    LBRACKET        reduce using rule 153 (add-sign -> MINUS .)
    LBRACE          reduce using rule 153 (add-sign -> MINUS .)


state 219

    (155) mult-expr -> mult-expr mult-sign . unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    unary-expr                     shift and go to state 294
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 220

    (156) mult-sign -> MULT .

    MINUS           reduce using rule 156 (mult-sign -> MULT .)
    EXCLAMATION     reduce using rule 156 (mult-sign -> MULT .)
    LPAREN          reduce using rule 156 (mult-sign -> MULT .)
    STR_LITERAL     reduce using rule 156 (mult-sign -> MULT .)
    MUL_STR_LITERAL reduce using rule 156 (mult-sign -> MULT .)
    INT             reduce using rule 156 (mult-sign -> MULT .)
    ID              reduce using rule 156 (mult-sign -> MULT .)
    DOUBLE          reduce using rule 156 (mult-sign -> MULT .)
    INF             reduce using rule 156 (mult-sign -> MULT .)
    NAN             reduce using rule 156 (mult-sign -> MULT .)
    E_TRUE          reduce using rule 156 (mult-sign -> MULT .)
    E_FALSE         reduce using rule 156 (mult-sign -> MULT .)
    LBRACKET        reduce using rule 156 (mult-sign -> MULT .)
    LBRACE          reduce using rule 156 (mult-sign -> MULT .)


state 221

    (157) mult-sign -> DIV .

    MINUS           reduce using rule 157 (mult-sign -> DIV .)
    EXCLAMATION     reduce using rule 157 (mult-sign -> DIV .)
    LPAREN          reduce using rule 157 (mult-sign -> DIV .)
    STR_LITERAL     reduce using rule 157 (mult-sign -> DIV .)
    MUL_STR_LITERAL reduce using rule 157 (mult-sign -> DIV .)
    INT             reduce using rule 157 (mult-sign -> DIV .)
    ID              reduce using rule 157 (mult-sign -> DIV .)
    DOUBLE          reduce using rule 157 (mult-sign -> DIV .)
    INF             reduce using rule 157 (mult-sign -> DIV .)
    NAN             reduce using rule 157 (mult-sign -> DIV .)
    E_TRUE          reduce using rule 157 (mult-sign -> DIV .)
    E_FALSE         reduce using rule 157 (mult-sign -> DIV .)
    LBRACKET        reduce using rule 157 (mult-sign -> DIV .)
    LBRACE          reduce using rule 157 (mult-sign -> DIV .)


state 222

    (158) mult-sign -> MULTPER .

    MINUS           reduce using rule 158 (mult-sign -> MULTPER .)
    EXCLAMATION     reduce using rule 158 (mult-sign -> MULTPER .)
    LPAREN          reduce using rule 158 (mult-sign -> MULTPER .)
    STR_LITERAL     reduce using rule 158 (mult-sign -> MULTPER .)
    MUL_STR_LITERAL reduce using rule 158 (mult-sign -> MULTPER .)
    INT             reduce using rule 158 (mult-sign -> MULTPER .)
    ID              reduce using rule 158 (mult-sign -> MULTPER .)
    DOUBLE          reduce using rule 158 (mult-sign -> MULTPER .)
    INF             reduce using rule 158 (mult-sign -> MULTPER .)
    NAN             reduce using rule 158 (mult-sign -> MULTPER .)
    E_TRUE          reduce using rule 158 (mult-sign -> MULTPER .)
    E_FALSE         reduce using rule 158 (mult-sign -> MULTPER .)
    LBRACKET        reduce using rule 158 (mult-sign -> MULTPER .)
    LBRACE          reduce using rule 158 (mult-sign -> MULTPER .)


state 223

    (159) mult-sign -> DOUBLEPER .

    MINUS           reduce using rule 159 (mult-sign -> DOUBLEPER .)
    EXCLAMATION     reduce using rule 159 (mult-sign -> DOUBLEPER .)
    LPAREN          reduce using rule 159 (mult-sign -> DOUBLEPER .)
    STR_LITERAL     reduce using rule 159 (mult-sign -> DOUBLEPER .)
    MUL_STR_LITERAL reduce using rule 159 (mult-sign -> DOUBLEPER .)
    INT             reduce using rule 159 (mult-sign -> DOUBLEPER .)
    ID              reduce using rule 159 (mult-sign -> DOUBLEPER .)
    DOUBLE          reduce using rule 159 (mult-sign -> DOUBLEPER .)
    INF             reduce using rule 159 (mult-sign -> DOUBLEPER .)
    NAN             reduce using rule 159 (mult-sign -> DOUBLEPER .)
    E_TRUE          reduce using rule 159 (mult-sign -> DOUBLEPER .)
    E_FALSE         reduce using rule 159 (mult-sign -> DOUBLEPER .)
    LBRACKET        reduce using rule 159 (mult-sign -> DOUBLEPER .)
    LBRACE          reduce using rule 159 (mult-sign -> DOUBLEPER .)


state 224

    (160) mult-sign -> MOD .

    MINUS           reduce using rule 160 (mult-sign -> MOD .)
    EXCLAMATION     reduce using rule 160 (mult-sign -> MOD .)
    LPAREN          reduce using rule 160 (mult-sign -> MOD .)
    STR_LITERAL     reduce using rule 160 (mult-sign -> MOD .)
    MUL_STR_LITERAL reduce using rule 160 (mult-sign -> MOD .)
    INT             reduce using rule 160 (mult-sign -> MOD .)
    ID              reduce using rule 160 (mult-sign -> MOD .)
    DOUBLE          reduce using rule 160 (mult-sign -> MOD .)
    INF             reduce using rule 160 (mult-sign -> MOD .)
    NAN             reduce using rule 160 (mult-sign -> MOD .)
    E_TRUE          reduce using rule 160 (mult-sign -> MOD .)
    E_FALSE         reduce using rule 160 (mult-sign -> MOD .)
    LBRACKET        reduce using rule 160 (mult-sign -> MOD .)
    LBRACE          reduce using rule 160 (mult-sign -> MOD .)


state 225

    (166) postfix-expr -> postfix-expr array-or-struct .

    LBRACKET        reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    DOT             reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    MULT            reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    DIV             reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    MULTPER         reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    DOUBLEPER       reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    MOD             reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    PLUS            reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    MINUS           reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    LESS            reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    LESS_EQ         reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    EQUAL           reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    GREATER         reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    GREATER_EQ      reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    NOT_EQUAL       reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    LOG_AND         reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    LOG_OR          reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    RBRACKET        reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    SEMICOLON       reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    COMMA           reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    RPAREN          reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    C_GLOBAL        reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    D_IMPORT        reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    C_PRAGMA        reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    LBRACE          reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    S_IF            reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    S_SWITCH        reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    E_WAIT          reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    S_FOREACH       reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    S_FOR           reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    S_WHILE         reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    S_ITERATE       reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    S_ELSE          reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    ID              reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    C_APP           reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    LPAREN          reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    class_INT       reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    class_DOUBLE    reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    class_FLOAT     reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    class_VOID      reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    class_UINT      reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    class_BOOL      reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    class_CHARACTER reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    class_String    reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    collection_SET  reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    collection_ARRAY reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    collection_DICT reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    $end            reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    ARROW           reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    RBRACE          reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    S_CASE          reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    S_DEFAULT       reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    COLON           reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    E_STDIN         reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    E_STDOUT        reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)
    E_STDERR        reduce using rule 166 (postfix-expr -> postfix-expr array-or-struct .)


state 226

    (167) array-or-struct -> array-subscript .

    LBRACKET        reduce using rule 167 (array-or-struct -> array-subscript .)
    DOT             reduce using rule 167 (array-or-struct -> array-subscript .)
    MULT            reduce using rule 167 (array-or-struct -> array-subscript .)
    DIV             reduce using rule 167 (array-or-struct -> array-subscript .)
    MULTPER         reduce using rule 167 (array-or-struct -> array-subscript .)
    DOUBLEPER       reduce using rule 167 (array-or-struct -> array-subscript .)
    MOD             reduce using rule 167 (array-or-struct -> array-subscript .)
    PLUS            reduce using rule 167 (array-or-struct -> array-subscript .)
    MINUS           reduce using rule 167 (array-or-struct -> array-subscript .)
    LESS            reduce using rule 167 (array-or-struct -> array-subscript .)
    LESS_EQ         reduce using rule 167 (array-or-struct -> array-subscript .)
    EQUAL           reduce using rule 167 (array-or-struct -> array-subscript .)
    GREATER         reduce using rule 167 (array-or-struct -> array-subscript .)
    GREATER_EQ      reduce using rule 167 (array-or-struct -> array-subscript .)
    NOT_EQUAL       reduce using rule 167 (array-or-struct -> array-subscript .)
    LOG_AND         reduce using rule 167 (array-or-struct -> array-subscript .)
    LOG_OR          reduce using rule 167 (array-or-struct -> array-subscript .)
    RBRACKET        reduce using rule 167 (array-or-struct -> array-subscript .)
    SEMICOLON       reduce using rule 167 (array-or-struct -> array-subscript .)
    COMMA           reduce using rule 167 (array-or-struct -> array-subscript .)
    RPAREN          reduce using rule 167 (array-or-struct -> array-subscript .)
    C_GLOBAL        reduce using rule 167 (array-or-struct -> array-subscript .)
    D_IMPORT        reduce using rule 167 (array-or-struct -> array-subscript .)
    C_PRAGMA        reduce using rule 167 (array-or-struct -> array-subscript .)
    LBRACE          reduce using rule 167 (array-or-struct -> array-subscript .)
    S_IF            reduce using rule 167 (array-or-struct -> array-subscript .)
    S_SWITCH        reduce using rule 167 (array-or-struct -> array-subscript .)
    E_WAIT          reduce using rule 167 (array-or-struct -> array-subscript .)
    S_FOREACH       reduce using rule 167 (array-or-struct -> array-subscript .)
    S_FOR           reduce using rule 167 (array-or-struct -> array-subscript .)
    S_WHILE         reduce using rule 167 (array-or-struct -> array-subscript .)
    S_ITERATE       reduce using rule 167 (array-or-struct -> array-subscript .)
    S_ELSE          reduce using rule 167 (array-or-struct -> array-subscript .)
    ID              reduce using rule 167 (array-or-struct -> array-subscript .)
    C_APP           reduce using rule 167 (array-or-struct -> array-subscript .)
    LPAREN          reduce using rule 167 (array-or-struct -> array-subscript .)
    class_INT       reduce using rule 167 (array-or-struct -> array-subscript .)
    class_DOUBLE    reduce using rule 167 (array-or-struct -> array-subscript .)
    class_FLOAT     reduce using rule 167 (array-or-struct -> array-subscript .)
    class_VOID      reduce using rule 167 (array-or-struct -> array-subscript .)
    class_UINT      reduce using rule 167 (array-or-struct -> array-subscript .)
    class_BOOL      reduce using rule 167 (array-or-struct -> array-subscript .)
    class_CHARACTER reduce using rule 167 (array-or-struct -> array-subscript .)
    class_String    reduce using rule 167 (array-or-struct -> array-subscript .)
    collection_SET  reduce using rule 167 (array-or-struct -> array-subscript .)
    collection_ARRAY reduce using rule 167 (array-or-struct -> array-subscript .)
    collection_DICT reduce using rule 167 (array-or-struct -> array-subscript .)
    $end            reduce using rule 167 (array-or-struct -> array-subscript .)
    ARROW           reduce using rule 167 (array-or-struct -> array-subscript .)
    RBRACE          reduce using rule 167 (array-or-struct -> array-subscript .)
    S_CASE          reduce using rule 167 (array-or-struct -> array-subscript .)
    S_DEFAULT       reduce using rule 167 (array-or-struct -> array-subscript .)
    COLON           reduce using rule 167 (array-or-struct -> array-subscript .)
    E_STDIN         reduce using rule 167 (array-or-struct -> array-subscript .)
    E_STDOUT        reduce using rule 167 (array-or-struct -> array-subscript .)
    E_STDERR        reduce using rule 167 (array-or-struct -> array-subscript .)


state 227

    (168) array-or-struct -> struct-subscript .

    LBRACKET        reduce using rule 168 (array-or-struct -> struct-subscript .)
    DOT             reduce using rule 168 (array-or-struct -> struct-subscript .)
    MULT            reduce using rule 168 (array-or-struct -> struct-subscript .)
    DIV             reduce using rule 168 (array-or-struct -> struct-subscript .)
    MULTPER         reduce using rule 168 (array-or-struct -> struct-subscript .)
    DOUBLEPER       reduce using rule 168 (array-or-struct -> struct-subscript .)
    MOD             reduce using rule 168 (array-or-struct -> struct-subscript .)
    PLUS            reduce using rule 168 (array-or-struct -> struct-subscript .)
    MINUS           reduce using rule 168 (array-or-struct -> struct-subscript .)
    LESS            reduce using rule 168 (array-or-struct -> struct-subscript .)
    LESS_EQ         reduce using rule 168 (array-or-struct -> struct-subscript .)
    EQUAL           reduce using rule 168 (array-or-struct -> struct-subscript .)
    GREATER         reduce using rule 168 (array-or-struct -> struct-subscript .)
    GREATER_EQ      reduce using rule 168 (array-or-struct -> struct-subscript .)
    NOT_EQUAL       reduce using rule 168 (array-or-struct -> struct-subscript .)
    LOG_AND         reduce using rule 168 (array-or-struct -> struct-subscript .)
    LOG_OR          reduce using rule 168 (array-or-struct -> struct-subscript .)
    RBRACKET        reduce using rule 168 (array-or-struct -> struct-subscript .)
    SEMICOLON       reduce using rule 168 (array-or-struct -> struct-subscript .)
    COMMA           reduce using rule 168 (array-or-struct -> struct-subscript .)
    RPAREN          reduce using rule 168 (array-or-struct -> struct-subscript .)
    C_GLOBAL        reduce using rule 168 (array-or-struct -> struct-subscript .)
    D_IMPORT        reduce using rule 168 (array-or-struct -> struct-subscript .)
    C_PRAGMA        reduce using rule 168 (array-or-struct -> struct-subscript .)
    LBRACE          reduce using rule 168 (array-or-struct -> struct-subscript .)
    S_IF            reduce using rule 168 (array-or-struct -> struct-subscript .)
    S_SWITCH        reduce using rule 168 (array-or-struct -> struct-subscript .)
    E_WAIT          reduce using rule 168 (array-or-struct -> struct-subscript .)
    S_FOREACH       reduce using rule 168 (array-or-struct -> struct-subscript .)
    S_FOR           reduce using rule 168 (array-or-struct -> struct-subscript .)
    S_WHILE         reduce using rule 168 (array-or-struct -> struct-subscript .)
    S_ITERATE       reduce using rule 168 (array-or-struct -> struct-subscript .)
    S_ELSE          reduce using rule 168 (array-or-struct -> struct-subscript .)
    ID              reduce using rule 168 (array-or-struct -> struct-subscript .)
    C_APP           reduce using rule 168 (array-or-struct -> struct-subscript .)
    LPAREN          reduce using rule 168 (array-or-struct -> struct-subscript .)
    class_INT       reduce using rule 168 (array-or-struct -> struct-subscript .)
    class_DOUBLE    reduce using rule 168 (array-or-struct -> struct-subscript .)
    class_FLOAT     reduce using rule 168 (array-or-struct -> struct-subscript .)
    class_VOID      reduce using rule 168 (array-or-struct -> struct-subscript .)
    class_UINT      reduce using rule 168 (array-or-struct -> struct-subscript .)
    class_BOOL      reduce using rule 168 (array-or-struct -> struct-subscript .)
    class_CHARACTER reduce using rule 168 (array-or-struct -> struct-subscript .)
    class_String    reduce using rule 168 (array-or-struct -> struct-subscript .)
    collection_SET  reduce using rule 168 (array-or-struct -> struct-subscript .)
    collection_ARRAY reduce using rule 168 (array-or-struct -> struct-subscript .)
    collection_DICT reduce using rule 168 (array-or-struct -> struct-subscript .)
    $end            reduce using rule 168 (array-or-struct -> struct-subscript .)
    ARROW           reduce using rule 168 (array-or-struct -> struct-subscript .)
    RBRACE          reduce using rule 168 (array-or-struct -> struct-subscript .)
    S_CASE          reduce using rule 168 (array-or-struct -> struct-subscript .)
    S_DEFAULT       reduce using rule 168 (array-or-struct -> struct-subscript .)
    COLON           reduce using rule 168 (array-or-struct -> struct-subscript .)
    E_STDIN         reduce using rule 168 (array-or-struct -> struct-subscript .)
    E_STDOUT        reduce using rule 168 (array-or-struct -> struct-subscript .)
    E_STDERR        reduce using rule 168 (array-or-struct -> struct-subscript .)


state 228

    (162) unary-expr -> minus-or-excl postfix-expr .
    (166) postfix-expr -> postfix-expr . array-or-struct
    (167) array-or-struct -> . array-subscript
    (168) array-or-struct -> . struct-subscript
    (169) array-subscript -> . LBRACKET expr RBRACKET
    (170) struct-subscript -> . DOT ID

    MULT            reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    DIV             reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    MULTPER         reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    DOUBLEPER       reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    MOD             reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    PLUS            reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    MINUS           reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    LESS            reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    LESS_EQ         reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    EQUAL           reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    GREATER         reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    GREATER_EQ      reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    NOT_EQUAL       reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    LOG_AND         reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    LOG_OR          reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    RBRACKET        reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    SEMICOLON       reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    COMMA           reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    RPAREN          reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    C_GLOBAL        reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    D_IMPORT        reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    C_PRAGMA        reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    LBRACE          reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    S_IF            reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    S_SWITCH        reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    E_WAIT          reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    S_FOREACH       reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    S_FOR           reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    S_WHILE         reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    S_ITERATE       reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    S_ELSE          reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    ID              reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    C_APP           reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    LPAREN          reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    class_INT       reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    class_DOUBLE    reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    class_FLOAT     reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    class_VOID      reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    class_UINT      reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    class_BOOL      reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    class_CHARACTER reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    class_String    reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    collection_SET  reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    collection_ARRAY reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    collection_DICT reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    $end            reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    ARROW           reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    RBRACE          reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    S_CASE          reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    S_DEFAULT       reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    COLON           reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    E_STDIN         reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    E_STDOUT        reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    E_STDERR        reduce using rule 162 (unary-expr -> minus-or-excl postfix-expr .)
    LBRACKET        shift and go to state 70
    DOT             shift and go to state 71

    array-or-struct                shift and go to state 225
    array-subscript                shift and go to state 226
    struct-subscript               shift and go to state 227

state 229

    (174) base-expr -> LPAREN expr . RPAREN
    (184) -constructor -> LPAREN expr . COMMA expr comma-expr-star RPAREN

    RPAREN          shift and go to state 295
    COMMA           shift and go to state 296


state 230

    (196) array-kv-constructor -> LBRACE opt-array-constructor . RBRACE

    RBRACE          shift and go to state 297


state 231

    (197) opt-array-constructor -> array-kv-elem . comma-array-kv-elem-star
    (199) comma-array-kv-elem-star -> . COMMA array-kv-elem comma-array-kv-elem-star
    (200) comma-array-kv-elem-star -> . empty
    (76) empty -> .

    COMMA           shift and go to state 299
    RBRACE          reduce using rule 76 (empty -> .)

    comma-array-kv-elem-star       shift and go to state 298
    empty                          shift and go to state 300

state 232

    (198) opt-array-constructor -> empty .

    RBRACE          reduce using rule 198 (opt-array-constructor -> empty .)


state 233

    (201) array-kv-elem -> expr . COLON expr

    COLON           shift and go to state 301


state 234

    (24) global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .

    SEMICOLON       reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    C_GLOBAL        reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    D_IMPORT        reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    C_PRAGMA        reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    LBRACE          reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_IF            reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_SWITCH        reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    E_WAIT          reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_FOREACH       reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_FOR           reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_WHILE         reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_ITERATE       reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_ELSE          reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    ID              reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    C_APP           reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    LPAREN          reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_INT       reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_DOUBLE    reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_FLOAT     reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_VOID      reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_UINT      reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_BOOL      reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_CHARACTER reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_String    reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    collection_SET  reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    collection_ARRAY reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    collection_DICT reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    LESS            reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    $end            reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    RBRACE          reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_CASE          reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_DEFAULT       reduce using rule 24 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)


state 235

    (28) path-star -> DOT ID . path-star
    (28) path-star -> . DOT ID path-star
    (29) path-star -> .

    DOT             shift and go to state 156
    SEMICOLON       reduce using rule 29 (path-star -> .)

    path-star                      shift and go to state 302

state 236

    (30) pragma-stmt -> C_PRAGMA ID expr SEMICOLON .

    SEMICOLON       reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    C_GLOBAL        reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    D_IMPORT        reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    C_PRAGMA        reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    LBRACE          reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_IF            reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_SWITCH        reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    E_WAIT          reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_FOREACH       reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_FOR           reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_WHILE         reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_ITERATE       reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_ELSE          reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    ID              reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    C_APP           reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    LPAREN          reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_INT       reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_DOUBLE    reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_FLOAT     reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_VOID      reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_UINT      reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_BOOL      reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_CHARACTER reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_String    reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    collection_SET  reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    collection_ARRAY reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    collection_DICT reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    LESS            reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    $end            reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    RBRACE          reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_CASE          reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_DEFAULT       reduce using rule 30 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)


state 237

    (202) kw-expr -> ID ASSIGN . expr
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 303
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 238

    (177) func-call -> ID LPAREN func-call-arg-list RPAREN .

    SEMICOLON       reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    C_GLOBAL        reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    D_IMPORT        reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    C_PRAGMA        reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    LBRACE          reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    S_IF            reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    S_SWITCH        reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    E_WAIT          reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    S_FOREACH       reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    S_FOR           reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    S_WHILE         reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    S_ITERATE       reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    S_ELSE          reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    ID              reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    C_APP           reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    LPAREN          reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    class_INT       reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    class_DOUBLE    reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    class_FLOAT     reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    class_VOID      reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    class_UINT      reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    class_BOOL      reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    class_CHARACTER reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    class_String    reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    collection_SET  reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    collection_ARRAY reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    collection_DICT reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    LESS            reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    $end            reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    ARROW           reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    RBRACE          reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    S_CASE          reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    S_DEFAULT       reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    LBRACKET        reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    DOT             reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    MULT            reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    DIV             reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    MULTPER         reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    DOUBLEPER       reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    MOD             reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    PLUS            reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    MINUS           reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    LESS_EQ         reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    EQUAL           reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    GREATER         reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    GREATER_EQ      reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    NOT_EQUAL       reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    LOG_AND         reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    LOG_OR          reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    RBRACKET        reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    COMMA           reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    RPAREN          reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    COLON           reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    E_STDIN         reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    E_STDOUT        reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)
    E_STDERR        reduce using rule 177 (func-call -> ID LPAREN func-call-arg-list RPAREN .)


state 239

    (178) func-call-arg-list -> expr-or-kw func-call-arg-star .

    RPAREN          reduce using rule 178 (func-call-arg-list -> expr-or-kw func-call-arg-star .)


state 240

    (179) func-call-arg-star -> COMMA . expr-or-kw func-call-arg-star
    (181) expr-or-kw -> . expr
    (182) expr-or-kw -> . kw-expr
    (183) expr-or-kw -> . empty
    (134) expr -> . or-expr
    (202) kw-expr -> . ID ASSIGN expr
    (76) empty -> .
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    ID              shift and go to state 158
    COMMA           reduce using rule 76 (empty -> .)
    RPAREN          reduce using rule 76 (empty -> .)
    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr-or-kw                     shift and go to state 304
    expr                           shift and go to state 161
    kw-expr                        shift and go to state 162
    empty                          shift and go to state 163
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 241

    (180) func-call-arg-star -> empty .

    RPAREN          reduce using rule 180 (func-call-arg-star -> empty .)


state 242

    (106) if-stmt -> S_IF LPAREN expr RPAREN . block opt-else-block
    (90) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 305

state 243

    (109) switch-stmt -> S_SWITCH LPAREN expr RPAREN . LBRACE case-star opt-default RBRACE

    LBRACE          shift and go to state 306


state 244

    (116) wait-stmt -> E_WAIT opt-deep LPAREN expr-list . RPAREN block

    RPAREN          shift and go to state 307


state 245

    (119) foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN . expr block
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    var-name                       shift and go to state 131
    expr                           shift and go to state 308
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 246

    (120) opt-comma-var-name -> COMMA var-name .

    S_IN            reduce using rule 120 (opt-comma-var-name -> COMMA var-name .)


state 247

    (122) for-loop -> S_FOR LPAREN for-init-list SEMICOLON . expr SEMICOLON for-update-list RPAREN block
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 309
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 248

    (124) for-init-list -> for-init for-init-star .

    SEMICOLON       reduce using rule 124 (for-init-list -> for-init for-init-star .)


state 249

    (125) for-init-star -> COMMA . for-init for-init-star
    (127) for-init -> . for-assignment
    (128) for-init -> . type-prefix var-name type-suffix ASSIGN expr
    (132) for-assignment -> . var-name ASSIGN expr
    (81) type-prefix -> . type-name
    (82) type-prefix -> . param-type
    (227) var-name -> . ID
    (214) type-name -> . class_INT
    (215) type-name -> . class_DOUBLE
    (216) type-name -> . class_FLOAT
    (217) type-name -> . class_VOID
    (218) type-name -> . class_UINT
    (219) type-name -> . class_BOOL
    (220) type-name -> . class_CHARACTER
    (221) type-name -> . class_String
    (222) type-name -> . collection_SET
    (223) type-name -> . collection_ARRAY
    (224) type-name -> . collection_DICT
    (225) type-name -> . ID
    (83) param-type -> . type-name LESS standalone-type GREATER

    ID              shift and go to state 177
    class_INT       shift and go to state 52
    class_DOUBLE    shift and go to state 53
    class_FLOAT     shift and go to state 54
    class_VOID      shift and go to state 55
    class_UINT      shift and go to state 56
    class_BOOL      shift and go to state 57
    class_CHARACTER shift and go to state 58
    class_String    shift and go to state 59
    collection_SET  shift and go to state 60
    collection_ARRAY shift and go to state 61
    collection_DICT shift and go to state 62

    for-init                       shift and go to state 310
    for-assignment                 shift and go to state 174
    type-prefix                    shift and go to state 175
    var-name                       shift and go to state 176
    type-name                      shift and go to state 48
    param-type                     shift and go to state 49

state 250

    (128) for-init -> type-prefix var-name . type-suffix ASSIGN expr
    (84) type-suffix -> . LBRACKET empty-or-standalone-type RBRACKET type-suffix
    (85) type-suffix -> .

    LBRACKET        shift and go to state 179
    ASSIGN          reduce using rule 85 (type-suffix -> .)

    type-suffix                    shift and go to state 311

state 251

    (132) for-assignment -> var-name ASSIGN . expr
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    var-name                       shift and go to state 131
    expr                           shift and go to state 312
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 252

    (75) var-decl-rest -> var-name type-suffix empty-or-var-mapping . empty-or-assign-expr
    (79) empty-or-assign-expr -> . ASSIGN expr
    (80) empty-or-assign-expr -> . empty
    (76) empty -> .

    ASSIGN          shift and go to state 314
    SEMICOLON       reduce using rule 76 (empty -> .)
    C_GLOBAL        reduce using rule 76 (empty -> .)
    D_IMPORT        reduce using rule 76 (empty -> .)
    C_PRAGMA        reduce using rule 76 (empty -> .)
    LBRACE          reduce using rule 76 (empty -> .)
    S_IF            reduce using rule 76 (empty -> .)
    S_SWITCH        reduce using rule 76 (empty -> .)
    E_WAIT          reduce using rule 76 (empty -> .)
    S_FOREACH       reduce using rule 76 (empty -> .)
    S_FOR           reduce using rule 76 (empty -> .)
    S_WHILE         reduce using rule 76 (empty -> .)
    S_ITERATE       reduce using rule 76 (empty -> .)
    S_ELSE          reduce using rule 76 (empty -> .)
    ID              reduce using rule 76 (empty -> .)
    C_APP           reduce using rule 76 (empty -> .)
    LPAREN          reduce using rule 76 (empty -> .)
    class_INT       reduce using rule 76 (empty -> .)
    class_DOUBLE    reduce using rule 76 (empty -> .)
    class_FLOAT     reduce using rule 76 (empty -> .)
    class_VOID      reduce using rule 76 (empty -> .)
    class_UINT      reduce using rule 76 (empty -> .)
    class_BOOL      reduce using rule 76 (empty -> .)
    class_CHARACTER reduce using rule 76 (empty -> .)
    class_String    reduce using rule 76 (empty -> .)
    collection_SET  reduce using rule 76 (empty -> .)
    collection_ARRAY reduce using rule 76 (empty -> .)
    collection_DICT reduce using rule 76 (empty -> .)
    LESS            reduce using rule 76 (empty -> .)
    $end            reduce using rule 76 (empty -> .)
    ARROW           reduce using rule 76 (empty -> .)
    RBRACE          reduce using rule 76 (empty -> .)
    S_CASE          reduce using rule 76 (empty -> .)
    S_DEFAULT       reduce using rule 76 (empty -> .)

    empty-or-assign-expr           shift and go to state 313
    empty                          shift and go to state 315

state 253

    (77) empty-or-var-mapping -> var-mapping .

    ASSIGN          reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    SEMICOLON       reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    C_GLOBAL        reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    D_IMPORT        reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    C_PRAGMA        reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    LBRACE          reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    S_IF            reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    S_SWITCH        reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    E_WAIT          reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    S_FOREACH       reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    S_FOR           reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    S_WHILE         reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    S_ITERATE       reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    S_ELSE          reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    ID              reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    C_APP           reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    LPAREN          reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    class_INT       reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    class_DOUBLE    reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    class_FLOAT     reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    class_VOID      reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    class_UINT      reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    class_BOOL      reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    class_CHARACTER reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    class_String    reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    collection_SET  reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    collection_ARRAY reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    collection_DICT reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    LESS            reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    $end            reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    ARROW           reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    RBRACE          reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    S_CASE          reduce using rule 77 (empty-or-var-mapping -> var-mapping .)
    S_DEFAULT       reduce using rule 77 (empty-or-var-mapping -> var-mapping .)


state 254

    (78) empty-or-var-mapping -> empty .

    ASSIGN          reduce using rule 78 (empty-or-var-mapping -> empty .)
    SEMICOLON       reduce using rule 78 (empty-or-var-mapping -> empty .)
    C_GLOBAL        reduce using rule 78 (empty-or-var-mapping -> empty .)
    D_IMPORT        reduce using rule 78 (empty-or-var-mapping -> empty .)
    C_PRAGMA        reduce using rule 78 (empty-or-var-mapping -> empty .)
    LBRACE          reduce using rule 78 (empty-or-var-mapping -> empty .)
    S_IF            reduce using rule 78 (empty-or-var-mapping -> empty .)
    S_SWITCH        reduce using rule 78 (empty-or-var-mapping -> empty .)
    E_WAIT          reduce using rule 78 (empty-or-var-mapping -> empty .)
    S_FOREACH       reduce using rule 78 (empty-or-var-mapping -> empty .)
    S_FOR           reduce using rule 78 (empty-or-var-mapping -> empty .)
    S_WHILE         reduce using rule 78 (empty-or-var-mapping -> empty .)
    S_ITERATE       reduce using rule 78 (empty-or-var-mapping -> empty .)
    S_ELSE          reduce using rule 78 (empty-or-var-mapping -> empty .)
    ID              reduce using rule 78 (empty-or-var-mapping -> empty .)
    C_APP           reduce using rule 78 (empty-or-var-mapping -> empty .)
    LPAREN          reduce using rule 78 (empty-or-var-mapping -> empty .)
    class_INT       reduce using rule 78 (empty-or-var-mapping -> empty .)
    class_DOUBLE    reduce using rule 78 (empty-or-var-mapping -> empty .)
    class_FLOAT     reduce using rule 78 (empty-or-var-mapping -> empty .)
    class_VOID      reduce using rule 78 (empty-or-var-mapping -> empty .)
    class_UINT      reduce using rule 78 (empty-or-var-mapping -> empty .)
    class_BOOL      reduce using rule 78 (empty-or-var-mapping -> empty .)
    class_CHARACTER reduce using rule 78 (empty-or-var-mapping -> empty .)
    class_String    reduce using rule 78 (empty-or-var-mapping -> empty .)
    collection_SET  reduce using rule 78 (empty-or-var-mapping -> empty .)
    collection_ARRAY reduce using rule 78 (empty-or-var-mapping -> empty .)
    collection_DICT reduce using rule 78 (empty-or-var-mapping -> empty .)
    LESS            reduce using rule 78 (empty-or-var-mapping -> empty .)
    $end            reduce using rule 78 (empty-or-var-mapping -> empty .)
    ARROW           reduce using rule 78 (empty-or-var-mapping -> empty .)
    RBRACE          reduce using rule 78 (empty-or-var-mapping -> empty .)
    S_CASE          reduce using rule 78 (empty-or-var-mapping -> empty .)
    S_DEFAULT       reduce using rule 78 (empty-or-var-mapping -> empty .)


state 255

    (89) var-mapping -> LESS . expr GREATER
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 316
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 256

    (84) type-suffix -> LBRACKET empty-or-standalone-type . RBRACKET type-suffix

    RBRACKET        shift and go to state 317


state 257

    (86) empty-or-standalone-type -> standalone-type .

    RBRACKET        reduce using rule 86 (empty-or-standalone-type -> standalone-type .)


state 258

    (123) while-loop -> S_WHILE LPAREN expr RPAREN . block
    (90) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 318

state 259

    (133) iterate-loop -> S_ITERATE var-name block S_UNTIL . LPAREN expr RPAREN

    LPAREN          shift and go to state 319


state 260

    (37) type-params -> LESS var-name comma-name-star GREATER .

    LPAREN          reduce using rule 37 (type-params -> LESS var-name comma-name-star GREATER .)
    ID              reduce using rule 37 (type-params -> LESS var-name comma-name-star GREATER .)


state 261

    (39) comma-name-star -> COMMA var-name . comma-name-star
    (39) comma-name-star -> . COMMA var-name comma-name-star
    (40) comma-name-star -> .

    COMMA           shift and go to state 187
    GREATER         reduce using rule 40 (comma-name-star -> .)

    comma-name-star                shift and go to state 320

state 262

    (66) empty-or-literal -> STR_LITERAL .

    LBRACKET        reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    SEMICOLON       reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    C_GLOBAL        reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    D_IMPORT        reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    C_PRAGMA        reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    LBRACE          reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    S_IF            reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    S_SWITCH        reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    E_WAIT          reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    S_FOREACH       reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    S_FOR           reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    S_WHILE         reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    S_ITERATE       reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    S_ELSE          reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    ID              reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    C_APP           reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    LPAREN          reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    class_INT       reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    class_DOUBLE    reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    class_FLOAT     reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    class_VOID      reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    class_UINT      reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    class_BOOL      reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    class_CHARACTER reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    class_String    reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    collection_SET  reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    collection_ARRAY reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    collection_DICT reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    LESS            reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    $end            reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    RBRACE          reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    S_CASE          reduce using rule 66 (empty-or-literal -> STR_LITERAL .)
    S_DEFAULT       reduce using rule 66 (empty-or-literal -> STR_LITERAL .)


state 263

    (65) foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal . empty-or-more-literals
    (68) empty-or-more-literals -> . LBRACKET single-or-multiple-literal RBRACKET
    (69) empty-or-more-literals -> . empty
    (76) empty -> .

    LBRACKET        shift and go to state 322
    SEMICOLON       reduce using rule 76 (empty -> .)
    C_GLOBAL        reduce using rule 76 (empty -> .)
    D_IMPORT        reduce using rule 76 (empty -> .)
    C_PRAGMA        reduce using rule 76 (empty -> .)
    LBRACE          reduce using rule 76 (empty -> .)
    S_IF            reduce using rule 76 (empty -> .)
    S_SWITCH        reduce using rule 76 (empty -> .)
    E_WAIT          reduce using rule 76 (empty -> .)
    S_FOREACH       reduce using rule 76 (empty -> .)
    S_FOR           reduce using rule 76 (empty -> .)
    S_WHILE         reduce using rule 76 (empty -> .)
    S_ITERATE       reduce using rule 76 (empty -> .)
    S_ELSE          reduce using rule 76 (empty -> .)
    ID              reduce using rule 76 (empty -> .)
    C_APP           reduce using rule 76 (empty -> .)
    LPAREN          reduce using rule 76 (empty -> .)
    class_INT       reduce using rule 76 (empty -> .)
    class_DOUBLE    reduce using rule 76 (empty -> .)
    class_FLOAT     reduce using rule 76 (empty -> .)
    class_VOID      reduce using rule 76 (empty -> .)
    class_UINT      reduce using rule 76 (empty -> .)
    class_BOOL      reduce using rule 76 (empty -> .)
    class_CHARACTER reduce using rule 76 (empty -> .)
    class_String    reduce using rule 76 (empty -> .)
    collection_SET  reduce using rule 76 (empty -> .)
    collection_ARRAY reduce using rule 76 (empty -> .)
    collection_DICT reduce using rule 76 (empty -> .)
    LESS            reduce using rule 76 (empty -> .)
    $end            reduce using rule 76 (empty -> .)
    RBRACE          reduce using rule 76 (empty -> .)
    S_CASE          reduce using rule 76 (empty -> .)
    S_DEFAULT       reduce using rule 76 (empty -> .)

    empty-or-more-literals         shift and go to state 321
    empty                          shift and go to state 323

state 264

    (67) empty-or-literal -> empty .

    LBRACKET        reduce using rule 67 (empty-or-literal -> empty .)
    SEMICOLON       reduce using rule 67 (empty-or-literal -> empty .)
    C_GLOBAL        reduce using rule 67 (empty-or-literal -> empty .)
    D_IMPORT        reduce using rule 67 (empty-or-literal -> empty .)
    C_PRAGMA        reduce using rule 67 (empty-or-literal -> empty .)
    LBRACE          reduce using rule 67 (empty-or-literal -> empty .)
    S_IF            reduce using rule 67 (empty-or-literal -> empty .)
    S_SWITCH        reduce using rule 67 (empty-or-literal -> empty .)
    E_WAIT          reduce using rule 67 (empty-or-literal -> empty .)
    S_FOREACH       reduce using rule 67 (empty-or-literal -> empty .)
    S_FOR           reduce using rule 67 (empty-or-literal -> empty .)
    S_WHILE         reduce using rule 67 (empty-or-literal -> empty .)
    S_ITERATE       reduce using rule 67 (empty-or-literal -> empty .)
    S_ELSE          reduce using rule 67 (empty-or-literal -> empty .)
    ID              reduce using rule 67 (empty-or-literal -> empty .)
    C_APP           reduce using rule 67 (empty-or-literal -> empty .)
    LPAREN          reduce using rule 67 (empty-or-literal -> empty .)
    class_INT       reduce using rule 67 (empty-or-literal -> empty .)
    class_DOUBLE    reduce using rule 67 (empty-or-literal -> empty .)
    class_FLOAT     reduce using rule 67 (empty-or-literal -> empty .)
    class_VOID      reduce using rule 67 (empty-or-literal -> empty .)
    class_UINT      reduce using rule 67 (empty-or-literal -> empty .)
    class_BOOL      reduce using rule 67 (empty-or-literal -> empty .)
    class_CHARACTER reduce using rule 67 (empty-or-literal -> empty .)
    class_String    reduce using rule 67 (empty-or-literal -> empty .)
    collection_SET  reduce using rule 67 (empty-or-literal -> empty .)
    collection_ARRAY reduce using rule 67 (empty-or-literal -> empty .)
    collection_DICT reduce using rule 67 (empty-or-literal -> empty .)
    LESS            reduce using rule 67 (empty-or-literal -> empty .)
    $end            reduce using rule 67 (empty-or-literal -> empty .)
    RBRACE          reduce using rule 67 (empty-or-literal -> empty .)
    S_CASE          reduce using rule 67 (empty-or-literal -> empty .)
    S_DEFAULT       reduce using rule 67 (empty-or-literal -> empty .)


state 265

    (53) app-func-defn -> C_APP func-hdr LBRACE app-body . RBRACE

    RBRACE          shift and go to state 324


state 266

    (54) app-body -> app-arg-expr . app-arg-expr-star app-out-star empty-or-semicolon
    (62) app-arg-expr-star -> . app-arg-expr app-arg-expr-star
    (63) app-arg-expr-star -> .
    (235) app-arg-expr -> . opt-at var-name
    (236) app-arg-expr -> . literal
    (237) app-arg-expr -> . array-constructor
    (238) app-arg-expr -> . LPAREN expr RPAREN
    (239) opt-at -> . AT
    (240) opt-at -> . empty
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (76) empty -> .
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    E_STDIN         reduce using rule 63 (app-arg-expr-star -> .)
    E_STDOUT        reduce using rule 63 (app-arg-expr-star -> .)
    E_STDERR        reduce using rule 63 (app-arg-expr-star -> .)
    SEMICOLON       reduce using rule 63 (app-arg-expr-star -> .)
    RBRACE          reduce using rule 63 (app-arg-expr-star -> .)
    LPAREN          shift and go to state 270
    AT              shift and go to state 271
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              reduce using rule 76 (empty -> .)
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    app-arg-expr                   shift and go to state 325
    app-arg-expr-star              shift and go to state 326
    opt-at                         shift and go to state 267
    literal                        shift and go to state 268
    array-constructor              shift and go to state 269
    empty                          shift and go to state 272
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 267

    (235) app-arg-expr -> opt-at . var-name
    (227) var-name -> . ID

    ID              shift and go to state 82

    var-name                       shift and go to state 327

state 268

    (236) app-arg-expr -> literal .

    LPAREN          reduce using rule 236 (app-arg-expr -> literal .)
    AT              reduce using rule 236 (app-arg-expr -> literal .)
    STR_LITERAL     reduce using rule 236 (app-arg-expr -> literal .)
    MUL_STR_LITERAL reduce using rule 236 (app-arg-expr -> literal .)
    INT             reduce using rule 236 (app-arg-expr -> literal .)
    DOUBLE          reduce using rule 236 (app-arg-expr -> literal .)
    INF             reduce using rule 236 (app-arg-expr -> literal .)
    NAN             reduce using rule 236 (app-arg-expr -> literal .)
    E_TRUE          reduce using rule 236 (app-arg-expr -> literal .)
    E_FALSE         reduce using rule 236 (app-arg-expr -> literal .)
    LBRACKET        reduce using rule 236 (app-arg-expr -> literal .)
    LBRACE          reduce using rule 236 (app-arg-expr -> literal .)
    E_STDIN         reduce using rule 236 (app-arg-expr -> literal .)
    E_STDOUT        reduce using rule 236 (app-arg-expr -> literal .)
    E_STDERR        reduce using rule 236 (app-arg-expr -> literal .)
    SEMICOLON       reduce using rule 236 (app-arg-expr -> literal .)
    ID              reduce using rule 236 (app-arg-expr -> literal .)
    RBRACE          reduce using rule 236 (app-arg-expr -> literal .)


state 269

    (237) app-arg-expr -> array-constructor .

    LPAREN          reduce using rule 237 (app-arg-expr -> array-constructor .)
    AT              reduce using rule 237 (app-arg-expr -> array-constructor .)
    STR_LITERAL     reduce using rule 237 (app-arg-expr -> array-constructor .)
    MUL_STR_LITERAL reduce using rule 237 (app-arg-expr -> array-constructor .)
    INT             reduce using rule 237 (app-arg-expr -> array-constructor .)
    DOUBLE          reduce using rule 237 (app-arg-expr -> array-constructor .)
    INF             reduce using rule 237 (app-arg-expr -> array-constructor .)
    NAN             reduce using rule 237 (app-arg-expr -> array-constructor .)
    E_TRUE          reduce using rule 237 (app-arg-expr -> array-constructor .)
    E_FALSE         reduce using rule 237 (app-arg-expr -> array-constructor .)
    LBRACKET        reduce using rule 237 (app-arg-expr -> array-constructor .)
    LBRACE          reduce using rule 237 (app-arg-expr -> array-constructor .)
    E_STDIN         reduce using rule 237 (app-arg-expr -> array-constructor .)
    E_STDOUT        reduce using rule 237 (app-arg-expr -> array-constructor .)
    E_STDERR        reduce using rule 237 (app-arg-expr -> array-constructor .)
    SEMICOLON       reduce using rule 237 (app-arg-expr -> array-constructor .)
    ID              reduce using rule 237 (app-arg-expr -> array-constructor .)
    RBRACE          reduce using rule 237 (app-arg-expr -> array-constructor .)


state 270

    (238) app-arg-expr -> LPAREN . expr RPAREN
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 328
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 271

    (239) opt-at -> AT .

    ID              reduce using rule 239 (opt-at -> AT .)


state 272

    (240) opt-at -> empty .

    ID              reduce using rule 240 (opt-at -> empty .)


state 273

    (83) param-type -> type-name LESS standalone-type GREATER .

    ID              reduce using rule 83 (param-type -> type-name LESS standalone-type GREATER .)
    LBRACKET        reduce using rule 83 (param-type -> type-name LESS standalone-type GREATER .)
    GREATER         reduce using rule 83 (param-type -> type-name LESS standalone-type GREATER .)
    RANGE           reduce using rule 83 (param-type -> type-name LESS standalone-type GREATER .)
    RBRACKET        reduce using rule 83 (param-type -> type-name LESS standalone-type GREATER .)


state 274

    (88) standalone-type -> type-prefix type-suffix .

    GREATER         reduce using rule 88 (standalone-type -> type-prefix type-suffix .)
    RBRACKET        reduce using rule 88 (standalone-type -> type-prefix type-suffix .)


state 275

    (35) empty-or-arg-list -> formal-arg-list .

    ARROW           reduce using rule 35 (empty-or-arg-list -> formal-arg-list .)
    STR_LITERAL     reduce using rule 35 (empty-or-arg-list -> formal-arg-list .)
    LBRACE          reduce using rule 35 (empty-or-arg-list -> formal-arg-list .)


state 276

    (34) func-hdr -> type-params formal-arg-list ID empty-or-arg-list .

    ARROW           reduce using rule 34 (func-hdr -> type-params formal-arg-list ID empty-or-arg-list .)
    STR_LITERAL     reduce using rule 34 (func-hdr -> type-params formal-arg-list ID empty-or-arg-list .)
    LBRACE          reduce using rule 34 (func-hdr -> type-params formal-arg-list ID empty-or-arg-list .)


state 277

    (36) empty-or-arg-list -> empty .
    (42) formal-arg-list -> empty .

  ! reduce/reduce conflict for ARROW resolved using rule 36 (empty-or-arg-list -> empty .)
  ! reduce/reduce conflict for STR_LITERAL resolved using rule 36 (empty-or-arg-list -> empty .)
  ! reduce/reduce conflict for LBRACE resolved using rule 36 (empty-or-arg-list -> empty .)
    ARROW           reduce using rule 36 (empty-or-arg-list -> empty .)
    STR_LITERAL     reduce using rule 36 (empty-or-arg-list -> empty .)
    LBRACE          reduce using rule 36 (empty-or-arg-list -> empty .)

  ! ARROW           [ reduce using rule 42 (formal-arg-list -> empty .) ]
  ! STR_LITERAL     [ reduce using rule 42 (formal-arg-list -> empty .) ]
  ! LBRACE          [ reduce using rule 42 (formal-arg-list -> empty .) ]


state 278

    (41) formal-arg-list -> LPAREN opt-formal-args RPAREN .

    ID              reduce using rule 41 (formal-arg-list -> LPAREN opt-formal-args RPAREN .)
    ARROW           reduce using rule 41 (formal-arg-list -> LPAREN opt-formal-args RPAREN .)
    STR_LITERAL     reduce using rule 41 (formal-arg-list -> LPAREN opt-formal-args RPAREN .)
    LBRACE          reduce using rule 41 (formal-arg-list -> LPAREN opt-formal-args RPAREN .)
    ASSIGN          reduce using rule 41 (formal-arg-list -> LPAREN opt-formal-args RPAREN .)


state 279

    (43) opt-formal-args -> formal-arg comma-args-star .

    RPAREN          reduce using rule 43 (opt-formal-args -> formal-arg comma-args-star .)


state 280

    (45) comma-args-star -> COMMA . formal-arg comma-args-star
    (47) formal-arg -> . type-prefix empty-or-range var-name type-suffix empty-or-ass-expr
    (81) type-prefix -> . type-name
    (82) type-prefix -> . param-type
    (214) type-name -> . class_INT
    (215) type-name -> . class_DOUBLE
    (216) type-name -> . class_FLOAT
    (217) type-name -> . class_VOID
    (218) type-name -> . class_UINT
    (219) type-name -> . class_BOOL
    (220) type-name -> . class_CHARACTER
    (221) type-name -> . class_String
    (222) type-name -> . collection_SET
    (223) type-name -> . collection_ARRAY
    (224) type-name -> . collection_DICT
    (225) type-name -> . ID
    (83) param-type -> . type-name LESS standalone-type GREATER

    class_INT       shift and go to state 52
    class_DOUBLE    shift and go to state 53
    class_FLOAT     shift and go to state 54
    class_VOID      shift and go to state 55
    class_UINT      shift and go to state 56
    class_BOOL      shift and go to state 57
    class_CHARACTER shift and go to state 58
    class_String    shift and go to state 59
    collection_SET  shift and go to state 60
    collection_ARRAY shift and go to state 61
    collection_DICT shift and go to state 62
    ID              shift and go to state 152

    formal-arg                     shift and go to state 329
    type-prefix                    shift and go to state 197
    type-name                      shift and go to state 48
    param-type                     shift and go to state 49

state 281

    (46) comma-args-star -> empty .

    RPAREN          reduce using rule 46 (comma-args-star -> empty .)


state 282

    (47) formal-arg -> type-prefix empty-or-range . var-name type-suffix empty-or-ass-expr
    (227) var-name -> . ID

    ID              shift and go to state 82

    var-name                       shift and go to state 330

state 283

    (48) empty-or-range -> RANGE .

    ID              reduce using rule 48 (empty-or-range -> RANGE .)


state 284

    (49) empty-or-range -> empty .

    ID              reduce using rule 49 (empty-or-range -> empty .)


state 285

    (229) lval-expr-star -> COMMA lval-expr lval-expr-star .

    ASSIGN          reduce using rule 229 (lval-expr-star -> COMMA lval-expr lval-expr-star .)
    PLUS_AS         reduce using rule 229 (lval-expr-star -> COMMA lval-expr lval-expr-star .)
    RPAREN          reduce using rule 229 (lval-expr-star -> COMMA lval-expr lval-expr-star .)


state 286

    (105) update-stmt -> var-name LESS ID GREATER UPD . expr SEMICOLON
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    var-name                       shift and go to state 131
    expr                           shift and go to state 331
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 287

    (190) array-list-constructor -> LBRACKET opt-expr-list RBRACKET .

    LBRACKET        reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    DOT             reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    MULT            reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    DIV             reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    MULTPER         reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    DOUBLEPER       reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    MOD             reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    PLUS            reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    MINUS           reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    LESS            reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    LESS_EQ         reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    EQUAL           reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    GREATER         reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    GREATER_EQ      reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    NOT_EQUAL       reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    LOG_AND         reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    LOG_OR          reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    RBRACKET        reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    SEMICOLON       reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    COMMA           reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    RPAREN          reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    C_GLOBAL        reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    D_IMPORT        reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    C_PRAGMA        reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    LBRACE          reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    S_IF            reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    S_SWITCH        reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    E_WAIT          reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    S_FOREACH       reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    S_FOR           reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    S_WHILE         reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    S_ITERATE       reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    S_ELSE          reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    ID              reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    C_APP           reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    LPAREN          reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    class_INT       reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    class_DOUBLE    reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    class_FLOAT     reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    class_VOID      reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    class_UINT      reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    class_BOOL      reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    class_CHARACTER reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    class_String    reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    collection_SET  reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    collection_ARRAY reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    collection_DICT reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    $end            reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    ARROW           reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    RBRACE          reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    S_CASE          reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    S_DEFAULT       reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    COLON           reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    E_STDIN         reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    E_STDOUT        reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    E_STDERR        reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    AT              reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    STR_LITERAL     reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    MUL_STR_LITERAL reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    INT             reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    DOUBLE          reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    INF             reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    NAN             reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    E_TRUE          reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    E_FALSE         reduce using rule 190 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)


state 288

    (193) array-range-constructor -> LBRACKET expr COLON . expr opt-coloned-expr RBRACKET
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 332
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 289

    (136) or-expr -> or-expr LOG_OR and-expr .
    (138) and-expr -> and-expr . LOG_AND eq-expr

    LOG_OR          reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    RBRACKET        reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    SEMICOLON       reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    COMMA           reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    RPAREN          reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    C_GLOBAL        reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    D_IMPORT        reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    C_PRAGMA        reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    LBRACE          reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    S_IF            reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    S_SWITCH        reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    E_WAIT          reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    S_FOREACH       reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    S_FOR           reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    S_WHILE         reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    S_ITERATE       reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    S_ELSE          reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    ID              reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    C_APP           reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    LPAREN          reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    class_INT       reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    class_DOUBLE    reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    class_FLOAT     reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    class_VOID      reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    class_UINT      reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    class_BOOL      reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    class_CHARACTER reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    class_String    reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    collection_SET  reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    collection_ARRAY reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    collection_DICT reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    LESS            reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    $end            reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    ARROW           reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    RBRACE          reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    S_CASE          reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    S_DEFAULT       reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    COLON           reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    GREATER         reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    E_STDIN         reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    E_STDOUT        reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    E_STDERR        reduce using rule 136 (or-expr -> or-expr LOG_OR and-expr .)
    LOG_AND         shift and go to state 206


state 290

    (138) and-expr -> and-expr LOG_AND eq-expr .
    (140) eq-expr -> eq-expr . eq-or-not-eq eq-expr
    (141) eq-or-not-eq -> . EQUAL
    (142) eq-or-not-eq -> . NOT_EQUAL

    LOG_AND         reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    LOG_OR          reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    RBRACKET        reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    SEMICOLON       reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    COMMA           reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    RPAREN          reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    C_GLOBAL        reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    D_IMPORT        reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    C_PRAGMA        reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    LBRACE          reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    S_IF            reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    S_SWITCH        reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    E_WAIT          reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    S_FOREACH       reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    S_FOR           reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    S_WHILE         reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    S_ITERATE       reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    S_ELSE          reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    ID              reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    C_APP           reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    LPAREN          reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    class_INT       reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    class_DOUBLE    reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    class_FLOAT     reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    class_VOID      reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    class_UINT      reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    class_BOOL      reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    class_CHARACTER reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    class_String    reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    collection_SET  reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    collection_ARRAY reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    collection_DICT reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    LESS            reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    $end            reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    ARROW           reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    RBRACE          reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    S_CASE          reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    S_DEFAULT       reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    COLON           reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    GREATER         reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    E_STDIN         reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    E_STDOUT        reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    E_STDERR        reduce using rule 138 (and-expr -> and-expr LOG_AND eq-expr .)
    EQUAL           shift and go to state 208
    NOT_EQUAL       shift and go to state 209

    eq-or-not-eq                   shift and go to state 207

state 291

    (140) eq-expr -> eq-expr eq-or-not-eq eq-expr .
    (140) eq-expr -> eq-expr . eq-or-not-eq eq-expr
    (141) eq-or-not-eq -> . EQUAL
    (142) eq-or-not-eq -> . NOT_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
    LOG_AND         reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    LOG_OR          reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    RBRACKET        reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    SEMICOLON       reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    COMMA           reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    RPAREN          reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    C_GLOBAL        reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    D_IMPORT        reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    C_PRAGMA        reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    LBRACE          reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    S_IF            reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    S_SWITCH        reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    E_WAIT          reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    S_FOREACH       reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    S_FOR           reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    S_WHILE         reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    S_ITERATE       reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    S_ELSE          reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    ID              reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    C_APP           reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    LPAREN          reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    class_INT       reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    class_DOUBLE    reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    class_FLOAT     reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    class_VOID      reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    class_UINT      reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    class_BOOL      reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    class_CHARACTER reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    class_String    reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    collection_SET  reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    collection_ARRAY reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    collection_DICT reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    LESS            reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    $end            reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    ARROW           reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    RBRACE          reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    S_CASE          reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    S_DEFAULT       reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    COLON           reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    GREATER         reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    E_STDIN         reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    E_STDOUT        reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    E_STDERR        reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    EQUAL           shift and go to state 208
    NOT_EQUAL       shift and go to state 209

  ! EQUAL           [ reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .) ]
  ! NOT_EQUAL       [ reduce using rule 140 (eq-expr -> eq-expr eq-or-not-eq eq-expr .) ]

    eq-or-not-eq                   shift and go to state 207

state 292

    (144) cmp-expr -> cmp-expr cmp-sign add-expr .
    (151) add-expr -> add-expr . add-sign mult-expr
    (152) add-sign -> . PLUS
    (153) add-sign -> . MINUS

    LESS            reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    LESS_EQ         reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    EQUAL           reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    GREATER         reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    GREATER_EQ      reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    NOT_EQUAL       reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    LOG_AND         reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    LOG_OR          reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    RBRACKET        reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    SEMICOLON       reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    COMMA           reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    RPAREN          reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    C_GLOBAL        reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    D_IMPORT        reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    C_PRAGMA        reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    LBRACE          reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    S_IF            reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    S_SWITCH        reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    E_WAIT          reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    S_FOREACH       reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    S_FOR           reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    S_WHILE         reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    S_ITERATE       reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    S_ELSE          reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    ID              reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    C_APP           reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    LPAREN          reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    class_INT       reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    class_DOUBLE    reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    class_FLOAT     reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    class_VOID      reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    class_UINT      reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    class_BOOL      reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    class_CHARACTER reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    class_String    reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    collection_SET  reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    collection_ARRAY reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    collection_DICT reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    $end            reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    ARROW           reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    RBRACE          reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    S_CASE          reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    S_DEFAULT       reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    COLON           reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    E_STDIN         reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    E_STDOUT        reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    E_STDERR        reduce using rule 144 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    PLUS            shift and go to state 217
    MINUS           shift and go to state 218

    add-sign                       shift and go to state 216

state 293

    (151) add-expr -> add-expr add-sign mult-expr .
    (155) mult-expr -> mult-expr . mult-sign unary-expr
    (156) mult-sign -> . MULT
    (157) mult-sign -> . DIV
    (158) mult-sign -> . MULTPER
    (159) mult-sign -> . DOUBLEPER
    (160) mult-sign -> . MOD

    PLUS            reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    MINUS           reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    LESS            reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    LESS_EQ         reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    EQUAL           reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    GREATER         reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    GREATER_EQ      reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    NOT_EQUAL       reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    LOG_AND         reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    LOG_OR          reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    RBRACKET        reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    SEMICOLON       reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    COMMA           reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    RPAREN          reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    C_GLOBAL        reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    D_IMPORT        reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    C_PRAGMA        reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    LBRACE          reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    S_IF            reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    S_SWITCH        reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    E_WAIT          reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    S_FOREACH       reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    S_FOR           reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    S_WHILE         reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    S_ITERATE       reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    S_ELSE          reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    ID              reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    C_APP           reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    LPAREN          reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    class_INT       reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    class_DOUBLE    reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    class_FLOAT     reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    class_VOID      reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    class_UINT      reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    class_BOOL      reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    class_CHARACTER reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    class_String    reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    collection_SET  reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    collection_ARRAY reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    collection_DICT reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    $end            reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    ARROW           reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    RBRACE          reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    S_CASE          reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    S_DEFAULT       reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    COLON           reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    E_STDIN         reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    E_STDOUT        reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    E_STDERR        reduce using rule 151 (add-expr -> add-expr add-sign mult-expr .)
    MULT            shift and go to state 220
    DIV             shift and go to state 221
    MULTPER         shift and go to state 222
    DOUBLEPER       shift and go to state 223
    MOD             shift and go to state 224

    mult-sign                      shift and go to state 219

state 294

    (155) mult-expr -> mult-expr mult-sign unary-expr .

    MULT            reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    DIV             reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    MULTPER         reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    DOUBLEPER       reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    MOD             reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    PLUS            reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    MINUS           reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    LESS            reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    LESS_EQ         reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    EQUAL           reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    GREATER         reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    GREATER_EQ      reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    NOT_EQUAL       reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    LOG_AND         reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    LOG_OR          reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    RBRACKET        reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    SEMICOLON       reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    COMMA           reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    RPAREN          reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    C_GLOBAL        reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    D_IMPORT        reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    C_PRAGMA        reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    LBRACE          reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    S_IF            reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    S_SWITCH        reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    E_WAIT          reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    S_FOREACH       reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    S_FOR           reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    S_WHILE         reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    S_ITERATE       reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    S_ELSE          reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    ID              reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    C_APP           reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    LPAREN          reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    class_INT       reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    class_DOUBLE    reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    class_FLOAT     reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    class_VOID      reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    class_UINT      reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    class_BOOL      reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    class_CHARACTER reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    class_String    reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    collection_SET  reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    collection_ARRAY reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    collection_DICT reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    $end            reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    ARROW           reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    RBRACE          reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    S_CASE          reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    S_DEFAULT       reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    COLON           reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    E_STDIN         reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    E_STDOUT        reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)
    E_STDERR        reduce using rule 155 (mult-expr -> mult-expr mult-sign unary-expr .)


state 295

    (174) base-expr -> LPAREN expr RPAREN .

    LBRACKET        reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    DOT             reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    MULT            reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    DIV             reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    MULTPER         reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    DOUBLEPER       reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    MOD             reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    LESS            reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    LESS_EQ         reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    EQUAL           reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    GREATER         reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    NOT_EQUAL       reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    LOG_AND         reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    LOG_OR          reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    C_GLOBAL        reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    D_IMPORT        reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    C_PRAGMA        reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    LBRACE          reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    S_IF            reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    S_SWITCH        reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    E_WAIT          reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    S_FOREACH       reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    S_FOR           reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    S_WHILE         reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    S_ITERATE       reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    S_ELSE          reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    ID              reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    C_APP           reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    LPAREN          reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    class_INT       reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    class_DOUBLE    reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    class_FLOAT     reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    class_VOID      reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    class_UINT      reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    class_BOOL      reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    class_CHARACTER reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    class_String    reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    collection_SET  reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    collection_ARRAY reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    collection_DICT reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    ARROW           reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    RBRACE          reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    S_CASE          reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    S_DEFAULT       reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    COLON           reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    E_STDIN         reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    E_STDOUT        reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)
    E_STDERR        reduce using rule 174 (base-expr -> LPAREN expr RPAREN .)


state 296

    (184) -constructor -> LPAREN expr COMMA . expr comma-expr-star RPAREN
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 333
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 297

    (196) array-kv-constructor -> LBRACE opt-array-constructor RBRACE .

    LBRACKET        reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    DOT             reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    MULT            reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    DIV             reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    MULTPER         reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    DOUBLEPER       reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    MOD             reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    PLUS            reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    MINUS           reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    LESS            reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    LESS_EQ         reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    EQUAL           reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    GREATER         reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    GREATER_EQ      reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    NOT_EQUAL       reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    LOG_AND         reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    LOG_OR          reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    RBRACKET        reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    SEMICOLON       reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    COMMA           reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    RPAREN          reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    C_GLOBAL        reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    D_IMPORT        reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    C_PRAGMA        reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    LBRACE          reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    S_IF            reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    S_SWITCH        reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    E_WAIT          reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    S_FOREACH       reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    S_FOR           reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    S_WHILE         reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    S_ITERATE       reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    S_ELSE          reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    ID              reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    C_APP           reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    LPAREN          reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    class_INT       reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    class_DOUBLE    reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    class_FLOAT     reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    class_VOID      reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    class_UINT      reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    class_BOOL      reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    class_CHARACTER reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    class_String    reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    collection_SET  reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    collection_ARRAY reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    collection_DICT reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    $end            reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    ARROW           reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    RBRACE          reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    S_CASE          reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    S_DEFAULT       reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    COLON           reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    E_STDIN         reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    E_STDOUT        reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    E_STDERR        reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    AT              reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    STR_LITERAL     reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    MUL_STR_LITERAL reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    INT             reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    DOUBLE          reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    INF             reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    NAN             reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    E_TRUE          reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    E_FALSE         reduce using rule 196 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)


state 298

    (197) opt-array-constructor -> array-kv-elem comma-array-kv-elem-star .

    RBRACE          reduce using rule 197 (opt-array-constructor -> array-kv-elem comma-array-kv-elem-star .)


state 299

    (199) comma-array-kv-elem-star -> COMMA . array-kv-elem comma-array-kv-elem-star
    (201) array-kv-elem -> . expr COLON expr
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    array-kv-elem                  shift and go to state 334
    expr                           shift and go to state 233
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 300

    (200) comma-array-kv-elem-star -> empty .

    RBRACE          reduce using rule 200 (comma-array-kv-elem-star -> empty .)


state 301

    (201) array-kv-elem -> expr COLON . expr
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 335
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 302

    (28) path-star -> DOT ID path-star .

    SEMICOLON       reduce using rule 28 (path-star -> DOT ID path-star .)


state 303

    (202) kw-expr -> ID ASSIGN expr .

    COMMA           reduce using rule 202 (kw-expr -> ID ASSIGN expr .)
    RPAREN          reduce using rule 202 (kw-expr -> ID ASSIGN expr .)


state 304

    (179) func-call-arg-star -> COMMA expr-or-kw . func-call-arg-star
    (179) func-call-arg-star -> . COMMA expr-or-kw func-call-arg-star
    (180) func-call-arg-star -> . empty
    (76) empty -> .

    COMMA           shift and go to state 240
    RPAREN          reduce using rule 76 (empty -> .)

    func-call-arg-star             shift and go to state 336
    empty                          shift and go to state 241

state 305

    (106) if-stmt -> S_IF LPAREN expr RPAREN block . opt-else-block
    (107) opt-else-block -> . S_ELSE block
    (108) opt-else-block -> . empty
    (76) empty -> .

  ! shift/reduce conflict for S_ELSE resolved as shift
    S_ELSE          shift and go to state 43
    SEMICOLON       reduce using rule 76 (empty -> .)
    C_GLOBAL        reduce using rule 76 (empty -> .)
    D_IMPORT        reduce using rule 76 (empty -> .)
    C_PRAGMA        reduce using rule 76 (empty -> .)
    LBRACE          reduce using rule 76 (empty -> .)
    S_IF            reduce using rule 76 (empty -> .)
    S_SWITCH        reduce using rule 76 (empty -> .)
    E_WAIT          reduce using rule 76 (empty -> .)
    S_FOREACH       reduce using rule 76 (empty -> .)
    S_FOR           reduce using rule 76 (empty -> .)
    S_WHILE         reduce using rule 76 (empty -> .)
    S_ITERATE       reduce using rule 76 (empty -> .)
    ID              reduce using rule 76 (empty -> .)
    C_APP           reduce using rule 76 (empty -> .)
    LPAREN          reduce using rule 76 (empty -> .)
    class_INT       reduce using rule 76 (empty -> .)
    class_DOUBLE    reduce using rule 76 (empty -> .)
    class_FLOAT     reduce using rule 76 (empty -> .)
    class_VOID      reduce using rule 76 (empty -> .)
    class_UINT      reduce using rule 76 (empty -> .)
    class_BOOL      reduce using rule 76 (empty -> .)
    class_CHARACTER reduce using rule 76 (empty -> .)
    class_String    reduce using rule 76 (empty -> .)
    collection_SET  reduce using rule 76 (empty -> .)
    collection_ARRAY reduce using rule 76 (empty -> .)
    collection_DICT reduce using rule 76 (empty -> .)
    LESS            reduce using rule 76 (empty -> .)
    $end            reduce using rule 76 (empty -> .)
    RBRACE          reduce using rule 76 (empty -> .)
    S_CASE          reduce using rule 76 (empty -> .)
    S_DEFAULT       reduce using rule 76 (empty -> .)

  ! S_ELSE          [ reduce using rule 76 (empty -> .) ]

    opt-else-block                 shift and go to state 337
    empty                          shift and go to state 338

state 306

    (109) switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE . case-star opt-default RBRACE
    (112) case-star -> . case case-star
    (113) case-star -> .
    (114) case -> . S_CASE INT COLON translation-unit

    S_DEFAULT       reduce using rule 113 (case-star -> .)
    RBRACE          reduce using rule 113 (case-star -> .)
    S_CASE          shift and go to state 341

    case-star                      shift and go to state 339
    case                           shift and go to state 340

state 307

    (116) wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN . block
    (90) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 342

state 308

    (119) foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr . block
    (90) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 343

state 309

    (122) for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr . SEMICOLON for-update-list RPAREN block

    SEMICOLON       shift and go to state 344


state 310

    (125) for-init-star -> COMMA for-init . for-init-star
    (125) for-init-star -> . COMMA for-init for-init-star
    (126) for-init-star -> .

    COMMA           shift and go to state 249
    SEMICOLON       reduce using rule 126 (for-init-star -> .)

    for-init-star                  shift and go to state 345

state 311

    (128) for-init -> type-prefix var-name type-suffix . ASSIGN expr

    ASSIGN          shift and go to state 346


state 312

    (132) for-assignment -> var-name ASSIGN expr .

    COMMA           reduce using rule 132 (for-assignment -> var-name ASSIGN expr .)
    SEMICOLON       reduce using rule 132 (for-assignment -> var-name ASSIGN expr .)
    RPAREN          reduce using rule 132 (for-assignment -> var-name ASSIGN expr .)


state 313

    (75) var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .

    SEMICOLON       reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    C_GLOBAL        reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    D_IMPORT        reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    C_PRAGMA        reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    LBRACE          reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    S_IF            reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    S_SWITCH        reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    E_WAIT          reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    S_FOREACH       reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    S_FOR           reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    S_WHILE         reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    S_ITERATE       reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    S_ELSE          reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    ID              reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    C_APP           reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    LPAREN          reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    class_INT       reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    class_DOUBLE    reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    class_FLOAT     reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    class_VOID      reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    class_UINT      reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    class_BOOL      reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    class_CHARACTER reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    class_String    reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    collection_SET  reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    collection_ARRAY reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    collection_DICT reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    LESS            reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    $end            reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    ARROW           reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    RBRACE          reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    S_CASE          reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)
    S_DEFAULT       reduce using rule 75 (var-decl-rest -> var-name type-suffix empty-or-var-mapping empty-or-assign-expr .)


state 314

    (79) empty-or-assign-expr -> ASSIGN . expr
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 347
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 315

    (80) empty-or-assign-expr -> empty .

    SEMICOLON       reduce using rule 80 (empty-or-assign-expr -> empty .)
    C_GLOBAL        reduce using rule 80 (empty-or-assign-expr -> empty .)
    D_IMPORT        reduce using rule 80 (empty-or-assign-expr -> empty .)
    C_PRAGMA        reduce using rule 80 (empty-or-assign-expr -> empty .)
    LBRACE          reduce using rule 80 (empty-or-assign-expr -> empty .)
    S_IF            reduce using rule 80 (empty-or-assign-expr -> empty .)
    S_SWITCH        reduce using rule 80 (empty-or-assign-expr -> empty .)
    E_WAIT          reduce using rule 80 (empty-or-assign-expr -> empty .)
    S_FOREACH       reduce using rule 80 (empty-or-assign-expr -> empty .)
    S_FOR           reduce using rule 80 (empty-or-assign-expr -> empty .)
    S_WHILE         reduce using rule 80 (empty-or-assign-expr -> empty .)
    S_ITERATE       reduce using rule 80 (empty-or-assign-expr -> empty .)
    S_ELSE          reduce using rule 80 (empty-or-assign-expr -> empty .)
    ID              reduce using rule 80 (empty-or-assign-expr -> empty .)
    C_APP           reduce using rule 80 (empty-or-assign-expr -> empty .)
    LPAREN          reduce using rule 80 (empty-or-assign-expr -> empty .)
    class_INT       reduce using rule 80 (empty-or-assign-expr -> empty .)
    class_DOUBLE    reduce using rule 80 (empty-or-assign-expr -> empty .)
    class_FLOAT     reduce using rule 80 (empty-or-assign-expr -> empty .)
    class_VOID      reduce using rule 80 (empty-or-assign-expr -> empty .)
    class_UINT      reduce using rule 80 (empty-or-assign-expr -> empty .)
    class_BOOL      reduce using rule 80 (empty-or-assign-expr -> empty .)
    class_CHARACTER reduce using rule 80 (empty-or-assign-expr -> empty .)
    class_String    reduce using rule 80 (empty-or-assign-expr -> empty .)
    collection_SET  reduce using rule 80 (empty-or-assign-expr -> empty .)
    collection_ARRAY reduce using rule 80 (empty-or-assign-expr -> empty .)
    collection_DICT reduce using rule 80 (empty-or-assign-expr -> empty .)
    LESS            reduce using rule 80 (empty-or-assign-expr -> empty .)
    $end            reduce using rule 80 (empty-or-assign-expr -> empty .)
    ARROW           reduce using rule 80 (empty-or-assign-expr -> empty .)
    RBRACE          reduce using rule 80 (empty-or-assign-expr -> empty .)
    S_CASE          reduce using rule 80 (empty-or-assign-expr -> empty .)
    S_DEFAULT       reduce using rule 80 (empty-or-assign-expr -> empty .)


state 316

    (89) var-mapping -> LESS expr . GREATER

    GREATER         shift and go to state 348


state 317

    (84) type-suffix -> LBRACKET empty-or-standalone-type RBRACKET . type-suffix
    (84) type-suffix -> . LBRACKET empty-or-standalone-type RBRACKET type-suffix
    (85) type-suffix -> .

    LBRACKET        shift and go to state 179
    LESS            reduce using rule 85 (type-suffix -> .)
    ASSIGN          reduce using rule 85 (type-suffix -> .)
    SEMICOLON       reduce using rule 85 (type-suffix -> .)
    C_GLOBAL        reduce using rule 85 (type-suffix -> .)
    D_IMPORT        reduce using rule 85 (type-suffix -> .)
    C_PRAGMA        reduce using rule 85 (type-suffix -> .)
    LBRACE          reduce using rule 85 (type-suffix -> .)
    S_IF            reduce using rule 85 (type-suffix -> .)
    S_SWITCH        reduce using rule 85 (type-suffix -> .)
    E_WAIT          reduce using rule 85 (type-suffix -> .)
    S_FOREACH       reduce using rule 85 (type-suffix -> .)
    S_FOR           reduce using rule 85 (type-suffix -> .)
    S_WHILE         reduce using rule 85 (type-suffix -> .)
    S_ITERATE       reduce using rule 85 (type-suffix -> .)
    S_ELSE          reduce using rule 85 (type-suffix -> .)
    ID              reduce using rule 85 (type-suffix -> .)
    C_APP           reduce using rule 85 (type-suffix -> .)
    LPAREN          reduce using rule 85 (type-suffix -> .)
    class_INT       reduce using rule 85 (type-suffix -> .)
    class_DOUBLE    reduce using rule 85 (type-suffix -> .)
    class_FLOAT     reduce using rule 85 (type-suffix -> .)
    class_VOID      reduce using rule 85 (type-suffix -> .)
    class_UINT      reduce using rule 85 (type-suffix -> .)
    class_BOOL      reduce using rule 85 (type-suffix -> .)
    class_CHARACTER reduce using rule 85 (type-suffix -> .)
    class_String    reduce using rule 85 (type-suffix -> .)
    collection_SET  reduce using rule 85 (type-suffix -> .)
    collection_ARRAY reduce using rule 85 (type-suffix -> .)
    collection_DICT reduce using rule 85 (type-suffix -> .)
    $end            reduce using rule 85 (type-suffix -> .)
    ARROW           reduce using rule 85 (type-suffix -> .)
    RBRACE          reduce using rule 85 (type-suffix -> .)
    S_CASE          reduce using rule 85 (type-suffix -> .)
    S_DEFAULT       reduce using rule 85 (type-suffix -> .)
    GREATER         reduce using rule 85 (type-suffix -> .)
    RBRACKET        reduce using rule 85 (type-suffix -> .)
    COMMA           reduce using rule 85 (type-suffix -> .)
    RPAREN          reduce using rule 85 (type-suffix -> .)

    type-suffix                    shift and go to state 349

state 318

    (123) while-loop -> S_WHILE LPAREN expr RPAREN block .

    SEMICOLON       reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    C_GLOBAL        reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    D_IMPORT        reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    C_PRAGMA        reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    LBRACE          reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    S_IF            reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    S_SWITCH        reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    E_WAIT          reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    S_FOREACH       reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    S_FOR           reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    S_WHILE         reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    S_ITERATE       reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    S_ELSE          reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    ID              reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    C_APP           reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    LPAREN          reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    class_INT       reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    class_DOUBLE    reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    class_FLOAT     reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    class_VOID      reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    class_UINT      reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    class_BOOL      reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    class_CHARACTER reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    class_String    reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    collection_SET  reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    collection_ARRAY reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    collection_DICT reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    LESS            reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    $end            reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    RBRACE          reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    S_CASE          reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)
    S_DEFAULT       reduce using rule 123 (while-loop -> S_WHILE LPAREN expr RPAREN block .)


state 319

    (133) iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN . expr RPAREN
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    var-name                       shift and go to state 131
    expr                           shift and go to state 350
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 320

    (39) comma-name-star -> COMMA var-name comma-name-star .

    GREATER         reduce using rule 39 (comma-name-star -> COMMA var-name comma-name-star .)


state 321

    (65) foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .

    SEMICOLON       reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    C_GLOBAL        reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    D_IMPORT        reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    C_PRAGMA        reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    LBRACE          reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_IF            reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_SWITCH        reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    E_WAIT          reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_FOREACH       reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_FOR           reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_WHILE         reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_ITERATE       reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_ELSE          reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    ID              reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    C_APP           reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    LPAREN          reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_INT       reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_DOUBLE    reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_FLOAT     reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_VOID      reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_UINT      reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_BOOL      reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_CHARACTER reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_String    reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    collection_SET  reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    collection_ARRAY reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    collection_DICT reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    LESS            reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    $end            reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    RBRACE          reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_CASE          reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_DEFAULT       reduce using rule 65 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)


state 322

    (68) empty-or-more-literals -> LBRACKET . single-or-multiple-literal RBRACKET
    (70) single-or-multiple-literal -> . STR_LITERAL
    (71) single-or-multiple-literal -> . MUL_STR_LITERAL

    STR_LITERAL     shift and go to state 352
    MUL_STR_LITERAL shift and go to state 353

    single-or-multiple-literal     shift and go to state 351

state 323

    (69) empty-or-more-literals -> empty .

    SEMICOLON       reduce using rule 69 (empty-or-more-literals -> empty .)
    C_GLOBAL        reduce using rule 69 (empty-or-more-literals -> empty .)
    D_IMPORT        reduce using rule 69 (empty-or-more-literals -> empty .)
    C_PRAGMA        reduce using rule 69 (empty-or-more-literals -> empty .)
    LBRACE          reduce using rule 69 (empty-or-more-literals -> empty .)
    S_IF            reduce using rule 69 (empty-or-more-literals -> empty .)
    S_SWITCH        reduce using rule 69 (empty-or-more-literals -> empty .)
    E_WAIT          reduce using rule 69 (empty-or-more-literals -> empty .)
    S_FOREACH       reduce using rule 69 (empty-or-more-literals -> empty .)
    S_FOR           reduce using rule 69 (empty-or-more-literals -> empty .)
    S_WHILE         reduce using rule 69 (empty-or-more-literals -> empty .)
    S_ITERATE       reduce using rule 69 (empty-or-more-literals -> empty .)
    S_ELSE          reduce using rule 69 (empty-or-more-literals -> empty .)
    ID              reduce using rule 69 (empty-or-more-literals -> empty .)
    C_APP           reduce using rule 69 (empty-or-more-literals -> empty .)
    LPAREN          reduce using rule 69 (empty-or-more-literals -> empty .)
    class_INT       reduce using rule 69 (empty-or-more-literals -> empty .)
    class_DOUBLE    reduce using rule 69 (empty-or-more-literals -> empty .)
    class_FLOAT     reduce using rule 69 (empty-or-more-literals -> empty .)
    class_VOID      reduce using rule 69 (empty-or-more-literals -> empty .)
    class_UINT      reduce using rule 69 (empty-or-more-literals -> empty .)
    class_BOOL      reduce using rule 69 (empty-or-more-literals -> empty .)
    class_CHARACTER reduce using rule 69 (empty-or-more-literals -> empty .)
    class_String    reduce using rule 69 (empty-or-more-literals -> empty .)
    collection_SET  reduce using rule 69 (empty-or-more-literals -> empty .)
    collection_ARRAY reduce using rule 69 (empty-or-more-literals -> empty .)
    collection_DICT reduce using rule 69 (empty-or-more-literals -> empty .)
    LESS            reduce using rule 69 (empty-or-more-literals -> empty .)
    $end            reduce using rule 69 (empty-or-more-literals -> empty .)
    RBRACE          reduce using rule 69 (empty-or-more-literals -> empty .)
    S_CASE          reduce using rule 69 (empty-or-more-literals -> empty .)
    S_DEFAULT       reduce using rule 69 (empty-or-more-literals -> empty .)


state 324

    (53) app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .

    SEMICOLON       reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    C_GLOBAL        reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    D_IMPORT        reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    C_PRAGMA        reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    LBRACE          reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    S_IF            reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    S_SWITCH        reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    E_WAIT          reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    S_FOREACH       reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    S_FOR           reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    S_WHILE         reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    S_ITERATE       reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    S_ELSE          reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    ID              reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    C_APP           reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    LPAREN          reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    class_INT       reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    class_DOUBLE    reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    class_FLOAT     reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    class_VOID      reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    class_UINT      reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    class_BOOL      reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    class_CHARACTER reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    class_String    reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    collection_SET  reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    collection_ARRAY reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    collection_DICT reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    LESS            reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    $end            reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    RBRACE          reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    S_CASE          reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)
    S_DEFAULT       reduce using rule 53 (app-func-defn -> C_APP func-hdr LBRACE app-body RBRACE .)


state 325

    (62) app-arg-expr-star -> app-arg-expr . app-arg-expr-star
    (62) app-arg-expr-star -> . app-arg-expr app-arg-expr-star
    (63) app-arg-expr-star -> .
    (235) app-arg-expr -> . opt-at var-name
    (236) app-arg-expr -> . literal
    (237) app-arg-expr -> . array-constructor
    (238) app-arg-expr -> . LPAREN expr RPAREN
    (239) opt-at -> . AT
    (240) opt-at -> . empty
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (76) empty -> .
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    E_STDIN         reduce using rule 63 (app-arg-expr-star -> .)
    E_STDOUT        reduce using rule 63 (app-arg-expr-star -> .)
    E_STDERR        reduce using rule 63 (app-arg-expr-star -> .)
    SEMICOLON       reduce using rule 63 (app-arg-expr-star -> .)
    RBRACE          reduce using rule 63 (app-arg-expr-star -> .)
    LPAREN          shift and go to state 270
    AT              shift and go to state 271
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              reduce using rule 76 (empty -> .)
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    app-arg-expr                   shift and go to state 325
    app-arg-expr-star              shift and go to state 354
    opt-at                         shift and go to state 267
    literal                        shift and go to state 268
    array-constructor              shift and go to state 269
    empty                          shift and go to state 272
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 326

    (54) app-body -> app-arg-expr app-arg-expr-star . app-out-star empty-or-semicolon
    (57) app-out-star -> . std-in-out-err ASSIGN expr app-out-star
    (58) app-out-star -> .
    (59) std-in-out-err -> . E_STDIN
    (60) std-in-out-err -> . E_STDOUT
    (61) std-in-out-err -> . E_STDERR

    SEMICOLON       reduce using rule 58 (app-out-star -> .)
    RBRACE          reduce using rule 58 (app-out-star -> .)
    E_STDIN         shift and go to state 357
    E_STDOUT        shift and go to state 358
    E_STDERR        shift and go to state 359

    app-out-star                   shift and go to state 355
    std-in-out-err                 shift and go to state 356

state 327

    (235) app-arg-expr -> opt-at var-name .

    LPAREN          reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    AT              reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    STR_LITERAL     reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    MUL_STR_LITERAL reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    INT             reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    DOUBLE          reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    INF             reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    NAN             reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    E_TRUE          reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    E_FALSE         reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    LBRACKET        reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    LBRACE          reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    E_STDIN         reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    E_STDOUT        reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    E_STDERR        reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    SEMICOLON       reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    ID              reduce using rule 235 (app-arg-expr -> opt-at var-name .)
    RBRACE          reduce using rule 235 (app-arg-expr -> opt-at var-name .)


state 328

    (238) app-arg-expr -> LPAREN expr . RPAREN

    RPAREN          shift and go to state 360


state 329

    (45) comma-args-star -> COMMA formal-arg . comma-args-star
    (45) comma-args-star -> . COMMA formal-arg comma-args-star
    (46) comma-args-star -> . empty
    (76) empty -> .

    COMMA           shift and go to state 280
    RPAREN          reduce using rule 76 (empty -> .)

    comma-args-star                shift and go to state 361
    empty                          shift and go to state 281

state 330

    (47) formal-arg -> type-prefix empty-or-range var-name . type-suffix empty-or-ass-expr
    (84) type-suffix -> . LBRACKET empty-or-standalone-type RBRACKET type-suffix
    (85) type-suffix -> .

    LBRACKET        shift and go to state 179
    LPAREN          reduce using rule 85 (type-suffix -> .)
    ASSIGN          reduce using rule 85 (type-suffix -> .)
    COMMA           reduce using rule 85 (type-suffix -> .)
    RPAREN          reduce using rule 85 (type-suffix -> .)

    type-suffix                    shift and go to state 362

state 331

    (105) update-stmt -> var-name LESS ID GREATER UPD expr . SEMICOLON

    SEMICOLON       shift and go to state 363


state 332

    (193) array-range-constructor -> LBRACKET expr COLON expr . opt-coloned-expr RBRACKET
    (194) opt-coloned-expr -> . COLON expr
    (195) opt-coloned-expr -> . empty
    (76) empty -> .

    COLON           shift and go to state 364
    RBRACKET        reduce using rule 76 (empty -> .)

    opt-coloned-expr               shift and go to state 365
    empty                          shift and go to state 366

state 333

    (184) -constructor -> LPAREN expr COMMA expr . comma-expr-star RPAREN
    (185) comma-expr-star -> . COMMA expr comma-expr-star
    (186) comma-expr-star -> . empty
    (76) empty -> .

    COMMA           shift and go to state 367
    RPAREN          reduce using rule 76 (empty -> .)

    comma-expr-star                shift and go to state 368
    empty                          shift and go to state 369

state 334

    (199) comma-array-kv-elem-star -> COMMA array-kv-elem . comma-array-kv-elem-star
    (199) comma-array-kv-elem-star -> . COMMA array-kv-elem comma-array-kv-elem-star
    (200) comma-array-kv-elem-star -> . empty
    (76) empty -> .

    COMMA           shift and go to state 299
    RBRACE          reduce using rule 76 (empty -> .)

    comma-array-kv-elem-star       shift and go to state 370
    empty                          shift and go to state 300

state 335

    (201) array-kv-elem -> expr COLON expr .

    COMMA           reduce using rule 201 (array-kv-elem -> expr COLON expr .)
    RBRACE          reduce using rule 201 (array-kv-elem -> expr COLON expr .)


state 336

    (179) func-call-arg-star -> COMMA expr-or-kw func-call-arg-star .

    RPAREN          reduce using rule 179 (func-call-arg-star -> COMMA expr-or-kw func-call-arg-star .)


state 337

    (106) if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .

    SEMICOLON       reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    C_GLOBAL        reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    D_IMPORT        reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    C_PRAGMA        reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    LBRACE          reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_IF            reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_SWITCH        reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    E_WAIT          reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_FOREACH       reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_FOR           reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_WHILE         reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_ITERATE       reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_ELSE          reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    ID              reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    C_APP           reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    LPAREN          reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_INT       reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_DOUBLE    reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_FLOAT     reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_VOID      reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_UINT      reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_BOOL      reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_CHARACTER reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_String    reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    collection_SET  reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    collection_ARRAY reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    collection_DICT reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    LESS            reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    $end            reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    RBRACE          reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_CASE          reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_DEFAULT       reduce using rule 106 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)


state 338

    (108) opt-else-block -> empty .

    SEMICOLON       reduce using rule 108 (opt-else-block -> empty .)
    C_GLOBAL        reduce using rule 108 (opt-else-block -> empty .)
    D_IMPORT        reduce using rule 108 (opt-else-block -> empty .)
    C_PRAGMA        reduce using rule 108 (opt-else-block -> empty .)
    LBRACE          reduce using rule 108 (opt-else-block -> empty .)
    S_IF            reduce using rule 108 (opt-else-block -> empty .)
    S_SWITCH        reduce using rule 108 (opt-else-block -> empty .)
    E_WAIT          reduce using rule 108 (opt-else-block -> empty .)
    S_FOREACH       reduce using rule 108 (opt-else-block -> empty .)
    S_FOR           reduce using rule 108 (opt-else-block -> empty .)
    S_WHILE         reduce using rule 108 (opt-else-block -> empty .)
    S_ITERATE       reduce using rule 108 (opt-else-block -> empty .)
    S_ELSE          reduce using rule 108 (opt-else-block -> empty .)
    ID              reduce using rule 108 (opt-else-block -> empty .)
    C_APP           reduce using rule 108 (opt-else-block -> empty .)
    LPAREN          reduce using rule 108 (opt-else-block -> empty .)
    class_INT       reduce using rule 108 (opt-else-block -> empty .)
    class_DOUBLE    reduce using rule 108 (opt-else-block -> empty .)
    class_FLOAT     reduce using rule 108 (opt-else-block -> empty .)
    class_VOID      reduce using rule 108 (opt-else-block -> empty .)
    class_UINT      reduce using rule 108 (opt-else-block -> empty .)
    class_BOOL      reduce using rule 108 (opt-else-block -> empty .)
    class_CHARACTER reduce using rule 108 (opt-else-block -> empty .)
    class_String    reduce using rule 108 (opt-else-block -> empty .)
    collection_SET  reduce using rule 108 (opt-else-block -> empty .)
    collection_ARRAY reduce using rule 108 (opt-else-block -> empty .)
    collection_DICT reduce using rule 108 (opt-else-block -> empty .)
    LESS            reduce using rule 108 (opt-else-block -> empty .)
    $end            reduce using rule 108 (opt-else-block -> empty .)
    RBRACE          reduce using rule 108 (opt-else-block -> empty .)
    S_CASE          reduce using rule 108 (opt-else-block -> empty .)
    S_DEFAULT       reduce using rule 108 (opt-else-block -> empty .)


state 339

    (109) switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star . opt-default RBRACE
    (110) opt-default -> . S_DEFAULT
    (111) opt-default -> . empty
    (76) empty -> .

    S_DEFAULT       shift and go to state 372
    RBRACE          reduce using rule 76 (empty -> .)

    opt-default                    shift and go to state 371
    empty                          shift and go to state 373

state 340

    (112) case-star -> case . case-star
    (112) case-star -> . case case-star
    (113) case-star -> .
    (114) case -> . S_CASE INT COLON translation-unit

    S_DEFAULT       reduce using rule 113 (case-star -> .)
    RBRACE          reduce using rule 113 (case-star -> .)
    S_CASE          shift and go to state 341

    case                           shift and go to state 340
    case-star                      shift and go to state 374

state 341

    (114) case -> S_CASE . INT COLON translation-unit

    INT             shift and go to state 375


state 342

    (116) wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .

    SEMICOLON       reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    C_GLOBAL        reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    D_IMPORT        reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    C_PRAGMA        reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    LBRACE          reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_IF            reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_SWITCH        reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    E_WAIT          reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_FOREACH       reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_FOR           reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_WHILE         reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_ITERATE       reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_ELSE          reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    ID              reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    C_APP           reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    LPAREN          reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_INT       reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_DOUBLE    reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_FLOAT     reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_VOID      reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_UINT      reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_BOOL      reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_CHARACTER reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_String    reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    collection_SET  reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    collection_ARRAY reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    collection_DICT reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    LESS            reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    $end            reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    RBRACE          reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_CASE          reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_DEFAULT       reduce using rule 116 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)


state 343

    (119) foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .

    SEMICOLON       reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    C_GLOBAL        reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    D_IMPORT        reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    C_PRAGMA        reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    LBRACE          reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_IF            reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_SWITCH        reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    E_WAIT          reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_FOREACH       reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_FOR           reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_WHILE         reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_ITERATE       reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_ELSE          reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    ID              reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    C_APP           reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    LPAREN          reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_INT       reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_DOUBLE    reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_FLOAT     reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_VOID      reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_UINT      reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_BOOL      reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_CHARACTER reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_String    reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    collection_SET  reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    collection_ARRAY reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    collection_DICT reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    LESS            reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    $end            reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    RBRACE          reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_CASE          reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_DEFAULT       reduce using rule 119 (foreach-loop -> S_FOREACH var-name opt-comma-var-name S_IN expr block .)


state 344

    (122) for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON . for-update-list RPAREN block
    (129) for-update-list -> . for-assignment for-assignment-star
    (132) for-assignment -> . var-name ASSIGN expr
    (227) var-name -> . ID

    ID              shift and go to state 82

    for-update-list                shift and go to state 376
    for-assignment                 shift and go to state 377
    var-name                       shift and go to state 176

state 345

    (125) for-init-star -> COMMA for-init for-init-star .

    SEMICOLON       reduce using rule 125 (for-init-star -> COMMA for-init for-init-star .)


state 346

    (128) for-init -> type-prefix var-name type-suffix ASSIGN . expr
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    var-name                       shift and go to state 131
    expr                           shift and go to state 378
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 347

    (79) empty-or-assign-expr -> ASSIGN expr .

    SEMICOLON       reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    C_GLOBAL        reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    D_IMPORT        reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    C_PRAGMA        reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    LBRACE          reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    S_IF            reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    S_SWITCH        reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    E_WAIT          reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    S_FOREACH       reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    S_FOR           reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    S_WHILE         reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    S_ITERATE       reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    S_ELSE          reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    ID              reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    C_APP           reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    LPAREN          reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    class_INT       reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    class_DOUBLE    reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    class_FLOAT     reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    class_VOID      reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    class_UINT      reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    class_BOOL      reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    class_CHARACTER reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    class_String    reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    collection_SET  reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    collection_ARRAY reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    collection_DICT reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    LESS            reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    $end            reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    ARROW           reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    RBRACE          reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    S_CASE          reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)
    S_DEFAULT       reduce using rule 79 (empty-or-assign-expr -> ASSIGN expr .)


state 348

    (89) var-mapping -> LESS expr GREATER .

    ASSIGN          reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    SEMICOLON       reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    C_GLOBAL        reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    D_IMPORT        reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    C_PRAGMA        reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    LBRACE          reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    S_IF            reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    S_SWITCH        reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    E_WAIT          reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    S_FOREACH       reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    S_FOR           reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    S_WHILE         reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    S_ITERATE       reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    S_ELSE          reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    ID              reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    C_APP           reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    LPAREN          reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    class_INT       reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    class_DOUBLE    reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    class_FLOAT     reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    class_VOID      reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    class_UINT      reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    class_BOOL      reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    class_CHARACTER reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    class_String    reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    collection_SET  reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    collection_ARRAY reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    collection_DICT reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    LESS            reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    $end            reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    ARROW           reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    RBRACE          reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    S_CASE          reduce using rule 89 (var-mapping -> LESS expr GREATER .)
    S_DEFAULT       reduce using rule 89 (var-mapping -> LESS expr GREATER .)


state 349

    (84) type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .

    LESS            reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    ASSIGN          reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    SEMICOLON       reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    C_GLOBAL        reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    D_IMPORT        reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    C_PRAGMA        reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    LBRACE          reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    S_IF            reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    S_SWITCH        reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    E_WAIT          reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    S_FOREACH       reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    S_FOR           reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    S_WHILE         reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    S_ITERATE       reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    S_ELSE          reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    ID              reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    C_APP           reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    LPAREN          reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    class_INT       reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    class_DOUBLE    reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    class_FLOAT     reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    class_VOID      reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    class_UINT      reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    class_BOOL      reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    class_CHARACTER reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    class_String    reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    collection_SET  reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    collection_ARRAY reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    collection_DICT reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    $end            reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    ARROW           reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    RBRACE          reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    S_CASE          reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    S_DEFAULT       reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    GREATER         reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    RBRACKET        reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    COMMA           reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    RPAREN          reduce using rule 84 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)


state 350

    (133) iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr . RPAREN

    RPAREN          shift and go to state 379


state 351

    (68) empty-or-more-literals -> LBRACKET single-or-multiple-literal . RBRACKET

    RBRACKET        shift and go to state 380


state 352

    (70) single-or-multiple-literal -> STR_LITERAL .

    RBRACKET        reduce using rule 70 (single-or-multiple-literal -> STR_LITERAL .)


state 353

    (71) single-or-multiple-literal -> MUL_STR_LITERAL .

    RBRACKET        reduce using rule 71 (single-or-multiple-literal -> MUL_STR_LITERAL .)


state 354

    (62) app-arg-expr-star -> app-arg-expr app-arg-expr-star .

    E_STDIN         reduce using rule 62 (app-arg-expr-star -> app-arg-expr app-arg-expr-star .)
    E_STDOUT        reduce using rule 62 (app-arg-expr-star -> app-arg-expr app-arg-expr-star .)
    E_STDERR        reduce using rule 62 (app-arg-expr-star -> app-arg-expr app-arg-expr-star .)
    SEMICOLON       reduce using rule 62 (app-arg-expr-star -> app-arg-expr app-arg-expr-star .)
    RBRACE          reduce using rule 62 (app-arg-expr-star -> app-arg-expr app-arg-expr-star .)


state 355

    (54) app-body -> app-arg-expr app-arg-expr-star app-out-star . empty-or-semicolon
    (55) empty-or-semicolon -> . SEMICOLON
    (56) empty-or-semicolon -> . empty
    (76) empty -> .

    SEMICOLON       shift and go to state 382
    RBRACE          reduce using rule 76 (empty -> .)

    empty-or-semicolon             shift and go to state 381
    empty                          shift and go to state 383

state 356

    (57) app-out-star -> std-in-out-err . ASSIGN expr app-out-star

    ASSIGN          shift and go to state 384


state 357

    (59) std-in-out-err -> E_STDIN .

    ASSIGN          reduce using rule 59 (std-in-out-err -> E_STDIN .)


state 358

    (60) std-in-out-err -> E_STDOUT .

    ASSIGN          reduce using rule 60 (std-in-out-err -> E_STDOUT .)


state 359

    (61) std-in-out-err -> E_STDERR .

    ASSIGN          reduce using rule 61 (std-in-out-err -> E_STDERR .)


state 360

    (238) app-arg-expr -> LPAREN expr RPAREN .

    LPAREN          reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    AT              reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    STR_LITERAL     reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    MUL_STR_LITERAL reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    INT             reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    DOUBLE          reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    INF             reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    NAN             reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    E_TRUE          reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    E_FALSE         reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    LBRACKET        reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    LBRACE          reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    E_STDIN         reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    E_STDOUT        reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    E_STDERR        reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    ID              reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)
    RBRACE          reduce using rule 238 (app-arg-expr -> LPAREN expr RPAREN .)


state 361

    (45) comma-args-star -> COMMA formal-arg comma-args-star .

    RPAREN          reduce using rule 45 (comma-args-star -> COMMA formal-arg comma-args-star .)


state 362

    (47) formal-arg -> type-prefix empty-or-range var-name type-suffix . empty-or-ass-expr
    (50) empty-or-ass-expr -> . formal-arg-list ASSIGN expr
    (51) empty-or-ass-expr -> . empty
    (41) formal-arg-list -> . LPAREN opt-formal-args RPAREN
    (42) formal-arg-list -> . empty
    (76) empty -> .

    LPAREN          shift and go to state 108
    COMMA           reduce using rule 76 (empty -> .)
    RPAREN          reduce using rule 76 (empty -> .)
    ASSIGN          reduce using rule 76 (empty -> .)

    empty-or-ass-expr              shift and go to state 385
    formal-arg-list                shift and go to state 386
    empty                          shift and go to state 387

state 363

    (105) update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .

    SEMICOLON       reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    C_GLOBAL        reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    D_IMPORT        reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    C_PRAGMA        reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    LBRACE          reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_IF            reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_SWITCH        reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    E_WAIT          reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_FOREACH       reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_FOR           reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_WHILE         reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_ITERATE       reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_ELSE          reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    ID              reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    C_APP           reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    LPAREN          reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_INT       reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_DOUBLE    reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_FLOAT     reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_VOID      reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_UINT      reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_BOOL      reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_CHARACTER reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_String    reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    collection_SET  reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    collection_ARRAY reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    collection_DICT reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    LESS            reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    $end            reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    RBRACE          reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_CASE          reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_DEFAULT       reduce using rule 105 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)


state 364

    (194) opt-coloned-expr -> COLON . expr
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 388
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 365

    (193) array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr . RBRACKET

    RBRACKET        shift and go to state 389


state 366

    (195) opt-coloned-expr -> empty .

    RBRACKET        reduce using rule 195 (opt-coloned-expr -> empty .)


state 367

    (185) comma-expr-star -> COMMA . expr comma-expr-star
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 390
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 368

    (184) -constructor -> LPAREN expr COMMA expr comma-expr-star . RPAREN

    RPAREN          shift and go to state 391


state 369

    (186) comma-expr-star -> empty .

    RPAREN          reduce using rule 186 (comma-expr-star -> empty .)


state 370

    (199) comma-array-kv-elem-star -> COMMA array-kv-elem comma-array-kv-elem-star .

    RBRACE          reduce using rule 199 (comma-array-kv-elem-star -> COMMA array-kv-elem comma-array-kv-elem-star .)


state 371

    (109) switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default . RBRACE

    RBRACE          shift and go to state 392


state 372

    (110) opt-default -> S_DEFAULT .

    RBRACE          reduce using rule 110 (opt-default -> S_DEFAULT .)


state 373

    (111) opt-default -> empty .

    RBRACE          reduce using rule 111 (opt-default -> empty .)


state 374

    (112) case-star -> case case-star .

    S_DEFAULT       reduce using rule 112 (case-star -> case case-star .)
    RBRACE          reduce using rule 112 (case-star -> case case-star .)


state 375

    (114) case -> S_CASE INT . COLON translation-unit

    COLON           shift and go to state 393


state 376

    (122) for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list . RPAREN block

    RPAREN          shift and go to state 394


state 377

    (129) for-update-list -> for-assignment . for-assignment-star
    (130) for-assignment-star -> . COMMA for-assignment for-assignment-star
    (131) for-assignment-star -> .

    COMMA           shift and go to state 396
    RPAREN          reduce using rule 131 (for-assignment-star -> .)

    for-assignment-star            shift and go to state 395

state 378

    (128) for-init -> type-prefix var-name type-suffix ASSIGN expr .

    COMMA           reduce using rule 128 (for-init -> type-prefix var-name type-suffix ASSIGN expr .)
    SEMICOLON       reduce using rule 128 (for-init -> type-prefix var-name type-suffix ASSIGN expr .)


state 379

    (133) iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    C_GLOBAL        reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    D_IMPORT        reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    C_PRAGMA        reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    LBRACE          reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_IF            reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_SWITCH        reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    E_WAIT          reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_FOREACH       reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_FOR           reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_WHILE         reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_ITERATE       reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_ELSE          reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    ID              reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    C_APP           reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    LPAREN          reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_INT       reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_DOUBLE    reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_FLOAT     reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_VOID      reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_UINT      reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_BOOL      reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_CHARACTER reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_String    reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    collection_SET  reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    collection_ARRAY reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    collection_DICT reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    LESS            reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    $end            reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    RBRACE          reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_CASE          reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_DEFAULT       reduce using rule 133 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)


state 380

    (68) empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .

    SEMICOLON       reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    C_GLOBAL        reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    D_IMPORT        reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    C_PRAGMA        reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    LBRACE          reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_IF            reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_SWITCH        reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    E_WAIT          reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_FOREACH       reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_FOR           reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_WHILE         reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_ITERATE       reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_ELSE          reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    ID              reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    C_APP           reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    LPAREN          reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_INT       reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_DOUBLE    reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_FLOAT     reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_VOID      reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_UINT      reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_BOOL      reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_CHARACTER reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_String    reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    collection_SET  reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    collection_ARRAY reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    collection_DICT reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    LESS            reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    $end            reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    RBRACE          reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_CASE          reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_DEFAULT       reduce using rule 68 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)


state 381

    (54) app-body -> app-arg-expr app-arg-expr-star app-out-star empty-or-semicolon .

    RBRACE          reduce using rule 54 (app-body -> app-arg-expr app-arg-expr-star app-out-star empty-or-semicolon .)


state 382

    (55) empty-or-semicolon -> SEMICOLON .

    RBRACE          reduce using rule 55 (empty-or-semicolon -> SEMICOLON .)


state 383

    (56) empty-or-semicolon -> empty .

    RBRACE          reduce using rule 56 (empty-or-semicolon -> empty .)


state 384

    (57) app-out-star -> std-in-out-err ASSIGN . expr app-out-star
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 397
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 385

    (47) formal-arg -> type-prefix empty-or-range var-name type-suffix empty-or-ass-expr .

    COMMA           reduce using rule 47 (formal-arg -> type-prefix empty-or-range var-name type-suffix empty-or-ass-expr .)
    RPAREN          reduce using rule 47 (formal-arg -> type-prefix empty-or-range var-name type-suffix empty-or-ass-expr .)


state 386

    (50) empty-or-ass-expr -> formal-arg-list . ASSIGN expr

    ASSIGN          shift and go to state 398


state 387

    (51) empty-or-ass-expr -> empty .
    (42) formal-arg-list -> empty .

    COMMA           reduce using rule 51 (empty-or-ass-expr -> empty .)
    RPAREN          reduce using rule 51 (empty-or-ass-expr -> empty .)
    ASSIGN          reduce using rule 42 (formal-arg-list -> empty .)


state 388

    (194) opt-coloned-expr -> COLON expr .

    RBRACKET        reduce using rule 194 (opt-coloned-expr -> COLON expr .)


state 389

    (193) array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .

    LBRACKET        reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    DOT             reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    MULT            reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    DIV             reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    MULTPER         reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    DOUBLEPER       reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    MOD             reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    PLUS            reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    MINUS           reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    LESS            reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    LESS_EQ         reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    EQUAL           reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    GREATER         reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    GREATER_EQ      reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    NOT_EQUAL       reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    LOG_AND         reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    LOG_OR          reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    RBRACKET        reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    SEMICOLON       reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    COMMA           reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    RPAREN          reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    C_GLOBAL        reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    D_IMPORT        reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    C_PRAGMA        reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    LBRACE          reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    S_IF            reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    S_SWITCH        reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    E_WAIT          reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    S_FOREACH       reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    S_FOR           reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    S_WHILE         reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    S_ITERATE       reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    S_ELSE          reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    ID              reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    C_APP           reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    LPAREN          reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    class_INT       reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    class_DOUBLE    reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    class_FLOAT     reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    class_VOID      reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    class_UINT      reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    class_BOOL      reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    class_CHARACTER reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    class_String    reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    collection_SET  reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    collection_ARRAY reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    collection_DICT reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    $end            reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    ARROW           reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    RBRACE          reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    S_CASE          reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    S_DEFAULT       reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    COLON           reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    E_STDIN         reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    E_STDOUT        reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    E_STDERR        reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    AT              reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    STR_LITERAL     reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    MUL_STR_LITERAL reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    INT             reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    DOUBLE          reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    INF             reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    NAN             reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    E_TRUE          reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    E_FALSE         reduce using rule 193 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)


state 390

    (185) comma-expr-star -> COMMA expr . comma-expr-star
    (185) comma-expr-star -> . COMMA expr comma-expr-star
    (186) comma-expr-star -> . empty
    (76) empty -> .

    COMMA           shift and go to state 367
    RPAREN          reduce using rule 76 (empty -> .)

    comma-expr-star                shift and go to state 399
    empty                          shift and go to state 369

state 391

    (184) -constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .

    LBRACKET        reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    DOT             reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    MULT            reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    DIV             reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    MULTPER         reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    DOUBLEPER       reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    MOD             reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    PLUS            reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    MINUS           reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    LESS            reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    LESS_EQ         reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    EQUAL           reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    GREATER         reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    GREATER_EQ      reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    NOT_EQUAL       reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    LOG_AND         reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    LOG_OR          reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    RBRACKET        reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    SEMICOLON       reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    COMMA           reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    RPAREN          reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    C_GLOBAL        reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    D_IMPORT        reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    C_PRAGMA        reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    LBRACE          reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    S_IF            reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    S_SWITCH        reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    E_WAIT          reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    S_FOREACH       reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    S_FOR           reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    S_WHILE         reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    S_ITERATE       reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    S_ELSE          reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    ID              reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    C_APP           reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    LPAREN          reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    class_INT       reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    class_DOUBLE    reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    class_FLOAT     reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    class_VOID      reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    class_UINT      reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    class_BOOL      reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    class_CHARACTER reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    class_String    reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    collection_SET  reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    collection_ARRAY reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    collection_DICT reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    $end            reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    ARROW           reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    RBRACE          reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    S_CASE          reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    S_DEFAULT       reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    COLON           reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    E_STDIN         reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    E_STDOUT        reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    E_STDERR        reduce using rule 184 (-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)


state 392

    (109) switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .

    SEMICOLON       reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    C_GLOBAL        reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    D_IMPORT        reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    C_PRAGMA        reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    LBRACE          reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_IF            reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_SWITCH        reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    E_WAIT          reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_FOREACH       reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_FOR           reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_WHILE         reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_ITERATE       reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_ELSE          reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    ID              reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    C_APP           reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    LPAREN          reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_INT       reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_DOUBLE    reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_FLOAT     reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_VOID      reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_UINT      reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_BOOL      reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_CHARACTER reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_String    reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    collection_SET  reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    collection_ARRAY reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    collection_DICT reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    LESS            reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    $end            reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    RBRACE          reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_CASE          reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_DEFAULT       reduce using rule 109 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)


state 393

    (114) case -> S_CASE INT COLON . translation-unit
    (1) translation-unit -> . statement-star
    (2) statement-star -> . statement statement-star
    (3) statement-star -> . empty
    (4) statement -> . SEMICOLON
    (5) statement -> . global-const-defn
    (6) statement -> . import-stmt
    (7) statement -> . pragma-stmt
    (8) statement -> . func-defn
    (9) statement -> . block
    (10) statement -> . if-stmt
    (11) statement -> . switch-stmt
    (12) statement -> . wait-stmt
    (13) statement -> . foreach-loop
    (14) statement -> . for-loop
    (15) statement -> . var-decl
    (16) statement -> . while-loop
    (17) statement -> . iterate-loop
    (18) statement -> . stmt-chain
    (19) statement -> . opt-else-block
    (20) statement -> . var-name
    (21) statement -> . assignment
    (22) statement -> . func-call
    (23) statement -> . update-stmt
    (76) empty -> .
    (24) global-const-defn -> . C_GLOBAL C_CONST var-decl SEMICOLON
    (25) import-stmt -> . D_IMPORT module-path SEMICOLON
    (26) import-stmt -> . D_IMPORT STR_LITERAL SEMICOLON
    (30) pragma-stmt -> . C_PRAGMA ID expr SEMICOLON
    (31) func-defn -> . swift-func-defn
    (32) func-defn -> . app-func-defn
    (33) func-defn -> . foreign-func-defn
    (90) block -> . LBRACE translation-unit RBRACE
    (106) if-stmt -> . S_IF LPAREN expr RPAREN block opt-else-block
    (109) switch-stmt -> . S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE
    (116) wait-stmt -> . E_WAIT opt-deep LPAREN expr-list RPAREN block
    (119) foreach-loop -> . S_FOREACH var-name opt-comma-var-name S_IN expr block
    (122) for-loop -> . S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
    (72) var-decl -> . type-prefix var-decl-rest
    (123) while-loop -> . S_WHILE LPAREN expr RPAREN block
    (133) iterate-loop -> . S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN
    (91) stmt-chain -> . chainable-stmt semicolon-or-arrow statement
    (107) opt-else-block -> . S_ELSE block
    (108) opt-else-block -> . empty
    (227) var-name -> . ID
    (98) assignment -> . lval-or-paren-lval assign-or-plusas expr-list
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (105) update-stmt -> . var-name LESS ID GREATER UPD expr SEMICOLON
    (52) swift-func-defn -> . func-hdr ARROW block
    (53) app-func-defn -> . C_APP func-hdr LBRACE app-body RBRACE
    (64) foreign-func-defn -> . func-hdr foreign-func-body
    (81) type-prefix -> . type-name
    (82) type-prefix -> . param-type
    (94) chainable-stmt -> . var-name
    (95) chainable-stmt -> . func-call
    (96) chainable-stmt -> . var-decl
    (97) chainable-stmt -> . assignment
    (103) lval-or-paren-lval -> . lval-list
    (104) lval-or-paren-lval -> . LPAREN lval-list RPAREN
    (34) func-hdr -> . type-params formal-arg-list ID empty-or-arg-list
    (214) type-name -> . class_INT
    (215) type-name -> . class_DOUBLE
    (216) type-name -> . class_FLOAT
    (217) type-name -> . class_VOID
    (218) type-name -> . class_UINT
    (219) type-name -> . class_BOOL
    (220) type-name -> . class_CHARACTER
    (221) type-name -> . class_String
    (222) type-name -> . collection_SET
    (223) type-name -> . collection_ARRAY
    (224) type-name -> . collection_DICT
    (225) type-name -> . ID
    (83) param-type -> . type-name LESS standalone-type GREATER
    (228) lval-list -> . lval-expr lval-expr-star
    (37) type-params -> . LESS var-name comma-name-star GREATER
    (38) type-params -> . empty
    (231) lval-expr -> . var-name subscript-star

  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for C_GLOBAL resolved as shift
  ! shift/reduce conflict for D_IMPORT resolved as shift
  ! shift/reduce conflict for C_PRAGMA resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for S_IF resolved as shift
  ! shift/reduce conflict for S_SWITCH resolved as shift
  ! shift/reduce conflict for E_WAIT resolved as shift
  ! shift/reduce conflict for S_FOREACH resolved as shift
  ! shift/reduce conflict for S_FOR resolved as shift
  ! shift/reduce conflict for S_WHILE resolved as shift
  ! shift/reduce conflict for S_ITERATE resolved as shift
  ! shift/reduce conflict for S_ELSE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for C_APP resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for class_INT resolved as shift
  ! shift/reduce conflict for class_DOUBLE resolved as shift
  ! shift/reduce conflict for class_FLOAT resolved as shift
  ! shift/reduce conflict for class_VOID resolved as shift
  ! shift/reduce conflict for class_UINT resolved as shift
  ! shift/reduce conflict for class_BOOL resolved as shift
  ! shift/reduce conflict for class_CHARACTER resolved as shift
  ! shift/reduce conflict for class_String resolved as shift
  ! shift/reduce conflict for collection_SET resolved as shift
  ! shift/reduce conflict for collection_ARRAY resolved as shift
  ! shift/reduce conflict for collection_DICT resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
    SEMICOLON       shift and go to state 5
    S_CASE          reduce using rule 76 (empty -> .)
    S_DEFAULT       reduce using rule 76 (empty -> .)
    RBRACE          reduce using rule 76 (empty -> .)
    C_GLOBAL        shift and go to state 25
    D_IMPORT        shift and go to state 26
    C_PRAGMA        shift and go to state 27
    LBRACE          shift and go to state 32
    S_IF            shift and go to state 33
    S_SWITCH        shift and go to state 35
    E_WAIT          shift and go to state 36
    S_FOREACH       shift and go to state 37
    S_FOR           shift and go to state 38
    S_WHILE         shift and go to state 40
    S_ITERATE       shift and go to state 41
    S_ELSE          shift and go to state 43
    ID              shift and go to state 28
    C_APP           shift and go to state 47
    LPAREN          shift and go to state 34
    class_INT       shift and go to state 52
    class_DOUBLE    shift and go to state 53
    class_FLOAT     shift and go to state 54
    class_VOID      shift and go to state 55
    class_UINT      shift and go to state 56
    class_BOOL      shift and go to state 57
    class_CHARACTER shift and go to state 58
    class_String    shift and go to state 59
    collection_SET  shift and go to state 60
    collection_ARRAY shift and go to state 61
    collection_DICT shift and go to state 62
    LESS            shift and go to state 45

  ! SEMICOLON       [ reduce using rule 76 (empty -> .) ]
  ! C_GLOBAL        [ reduce using rule 76 (empty -> .) ]
  ! D_IMPORT        [ reduce using rule 76 (empty -> .) ]
  ! C_PRAGMA        [ reduce using rule 76 (empty -> .) ]
  ! LBRACE          [ reduce using rule 76 (empty -> .) ]
  ! S_IF            [ reduce using rule 76 (empty -> .) ]
  ! S_SWITCH        [ reduce using rule 76 (empty -> .) ]
  ! E_WAIT          [ reduce using rule 76 (empty -> .) ]
  ! S_FOREACH       [ reduce using rule 76 (empty -> .) ]
  ! S_FOR           [ reduce using rule 76 (empty -> .) ]
  ! S_WHILE         [ reduce using rule 76 (empty -> .) ]
  ! S_ITERATE       [ reduce using rule 76 (empty -> .) ]
  ! S_ELSE          [ reduce using rule 76 (empty -> .) ]
  ! ID              [ reduce using rule 76 (empty -> .) ]
  ! C_APP           [ reduce using rule 76 (empty -> .) ]
  ! LPAREN          [ reduce using rule 76 (empty -> .) ]
  ! class_INT       [ reduce using rule 76 (empty -> .) ]
  ! class_DOUBLE    [ reduce using rule 76 (empty -> .) ]
  ! class_FLOAT     [ reduce using rule 76 (empty -> .) ]
  ! class_VOID      [ reduce using rule 76 (empty -> .) ]
  ! class_UINT      [ reduce using rule 76 (empty -> .) ]
  ! class_BOOL      [ reduce using rule 76 (empty -> .) ]
  ! class_CHARACTER [ reduce using rule 76 (empty -> .) ]
  ! class_String    [ reduce using rule 76 (empty -> .) ]
  ! collection_SET  [ reduce using rule 76 (empty -> .) ]
  ! collection_ARRAY [ reduce using rule 76 (empty -> .) ]
  ! collection_DICT [ reduce using rule 76 (empty -> .) ]
  ! LESS            [ reduce using rule 76 (empty -> .) ]

    translation-unit               shift and go to state 400
    statement-star                 shift and go to state 2
    statement                      shift and go to state 3
    empty                          shift and go to state 4
    global-const-defn              shift and go to state 6
    import-stmt                    shift and go to state 7
    pragma-stmt                    shift and go to state 8
    func-defn                      shift and go to state 9
    block                          shift and go to state 10
    if-stmt                        shift and go to state 11
    switch-stmt                    shift and go to state 12
    wait-stmt                      shift and go to state 13
    foreach-loop                   shift and go to state 14
    for-loop                       shift and go to state 15
    var-decl                       shift and go to state 16
    while-loop                     shift and go to state 17
    iterate-loop                   shift and go to state 18
    stmt-chain                     shift and go to state 19
    opt-else-block                 shift and go to state 20
    var-name                       shift and go to state 21
    assignment                     shift and go to state 22
    func-call                      shift and go to state 23
    update-stmt                    shift and go to state 24
    swift-func-defn                shift and go to state 29
    app-func-defn                  shift and go to state 30
    foreign-func-defn              shift and go to state 31
    type-prefix                    shift and go to state 39
    chainable-stmt                 shift and go to state 42
    lval-or-paren-lval             shift and go to state 44
    func-hdr                       shift and go to state 46
    type-name                      shift and go to state 48
    param-type                     shift and go to state 49
    lval-list                      shift and go to state 50
    type-params                    shift and go to state 51
    lval-expr                      shift and go to state 63

state 394

    (122) for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN . block
    (90) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 401

state 395

    (129) for-update-list -> for-assignment for-assignment-star .

    RPAREN          reduce using rule 129 (for-update-list -> for-assignment for-assignment-star .)


state 396

    (130) for-assignment-star -> COMMA . for-assignment for-assignment-star
    (132) for-assignment -> . var-name ASSIGN expr
    (227) var-name -> . ID

    ID              shift and go to state 82

    for-assignment                 shift and go to state 402
    var-name                       shift and go to state 176

state 397

    (57) app-out-star -> std-in-out-err ASSIGN expr . app-out-star
    (57) app-out-star -> . std-in-out-err ASSIGN expr app-out-star
    (58) app-out-star -> .
    (59) std-in-out-err -> . E_STDIN
    (60) std-in-out-err -> . E_STDOUT
    (61) std-in-out-err -> . E_STDERR

    SEMICOLON       reduce using rule 58 (app-out-star -> .)
    RBRACE          reduce using rule 58 (app-out-star -> .)
    E_STDIN         shift and go to state 357
    E_STDOUT        shift and go to state 358
    E_STDERR        shift and go to state 359

    std-in-out-err                 shift and go to state 356
    app-out-star                   shift and go to state 403

state 398

    (50) empty-or-ass-expr -> formal-arg-list ASSIGN . expr
    (134) expr -> . or-expr
    (135) or-expr -> . and-expr
    (136) or-expr -> . or-expr LOG_OR and-expr
    (137) and-expr -> . eq-expr
    (138) and-expr -> . and-expr LOG_AND eq-expr
    (139) eq-expr -> . cmp-expr
    (140) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (143) cmp-expr -> . add-expr
    (144) cmp-expr -> . cmp-expr cmp-sign add-expr
    (150) add-expr -> . mult-expr
    (151) add-expr -> . add-expr add-sign mult-expr
    (154) mult-expr -> . unary-expr
    (155) mult-expr -> . mult-expr mult-sign unary-expr
    (161) unary-expr -> . postfix-expr
    (162) unary-expr -> . minus-or-excl postfix-expr
    (165) postfix-expr -> . base-expr
    (166) postfix-expr -> . postfix-expr array-or-struct
    (163) minus-or-excl -> . MINUS
    (164) minus-or-excl -> . EXCLAMATION
    (171) base-expr -> . literal
    (172) base-expr -> . func-call
    (173) base-expr -> . var-name
    (174) base-expr -> . LPAREN expr RPAREN
    (175) base-expr -> . -constructor
    (176) base-expr -> . array-constructor
    (203) literal -> . STR_LITERAL
    (204) literal -> . MUL_STR_LITERAL
    (205) literal -> . INT
    (206) literal -> . float-literal
    (207) literal -> . bool-literal
    (177) func-call -> . ID LPAREN func-call-arg-list RPAREN
    (227) var-name -> . ID
    (184) -constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (187) array-constructor -> . array-list-constructor
    (188) array-constructor -> . array-range-constructor
    (189) array-constructor -> . array-kv-constructor
    (208) float-literal -> . DOUBLE
    (209) float-literal -> . INF
    (210) float-literal -> . NAN
    (211) bool-literal -> . E_TRUE
    (212) bool-literal -> . E_FALSE
    (190) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (193) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (196) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    MINUS           shift and go to state 127
    EXCLAMATION     shift and go to state 128
    LPAREN          shift and go to state 132
    STR_LITERAL     shift and go to state 135
    MUL_STR_LITERAL shift and go to state 136
    INT             shift and go to state 137
    ID              shift and go to state 140
    DOUBLE          shift and go to state 144
    INF             shift and go to state 145
    NAN             shift and go to state 146
    E_TRUE          shift and go to state 147
    E_FALSE         shift and go to state 148
    LBRACKET        shift and go to state 115
    LBRACE          shift and go to state 149

    expr                           shift and go to state 404
    or-expr                        shift and go to state 117
    and-expr                       shift and go to state 118
    eq-expr                        shift and go to state 119
    cmp-expr                       shift and go to state 120
    add-expr                       shift and go to state 121
    mult-expr                      shift and go to state 122
    unary-expr                     shift and go to state 123
    postfix-expr                   shift and go to state 124
    minus-or-excl                  shift and go to state 125
    base-expr                      shift and go to state 126
    literal                        shift and go to state 129
    func-call                      shift and go to state 130
    var-name                       shift and go to state 131
    -constructor                   shift and go to state 133
    array-constructor              shift and go to state 134
    float-literal                  shift and go to state 138
    bool-literal                   shift and go to state 139
    array-list-constructor         shift and go to state 141
    array-range-constructor        shift and go to state 142
    array-kv-constructor           shift and go to state 143

state 399

    (185) comma-expr-star -> COMMA expr comma-expr-star .

    RPAREN          reduce using rule 185 (comma-expr-star -> COMMA expr comma-expr-star .)


state 400

    (114) case -> S_CASE INT COLON translation-unit .

    S_CASE          reduce using rule 114 (case -> S_CASE INT COLON translation-unit .)
    S_DEFAULT       reduce using rule 114 (case -> S_CASE INT COLON translation-unit .)
    RBRACE          reduce using rule 114 (case -> S_CASE INT COLON translation-unit .)


state 401

    (122) for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .

    SEMICOLON       reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    C_GLOBAL        reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    D_IMPORT        reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    C_PRAGMA        reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    LBRACE          reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_IF            reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_SWITCH        reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    E_WAIT          reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_FOREACH       reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_FOR           reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_WHILE         reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_ITERATE       reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_ELSE          reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    ID              reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    C_APP           reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    LPAREN          reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_INT       reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_DOUBLE    reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_FLOAT     reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_VOID      reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_UINT      reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_BOOL      reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_CHARACTER reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_String    reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    collection_SET  reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    collection_ARRAY reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    collection_DICT reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    LESS            reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    $end            reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    RBRACE          reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_CASE          reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_DEFAULT       reduce using rule 122 (for-loop -> S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)


state 402

    (130) for-assignment-star -> COMMA for-assignment . for-assignment-star
    (130) for-assignment-star -> . COMMA for-assignment for-assignment-star
    (131) for-assignment-star -> .

    COMMA           shift and go to state 396
    RPAREN          reduce using rule 131 (for-assignment-star -> .)

    for-assignment-star            shift and go to state 405

state 403

    (57) app-out-star -> std-in-out-err ASSIGN expr app-out-star .

    SEMICOLON       reduce using rule 57 (app-out-star -> std-in-out-err ASSIGN expr app-out-star .)
    RBRACE          reduce using rule 57 (app-out-star -> std-in-out-err ASSIGN expr app-out-star .)


state 404

    (50) empty-or-ass-expr -> formal-arg-list ASSIGN expr .

    COMMA           reduce using rule 50 (empty-or-ass-expr -> formal-arg-list ASSIGN expr .)
    RPAREN          reduce using rule 50 (empty-or-ass-expr -> formal-arg-list ASSIGN expr .)


state 405

    (130) for-assignment-star -> COMMA for-assignment for-assignment-star .

    RPAREN          reduce using rule 130 (for-assignment-star -> COMMA for-assignment for-assignment-star .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMICOLON in state 0 resolved as shift
WARNING: shift/reduce conflict for C_GLOBAL in state 0 resolved as shift
WARNING: shift/reduce conflict for D_IMPORT in state 0 resolved as shift
WARNING: shift/reduce conflict for C_PRAGMA in state 0 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 0 resolved as shift
WARNING: shift/reduce conflict for S_IF in state 0 resolved as shift
WARNING: shift/reduce conflict for S_SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for E_WAIT in state 0 resolved as shift
WARNING: shift/reduce conflict for S_FOREACH in state 0 resolved as shift
WARNING: shift/reduce conflict for S_FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for S_WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for S_ITERATE in state 0 resolved as shift
WARNING: shift/reduce conflict for S_ELSE in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for C_APP in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for class_INT in state 0 resolved as shift
WARNING: shift/reduce conflict for class_DOUBLE in state 0 resolved as shift
WARNING: shift/reduce conflict for class_FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for class_VOID in state 0 resolved as shift
WARNING: shift/reduce conflict for class_UINT in state 0 resolved as shift
WARNING: shift/reduce conflict for class_BOOL in state 0 resolved as shift
WARNING: shift/reduce conflict for class_CHARACTER in state 0 resolved as shift
WARNING: shift/reduce conflict for class_String in state 0 resolved as shift
WARNING: shift/reduce conflict for collection_SET in state 0 resolved as shift
WARNING: shift/reduce conflict for collection_ARRAY in state 0 resolved as shift
WARNING: shift/reduce conflict for collection_DICT in state 0 resolved as shift
WARNING: shift/reduce conflict for LESS in state 0 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 3 resolved as shift
WARNING: shift/reduce conflict for C_GLOBAL in state 3 resolved as shift
WARNING: shift/reduce conflict for D_IMPORT in state 3 resolved as shift
WARNING: shift/reduce conflict for C_PRAGMA in state 3 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 3 resolved as shift
WARNING: shift/reduce conflict for S_IF in state 3 resolved as shift
WARNING: shift/reduce conflict for S_SWITCH in state 3 resolved as shift
WARNING: shift/reduce conflict for E_WAIT in state 3 resolved as shift
WARNING: shift/reduce conflict for S_FOREACH in state 3 resolved as shift
WARNING: shift/reduce conflict for S_FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for S_WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for S_ITERATE in state 3 resolved as shift
WARNING: shift/reduce conflict for S_ELSE in state 3 resolved as shift
WARNING: shift/reduce conflict for ID in state 3 resolved as shift
WARNING: shift/reduce conflict for C_APP in state 3 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 3 resolved as shift
WARNING: shift/reduce conflict for class_INT in state 3 resolved as shift
WARNING: shift/reduce conflict for class_DOUBLE in state 3 resolved as shift
WARNING: shift/reduce conflict for class_FLOAT in state 3 resolved as shift
WARNING: shift/reduce conflict for class_VOID in state 3 resolved as shift
WARNING: shift/reduce conflict for class_UINT in state 3 resolved as shift
WARNING: shift/reduce conflict for class_BOOL in state 3 resolved as shift
WARNING: shift/reduce conflict for class_CHARACTER in state 3 resolved as shift
WARNING: shift/reduce conflict for class_String in state 3 resolved as shift
WARNING: shift/reduce conflict for collection_SET in state 3 resolved as shift
WARNING: shift/reduce conflict for collection_ARRAY in state 3 resolved as shift
WARNING: shift/reduce conflict for collection_DICT in state 3 resolved as shift
WARNING: shift/reduce conflict for LESS in state 3 resolved as shift
WARNING: shift/reduce conflict for LESS in state 21 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 28 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 32 resolved as shift
WARNING: shift/reduce conflict for C_GLOBAL in state 32 resolved as shift
WARNING: shift/reduce conflict for D_IMPORT in state 32 resolved as shift
WARNING: shift/reduce conflict for C_PRAGMA in state 32 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 32 resolved as shift
WARNING: shift/reduce conflict for S_IF in state 32 resolved as shift
WARNING: shift/reduce conflict for S_SWITCH in state 32 resolved as shift
WARNING: shift/reduce conflict for E_WAIT in state 32 resolved as shift
WARNING: shift/reduce conflict for S_FOREACH in state 32 resolved as shift
WARNING: shift/reduce conflict for S_FOR in state 32 resolved as shift
WARNING: shift/reduce conflict for S_WHILE in state 32 resolved as shift
WARNING: shift/reduce conflict for S_ITERATE in state 32 resolved as shift
WARNING: shift/reduce conflict for S_ELSE in state 32 resolved as shift
WARNING: shift/reduce conflict for ID in state 32 resolved as shift
WARNING: shift/reduce conflict for C_APP in state 32 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 32 resolved as shift
WARNING: shift/reduce conflict for class_INT in state 32 resolved as shift
WARNING: shift/reduce conflict for class_DOUBLE in state 32 resolved as shift
WARNING: shift/reduce conflict for class_FLOAT in state 32 resolved as shift
WARNING: shift/reduce conflict for class_VOID in state 32 resolved as shift
WARNING: shift/reduce conflict for class_UINT in state 32 resolved as shift
WARNING: shift/reduce conflict for class_BOOL in state 32 resolved as shift
WARNING: shift/reduce conflict for class_CHARACTER in state 32 resolved as shift
WARNING: shift/reduce conflict for class_String in state 32 resolved as shift
WARNING: shift/reduce conflict for collection_SET in state 32 resolved as shift
WARNING: shift/reduce conflict for collection_ARRAY in state 32 resolved as shift
WARNING: shift/reduce conflict for collection_DICT in state 32 resolved as shift
WARNING: shift/reduce conflict for LESS in state 32 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 93 resolved as shift
WARNING: shift/reduce conflict for C_GLOBAL in state 93 resolved as shift
WARNING: shift/reduce conflict for D_IMPORT in state 93 resolved as shift
WARNING: shift/reduce conflict for C_PRAGMA in state 93 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 93 resolved as shift
WARNING: shift/reduce conflict for S_IF in state 93 resolved as shift
WARNING: shift/reduce conflict for S_SWITCH in state 93 resolved as shift
WARNING: shift/reduce conflict for E_WAIT in state 93 resolved as shift
WARNING: shift/reduce conflict for S_FOREACH in state 93 resolved as shift
WARNING: shift/reduce conflict for S_FOR in state 93 resolved as shift
WARNING: shift/reduce conflict for S_WHILE in state 93 resolved as shift
WARNING: shift/reduce conflict for S_ITERATE in state 93 resolved as shift
WARNING: shift/reduce conflict for S_ELSE in state 93 resolved as shift
WARNING: shift/reduce conflict for ID in state 93 resolved as shift
WARNING: shift/reduce conflict for C_APP in state 93 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 93 resolved as shift
WARNING: shift/reduce conflict for class_INT in state 93 resolved as shift
WARNING: shift/reduce conflict for class_DOUBLE in state 93 resolved as shift
WARNING: shift/reduce conflict for class_FLOAT in state 93 resolved as shift
WARNING: shift/reduce conflict for class_VOID in state 93 resolved as shift
WARNING: shift/reduce conflict for class_UINT in state 93 resolved as shift
WARNING: shift/reduce conflict for class_BOOL in state 93 resolved as shift
WARNING: shift/reduce conflict for class_CHARACTER in state 93 resolved as shift
WARNING: shift/reduce conflict for class_String in state 93 resolved as shift
WARNING: shift/reduce conflict for collection_SET in state 93 resolved as shift
WARNING: shift/reduce conflict for collection_ARRAY in state 93 resolved as shift
WARNING: shift/reduce conflict for collection_DICT in state 93 resolved as shift
WARNING: shift/reduce conflict for LESS in state 93 resolved as shift
WARNING: shift/reduce conflict for LESS in state 120 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 120 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 120 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 140 resolved as shift
WARNING: shift/reduce conflict for LESS in state 178 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 291 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 291 resolved as shift
WARNING: shift/reduce conflict for S_ELSE in state 305 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 393 resolved as shift
WARNING: shift/reduce conflict for C_GLOBAL in state 393 resolved as shift
WARNING: shift/reduce conflict for D_IMPORT in state 393 resolved as shift
WARNING: shift/reduce conflict for C_PRAGMA in state 393 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 393 resolved as shift
WARNING: shift/reduce conflict for S_IF in state 393 resolved as shift
WARNING: shift/reduce conflict for S_SWITCH in state 393 resolved as shift
WARNING: shift/reduce conflict for E_WAIT in state 393 resolved as shift
WARNING: shift/reduce conflict for S_FOREACH in state 393 resolved as shift
WARNING: shift/reduce conflict for S_FOR in state 393 resolved as shift
WARNING: shift/reduce conflict for S_WHILE in state 393 resolved as shift
WARNING: shift/reduce conflict for S_ITERATE in state 393 resolved as shift
WARNING: shift/reduce conflict for S_ELSE in state 393 resolved as shift
WARNING: shift/reduce conflict for ID in state 393 resolved as shift
WARNING: shift/reduce conflict for C_APP in state 393 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 393 resolved as shift
WARNING: shift/reduce conflict for class_INT in state 393 resolved as shift
WARNING: shift/reduce conflict for class_DOUBLE in state 393 resolved as shift
WARNING: shift/reduce conflict for class_FLOAT in state 393 resolved as shift
WARNING: shift/reduce conflict for class_VOID in state 393 resolved as shift
WARNING: shift/reduce conflict for class_UINT in state 393 resolved as shift
WARNING: shift/reduce conflict for class_BOOL in state 393 resolved as shift
WARNING: shift/reduce conflict for class_CHARACTER in state 393 resolved as shift
WARNING: shift/reduce conflict for class_String in state 393 resolved as shift
WARNING: shift/reduce conflict for collection_SET in state 393 resolved as shift
WARNING: shift/reduce conflict for collection_ARRAY in state 393 resolved as shift
WARNING: shift/reduce conflict for collection_DICT in state 393 resolved as shift
WARNING: shift/reduce conflict for LESS in state 393 resolved as shift
WARNING: reduce/reduce conflict in state 4 resolved using rule (statement-star -> empty)
WARNING: rejected rule (opt-else-block -> empty) in state 4
WARNING: reduce/reduce conflict in state 4 resolved using rule (type-params -> empty)
WARNING: rejected rule (opt-else-block -> empty) in state 4
WARNING: reduce/reduce conflict in state 16 resolved using rule (statement -> var-decl)
WARNING: rejected rule (chainable-stmt -> var-decl) in state 16
WARNING: reduce/reduce conflict in state 21 resolved using rule (statement -> var-name)
WARNING: rejected rule (chainable-stmt -> var-name) in state 21
WARNING: reduce/reduce conflict in state 22 resolved using rule (statement -> assignment)
WARNING: rejected rule (chainable-stmt -> assignment) in state 22
WARNING: reduce/reduce conflict in state 23 resolved using rule (statement -> func-call)
WARNING: rejected rule (chainable-stmt -> func-call) in state 23
WARNING: reduce/reduce conflict in state 28 resolved using rule (type-name -> ID)
WARNING: rejected rule (var-name -> ID) in state 28
WARNING: reduce/reduce conflict in state 183 resolved using rule (type-params -> empty)
WARNING: rejected rule (opt-else-block -> empty) in state 183
WARNING: reduce/reduce conflict in state 277 resolved using rule (empty-or-arg-list -> empty)
WARNING: rejected rule (formal-arg-list -> empty) in state 277
