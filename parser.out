Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERSAND
    BACKTICK
    BIT_NOT
    BIT_OR
    BIT_XOR
    C_ASSOCIATIVITY
    C_CONVENIENCE
    C_DID_SET
    C_DYNAMIC
    C_FINAL
    C_GET
    C_INDIRECT
    C_INFIX
    C_LAZY
    C_LEFT
    C_MUTATING
    C_NONE
    C_NONMUTATING
    C_OPTIONAL
    C_OVERRIDE
    C_POSTFIX
    C_PRECEDENCE
    C_PREFIX
    C_PROTOCOL
    C_REQUIRED
    C_RIGHT
    C_SET
    C_TYPE
    C_TYPEDEF
    C_UNOWNED
    C_WEAK
    C_WILLSET
    DIV_AS
    D_ASSOCIATED_TYPE
    D_DEINIT
    D_ENUM
    D_EXTENSION
    D_FILE_PRIVATE
    D_INIT
    D_INOUT
    D_OPERATOR
    D_PRIVATE
    D_PROTOCOL
    D_PUBLIC
    D_STATIC
    D_STRUCT
    D_SUBSCRIPT
    D_TYPE_ALIAS
    D_VAR
    E_ANY
    E_AS
    E_CATCH
    E_IS
    E_NIL
    E_RETHROWS
    E_SELF
    E_SELF_CAPITAL
    E_SUPER
    E_THROW
    E_THROWS
    E_TRY
    HASH
    HRANGE
    LSHIFT
    MINUS_AS
    MOD_AS
    MULT_AS
    N_AVAILABLE
    N_COLOR_LITERAL
    N_COLUMN
    N_ELSE
    N_ELSE_IF
    N_END_IF
    N_ERROR
    N_FILE
    N_FILE_LITERAL
    N_FUNCTION
    N_IF
    N_IMAGE_LITERAL
    N_LINE
    N_SELECTOR
    N_SOURCE_LOCATION
    N_WARNING
    P_UNDERSCORE
    QUESTION
    RSHIFT
    S_BREAK
    S_CONTINUE
    S_DEFER
    S_DO
    S_FALLTHROUGH
    S_GUARD
    S_REPEAT
    S_RETURN
    S_WHERE

Grammar

Rule 0     S' -> translation-unit
Rule 1     translation-unit -> statement-star
Rule 2     statement-star -> <empty>
Rule 3     statement-star -> statement statement-star
Rule 4     statement -> SEMICOLON
Rule 5     statement -> global-const-defn
Rule 6     statement -> import-stmt
Rule 7     statement -> pragma-stmt
Rule 8     statement -> func-defn
Rule 9     statement -> block
Rule 10    statement -> if-stmt
Rule 11    statement -> switch-stmt
Rule 12    statement -> wait-stmt
Rule 13    statement -> foreach-loop
Rule 14    statement -> for-loop
Rule 15    statement -> iterate-loop
Rule 16    statement -> stmt-chain
Rule 17    statement -> update-stmt
Rule 18    global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON
Rule 19    import-stmt -> D_IMPORT module-path SEMICOLON
Rule 20    import-stmt -> D_IMPORT STR_LITERAL SEMICOLON
Rule 21    module-path -> ID path-star
Rule 22    path-star -> <empty>
Rule 23    path-star -> DOT ID path-star
Rule 24    pragma-stmt -> C_PRAGMA ID expr SEMICOLON
Rule 25    func-defn -> swift-func-defn
Rule 26    func-defn -> app-func-defn
Rule 27    func-defn -> foreign-func-defn
Rule 28    func-hdr -> type-params formal-arg-list func-name empty-or-arg-list
Rule 29    empty-or-arg-list -> <empty>
Rule 30    empty-or-arg-list -> formal-arg-list
Rule 31    type-params -> <empty>
Rule 32    type-params -> LESS var-name comma-name-star GREATER
Rule 33    comma-name-star -> <empty>
Rule 34    comma-name-star -> COMMA var-name comma-name-star
Rule 35    formal-arg-list -> <empty>
Rule 36    formal-arg-list -> LPAREN opt-formal-args RPAREN
Rule 37    opt-formal-args -> <empty>
Rule 38    opt-formal-args -> formal-arg comma-args-star
Rule 39    comma-args-star -> <empty>
Rule 40    comma-args-star -> COMMA formal-arg comma-args-star
Rule 41    formal-arg -> type-prefix empty-or-range var-name type-suffix empty-or-ass-expr
Rule 42    empty-or-range -> <empty>
Rule 43    empty-or-range -> RANGE
Rule 44    empty-or-ass-expr -> <empty>
Rule 45    empty-or-ass-expr -> formal-arg-list ASSIGN expr
Rule 46    swift-func-defn -> annotation-star func-hdr ARROW block
Rule 47    annotation-star -> <empty>
Rule 48    annotation-star -> annotation annotation-star
Rule 49    app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE
Rule 50    app-body -> app-arg-expr app-arg-expr-star app-out-star empty-or-semicolon
Rule 51    empty-or-semicolon -> <empty>
Rule 52    empty-or-semicolon -> SEMICOLON
Rule 53    app-out-star -> <empty>
Rule 54    app-out-star -> std-in-out-err ASSIGN expr app-out-star
Rule 55    std-in-out-err -> E_STDIN
Rule 56    std-in-out-err -> E_STDOUT
Rule 57    std-in-out-err -> E_STDERR
Rule 58    app-arg-expr-star -> <empty>
Rule 59    app-arg-expr-star -> app-arg-expr app-arg-expr-star
Rule 60    foreign-func-defn -> annotation-star func-hdr foreign-func-body
Rule 61    foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals
Rule 62    empty-or-literal -> <empty>
Rule 63    empty-or-literal -> STR_LITERAL
Rule 64    empty-or-more-literals -> <empty>
Rule 65    empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET
Rule 66    single-or-multiple-literal -> STR_LITERAL
Rule 67    single-or-multiple-literal -> MUL_STR_LITERAL
Rule 68    var-decl -> type-prefix var-decl-rest
Rule 69    var-decl-rest-star -> <empty>
Rule 70    var-decl-rest-star -> COMMA var-decl-rest var-decl-rest-star
Rule 71    var-decl-rest -> var-name type-suffix empty-or-var-mappign empty-or-assign-expr
Rule 72    empty-or-var-mappign -> <empty>
Rule 73    empty-or-var-mappign -> var-mapping
Rule 74    empty-or-assign-expr -> <empty>
Rule 75    empty-or-assign-expr -> ASSIGN expr
Rule 76    type-prefix -> type-name
Rule 77    type-prefix -> param-type
Rule 78    param-type -> type-name LESS standalone-type GREATER
Rule 79    type-suffix -> <empty>
Rule 80    type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix
Rule 81    empty-or-standalone-type -> <empty>
Rule 82    empty-or-standalone-type -> standalone-type
Rule 83    standalone-type -> type-prefix type-suffix
Rule 84    var-mapping -> LESS expr GREATER
Rule 85    block -> LBRACE translation-unit RBRACE
Rule 86    stmt-chain -> chainable-stmt semicolon-or-arrow statement
Rule 87    semicolon-or-arrow -> SEMICOLON
Rule 88    semicolon-or-arrow -> ARROW
Rule 89    chainable-stmt -> var-name
Rule 90    chainable-stmt -> func-call
Rule 91    chainable-stmt -> var-decl
Rule 92    chainable-stmt -> assignment
Rule 93    assignment -> lval-or-paren-lval assign-or-plusas expr-list
Rule 94    lval-or-lval-list -> lval-list
Rule 95    lval-or-lval-list -> LPAREN lval-list RPAREN
Rule 96    assign-or-plusas -> ASSIGN
Rule 97    assign-or-plusas -> PLUS_AS
Rule 98    lval-or-paren-lval -> lval-list
Rule 99    lval-or-paren-lval -> LPAREN lval-list RPAREN
Rule 100   update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON
Rule 101   if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block
Rule 102   opt-else-block -> <empty>
Rule 103   opt-else-block -> S_ELSE block
Rule 104   switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE
Rule 105   opt-default -> <empty>
Rule 106   opt-default -> S_DEFAULT
Rule 107   case-star -> <empty>
Rule 108   case-star -> case case-star
Rule 109   case -> S_CASE INT COLON translation-unit
Rule 110   default -> S_DEFAULT COLON translation-unit
Rule 111   wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block
Rule 112   opt-deep -> <empty>
Rule 113   opt-deep -> E_DEEP
Rule 114   foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block
Rule 115   opt-comma-var-name -> <empty>
Rule 116   opt-comma-var-name -> COMMA var-name
Rule 117   for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
Rule 118   while-loop -> annotation S_WHILE LPAREN expr RPAREN block
Rule 119   for-init-list -> for-init for-init-star
Rule 120   for-init-star -> <empty>
Rule 121   for-init-star -> COMMA for-init for-init-star
Rule 122   for-init -> for-assignment
Rule 123   for-init -> type-prefix var-name type-suffix ASSIGN expr
Rule 124   for-update-list -> for-assignment for-assignment-star
Rule 125   for-assignment-star -> <empty>
Rule 126   for-assignment-star -> COMMA for-assignment for-assignment-star
Rule 127   for-assignment -> var-name ASSIGN expr
Rule 128   iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN
Rule 129   expr -> or-expr
Rule 130   or-expr -> and-expr
Rule 131   or-expr -> or-expr LOG_OR and-expr
Rule 132   and-expr -> eq-expr
Rule 133   and-expr -> and-expr LOG_AND eq-expr
Rule 134   eq-expr -> cmp-expr
Rule 135   eq-expr -> eq-expr eq-or-not-eq eq-expr
Rule 136   eq-or-not-eq -> EQUAL
Rule 137   eq-or-not-eq -> NOT_EQUAL
Rule 138   cmp-expr -> add-expr
Rule 139   cmp-expr -> cmp-expr cmp-sign add-expr
Rule 140   cmp-sign -> LESS
Rule 141   cmp-sign -> LESS_EQ
Rule 142   cmp-sign -> EQUAL
Rule 143   cmp-sign -> GREATER
Rule 144   cmp-sign -> GREATER_EQ
Rule 145   add-expr -> mult-expr
Rule 146   add-expr -> add-expr add-sign mult-expr
Rule 147   add-sign -> PLUS
Rule 148   add-sign -> MINUS
Rule 149   mult-expr -> unary-expr
Rule 150   mult-expr -> mult-expr mult-sign unary-expr
Rule 151   mult-sign -> MULT
Rule 152   mult-sign -> DIV
Rule 153   mult-sign -> MULTPER
Rule 154   mult-sign -> DOUBLEPER
Rule 155   mult-sign -> MOD
Rule 156   unary-expr -> postfix-expr
Rule 157   unary-expr -> minus-or-excl postfix-expr
Rule 158   minus-or-excl -> MINUS
Rule 159   minus-or-excl -> EXCLAMATION
Rule 160   postfix-expr -> base-expr
Rule 161   postfix-expr -> postfix-expr array-or-struct
Rule 162   array-or-struct -> array-subscript
Rule 163   array-or-struct -> struct-subscript
Rule 164   array-subscript -> LBRACKET expr RBRACKET
Rule 165   struct-subscript -> DOT ID
Rule 166   base-expr -> literal
Rule 167   base-expr -> func-call
Rule 168   base-expr -> var-name
Rule 169   base-expr -> LPAREN expr RPAREN
Rule 170   base-expr -> tuple-constructor
Rule 171   base-expr -> array-constructor
Rule 172   func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN
Rule 173   func-call-arg-list -> expr-or-kw func-call-arg-star
Rule 174   func-call-arg-star -> <empty>
Rule 175   func-call-arg-star -> COMMA expr-or-kw func-call-arg-star
Rule 176   expr-or-kw -> expr
Rule 177   expr-or-kw -> kw-expr
Rule 178   tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN
Rule 179   comma-expr-star -> <empty>
Rule 180   comma-expr-star -> COMMA expr comma-expr-star
Rule 181   array-constructor -> array-list-constructor
Rule 182   array-constructor -> array-range-constructor
Rule 183   array-constructor -> array-kv-constructor
Rule 184   array-list-constructor -> LBRACKET opt-expr-list RBRACKET
Rule 185   opt-expr-list -> <empty>
Rule 186   opt-expr-list -> expr-list
Rule 187   array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET
Rule 188   opt-coloned-expr -> <empty>
Rule 189   opt-coloned-expr -> COLON expr
Rule 190   array-kv-constructor -> LBRACE opt-array-constructor RBRACE
Rule 191   opt-array-constructor -> <empty>
Rule 192   opt-array-constructor -> array-kv-elem comma-array-kv-elem-star
Rule 193   comma-array-kv-elem-star -> <empty>
Rule 194   comma-array-kv-elem-star -> COMMA array-kv-elem comma-array-kv-elem-star
Rule 195   array-kv-elem -> expr COLON expr
Rule 196   annotation -> AT ID
Rule 197   annotation -> AT kw-expr
Rule 198   kw-expr -> ID ASSIGN expr
Rule 199   literal -> STR_LITERAL
Rule 200   literal -> MUL_STR_LITERAL
Rule 201   literal -> INT
Rule 202   literal -> float-literal
Rule 203   literal -> bool-literal
Rule 204   float-literal -> DOUBLE
Rule 205   float-literal -> INF
Rule 206   float-literal -> NAN
Rule 207   bool-literal -> E_TRUE
Rule 208   bool-literal -> E_FALSE
Rule 209   expr-list -> expr
Rule 210   type-name -> class_INT
Rule 211   type-name -> class_DOUBLE
Rule 212   type-name -> class_FLOAT
Rule 213   type-name -> class_VOID
Rule 214   type-name -> class_UINT
Rule 215   type-name -> class_BOOL
Rule 216   type-name -> class_CHARACTER
Rule 217   type-name -> class_String
Rule 218   type-name -> collection_SET
Rule 219   type-name -> collection_ARRAY
Rule 220   type-name -> collection_DICT
Rule 221   type-name -> ID
Rule 222   const-name -> D_LET ID
Rule 223   var-name -> ID
Rule 224   func-name -> D_FUNCTION ID
Rule 225   lval-list -> lval-expr lval-expr-star
Rule 226   lval-expr-star -> <empty>
Rule 227   lval-expr-star -> COMMA lval-expr lval-expr-star
Rule 228   lval-expr -> var-name subscript-star
Rule 229   subscript-star -> <empty>
Rule 230   subscript-star -> array-subscript subscript-star
Rule 231   subscript-star -> struct-subscript subscript-star
Rule 232   app-arg-expr -> opt-at var-name
Rule 233   app-arg-expr -> literal
Rule 234   app-arg-expr -> array-constructor
Rule 235   app-arg-expr -> LPAREN expr RPAREN
Rule 236   opt-at -> <empty>
Rule 237   opt-at -> AT

Terminals, with rules where they appear

AMPERSAND            : 
ARROW                : 46 88
ASSIGN               : 45 54 75 96 123 127 198
AT                   : 196 197 237
BACKTICK             : 
BIT_NOT              : 
BIT_OR               : 
BIT_XOR              : 
COLON                : 109 110 187 189 195
COMMA                : 34 40 70 116 121 126 175 178 180 194 227
C_APP                : 49
C_ASSOCIATIVITY      : 
C_CONST              : 18
C_CONVENIENCE        : 
C_DID_SET            : 
C_DYNAMIC            : 
C_FINAL              : 
C_GET                : 
C_GLOBAL             : 18
C_INDIRECT           : 
C_INFIX              : 
C_LAZY               : 
C_LEFT               : 
C_MUTATING           : 
C_NONE               : 
C_NONMUTATING        : 
C_OPTIONAL           : 
C_OVERRIDE           : 
C_POSTFIX            : 
C_PRAGMA             : 24
C_PRECEDENCE         : 
C_PREFIX             : 
C_PROTOCOL           : 
C_REQUIRED           : 
C_RIGHT              : 
C_SET                : 
C_TYPE               : 
C_TYPEDEF            : 
C_UNOWNED            : 
C_WEAK               : 
C_WILLSET            : 
DIV                  : 152
DIV_AS               : 
DOT                  : 23 165
DOUBLE               : 204
DOUBLEPER            : 154
D_ASSOCIATED_TYPE    : 
D_DEINIT             : 
D_ENUM               : 
D_EXTENSION          : 
D_FILE_PRIVATE       : 
D_FUNCTION           : 224
D_IMPORT             : 19 20
D_INIT               : 
D_INOUT              : 
D_LET                : 222
D_OPERATOR           : 
D_PRIVATE            : 
D_PROTOCOL           : 
D_PUBLIC             : 
D_STATIC             : 
D_STRUCT             : 
D_SUBSCRIPT          : 
D_TYPE_ALIAS         : 
D_VAR                : 
EQUAL                : 136 142
EXCLAMATION          : 159
E_ANY                : 
E_AS                 : 
E_CATCH              : 
E_DEEP               : 113
E_FALSE              : 208
E_IS                 : 
E_NIL                : 
E_RETHROWS           : 
E_SELF               : 
E_SELF_CAPITAL       : 
E_STDERR             : 57
E_STDIN              : 55
E_STDOUT             : 56
E_SUPER              : 
E_THROW              : 
E_THROWS             : 
E_TRUE               : 207
E_TRY                : 
E_WAIT               : 111
GREATER              : 32 78 84 100 143
GREATER_EQ           : 144
HASH                 : 
HRANGE               : 
ID                   : 21 23 24 100 165 196 198 221 222 223 224
INF                  : 205
INT                  : 109 201
LBRACE               : 49 85 104 190
LBRACKET             : 65 80 164 184 187
LESS                 : 32 78 84 100 140
LESS_EQ              : 141
LOG_AND              : 133
LOG_OR               : 131
LPAREN               : 36 95 99 101 104 111 117 118 128 169 172 178 235
LSHIFT               : 
MINUS                : 148 158
MINUS_AS             : 
MOD                  : 155
MOD_AS               : 
MULT                 : 151
MULTPER              : 153
MULT_AS              : 
MUL_STR_LITERAL      : 67 200
NAN                  : 206
NOT_EQUAL            : 137
N_AVAILABLE          : 
N_COLOR_LITERAL      : 
N_COLUMN             : 
N_ELSE               : 
N_ELSE_IF            : 
N_END_IF             : 
N_ERROR              : 
N_FILE               : 
N_FILE_LITERAL       : 
N_FUNCTION           : 
N_IF                 : 
N_IMAGE_LITERAL      : 
N_LINE               : 
N_SELECTOR           : 
N_SOURCE_LOCATION    : 
N_WARNING            : 
PLUS                 : 147
PLUS_AS              : 97
P_UNDERSCORE         : 
QUESTION             : 
RANGE                : 43
RBRACE               : 49 85 104 190
RBRACKET             : 65 80 164 184 187
RPAREN               : 36 95 99 101 104 111 117 118 128 169 172 178 235
RSHIFT               : 
SEMICOLON            : 4 18 19 20 24 52 87 100 117 117
STR_LITERAL          : 20 61 61 63 66 199
S_BREAK              : 
S_CASE               : 109
S_CONTINUE           : 
S_DEFAULT            : 106 110
S_DEFER              : 
S_DO                 : 
S_ELSE               : 103
S_FALLTHROUGH        : 
S_FOR                : 117
S_FOREACH            : 114
S_GUARD              : 
S_IF                 : 101
S_IN                 : 114
S_ITERATE            : 128
S_REPEAT             : 
S_RETURN             : 
S_SWITCH             : 104
S_UNTIL              : 128
S_WHERE              : 
S_WHILE              : 118
UPD                  : 100
class_BOOL           : 215
class_CHARACTER      : 216
class_DOUBLE         : 211
class_FLOAT          : 212
class_INT            : 210
class_String         : 217
class_UINT           : 214
class_VOID           : 213
collection_ARRAY     : 219
collection_DICT      : 220
collection_SET       : 218
error                : 

Nonterminals, with rules where they appear

add-expr             : 138 139 146
add-sign             : 146
and-expr             : 130 131 133
annotation           : 48 118
annotation-star      : 46 48 49 60 114 117 172
app-arg-expr         : 50 59
app-arg-expr-star    : 50 59
app-body             : 49
app-func-defn        : 26
app-out-star         : 50 54
array-constructor    : 171 234
array-kv-constructor : 183
array-kv-elem        : 192 194
array-list-constructor : 181
array-or-struct      : 161
array-range-constructor : 182
array-subscript      : 162 230
assign-or-plusas     : 93
assignment           : 92
base-expr            : 160
block                : 9 46 101 103 111 114 117 118 128
bool-literal         : 203
case                 : 108
case-star            : 104 108
chainable-stmt       : 86
cmp-expr             : 134 139
cmp-sign             : 139
comma-args-star      : 38 40
comma-array-kv-elem-star : 192 194
comma-expr-star      : 178 180
comma-name-star      : 32 34
const-name           : 
default              : 
empty-or-arg-list    : 28
empty-or-ass-expr    : 41
empty-or-assign-expr : 71
empty-or-literal     : 61
empty-or-more-literals : 61
empty-or-range       : 41
empty-or-semicolon   : 50
empty-or-standalone-type : 80
empty-or-var-mappign : 71
eq-expr              : 132 133 135 135
eq-or-not-eq         : 135
expr                 : 24 45 54 75 84 100 101 104 114 117 118 123 127 128 164 169 176 178 178 180 187 187 189 195 195 198 209 235
expr-list            : 93 111 186
expr-or-kw           : 173 175
float-literal        : 202
for-assignment       : 122 124 126
for-assignment-star  : 124 126
for-init             : 119 121
for-init-list        : 117
for-init-star        : 119 121
for-loop             : 14
for-update-list      : 117
foreach-loop         : 13
foreign-func-body    : 60
foreign-func-defn    : 27
formal-arg           : 38 40
formal-arg-list      : 28 30 45
func-call            : 90 167
func-call-arg-list   : 172
func-call-arg-star   : 173 175
func-defn            : 8
func-hdr             : 46 49 60
func-name            : 28 172
global-const-defn    : 5
if-stmt              : 10
import-stmt          : 6
iterate-loop         : 15
kw-expr              : 177 197
literal              : 166 233
lval-expr            : 225 227
lval-expr-star       : 225 227
lval-list            : 94 95 98 99
lval-or-lval-list    : 
lval-or-paren-lval   : 93
minus-or-excl        : 157
module-path          : 19
mult-expr            : 145 146 150
mult-sign            : 150
opt-array-constructor : 190
opt-at               : 232
opt-coloned-expr     : 187
opt-comma-var-name   : 114
opt-deep             : 111
opt-default          : 104
opt-else-block       : 101
opt-expr-list        : 184
opt-formal-args      : 36
or-expr              : 129 131
param-type           : 77
path-star            : 21 23
postfix-expr         : 156 157 161
pragma-stmt          : 7
semicolon-or-arrow   : 86
single-or-multiple-literal : 65
standalone-type      : 78 82
statement            : 3 86
statement-star       : 1 3
std-in-out-err       : 54
stmt-chain           : 16
struct-subscript     : 163 231
subscript-star       : 228 230 231
swift-func-defn      : 25
switch-stmt          : 11
translation-unit     : 85 109 110 0
tuple-constructor    : 170
type-name            : 76 78
type-params          : 28
type-prefix          : 41 68 83 123
type-suffix          : 41 71 80 83 123
unary-expr           : 149 150
update-stmt          : 17
var-decl             : 18 91
var-decl-rest        : 68 70
var-decl-rest-star   : 70
var-mapping          : 73
var-name             : 32 34 41 71 89 100 114 116 123 127 128 168 228 232
wait-stmt            : 12
while-loop           : 

Parsing method: LALR

state 0

    (0) S' -> . translation-unit
    (1) translation-unit -> . statement-star
    (2) statement-star -> .
    (3) statement-star -> . statement statement-star
    (4) statement -> . SEMICOLON
    (5) statement -> . global-const-defn
    (6) statement -> . import-stmt
    (7) statement -> . pragma-stmt
    (8) statement -> . func-defn
    (9) statement -> . block
    (10) statement -> . if-stmt
    (11) statement -> . switch-stmt
    (12) statement -> . wait-stmt
    (13) statement -> . foreach-loop
    (14) statement -> . for-loop
    (15) statement -> . iterate-loop
    (16) statement -> . stmt-chain
    (17) statement -> . update-stmt
    (18) global-const-defn -> . C_GLOBAL C_CONST var-decl SEMICOLON
    (19) import-stmt -> . D_IMPORT module-path SEMICOLON
    (20) import-stmt -> . D_IMPORT STR_LITERAL SEMICOLON
    (24) pragma-stmt -> . C_PRAGMA ID expr SEMICOLON
    (25) func-defn -> . swift-func-defn
    (26) func-defn -> . app-func-defn
    (27) func-defn -> . foreign-func-defn
    (85) block -> . LBRACE translation-unit RBRACE
    (101) if-stmt -> . S_IF LPAREN expr RPAREN block opt-else-block
    (104) switch-stmt -> . S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE
    (111) wait-stmt -> . E_WAIT opt-deep LPAREN expr-list RPAREN block
    (114) foreach-loop -> . annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block
    (117) for-loop -> . annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
    (128) iterate-loop -> . S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN
    (86) stmt-chain -> . chainable-stmt semicolon-or-arrow statement
    (100) update-stmt -> . var-name LESS ID GREATER UPD expr SEMICOLON
    (46) swift-func-defn -> . annotation-star func-hdr ARROW block
    (49) app-func-defn -> . annotation-star C_APP func-hdr LBRACE app-body RBRACE
    (60) foreign-func-defn -> . annotation-star func-hdr foreign-func-body
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (89) chainable-stmt -> . var-name
    (90) chainable-stmt -> . func-call
    (91) chainable-stmt -> . var-decl
    (92) chainable-stmt -> . assignment
    (223) var-name -> . ID
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (68) var-decl -> . type-prefix var-decl-rest
    (93) assignment -> . lval-or-paren-lval assign-or-plusas expr-list
    (76) type-prefix -> . type-name
    (77) type-prefix -> . param-type
    (98) lval-or-paren-lval -> . lval-list
    (99) lval-or-paren-lval -> . LPAREN lval-list RPAREN
    (210) type-name -> . class_INT
    (211) type-name -> . class_DOUBLE
    (212) type-name -> . class_FLOAT
    (213) type-name -> . class_VOID
    (214) type-name -> . class_UINT
    (215) type-name -> . class_BOOL
    (216) type-name -> . class_CHARACTER
    (217) type-name -> . class_String
    (218) type-name -> . collection_SET
    (219) type-name -> . collection_ARRAY
    (220) type-name -> . collection_DICT
    (221) type-name -> . ID
    (78) param-type -> . type-name LESS standalone-type GREATER
    (225) lval-list -> . lval-expr lval-expr-star
    (228) lval-expr -> . var-name subscript-star

  ! shift/reduce conflict for LPAREN resolved as shift
    $end            reduce using rule 2 (statement-star -> .)
    SEMICOLON       shift and go to state 4
    C_GLOBAL        shift and go to state 18
    D_IMPORT        shift and go to state 20
    C_PRAGMA        shift and go to state 21
    LBRACE          shift and go to state 26
    S_IF            shift and go to state 27
    S_SWITCH        shift and go to state 29
    E_WAIT          shift and go to state 30
    S_ITERATE       shift and go to state 33
    S_FOREACH       reduce using rule 47 (annotation-star -> .)
    S_FOR           reduce using rule 47 (annotation-star -> .)
    C_APP           reduce using rule 47 (annotation-star -> .)
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LESS            reduce using rule 47 (annotation-star -> .)
    ID              shift and go to state 22
    AT              shift and go to state 38
    LPAREN          shift and go to state 28
    class_INT       shift and go to state 44
    class_DOUBLE    shift and go to state 45
    class_FLOAT     shift and go to state 46
    class_VOID      shift and go to state 47
    class_UINT      shift and go to state 48
    class_BOOL      shift and go to state 49
    class_CHARACTER shift and go to state 50
    class_String    shift and go to state 51
    collection_SET  shift and go to state 52
    collection_ARRAY shift and go to state 53
    collection_DICT shift and go to state 54

  ! LPAREN          [ reduce using rule 47 (annotation-star -> .) ]

    translation-unit               shift and go to state 1
    statement-star                 shift and go to state 2
    statement                      shift and go to state 3
    global-const-defn              shift and go to state 5
    import-stmt                    shift and go to state 6
    pragma-stmt                    shift and go to state 7
    func-defn                      shift and go to state 8
    block                          shift and go to state 9
    if-stmt                        shift and go to state 10
    switch-stmt                    shift and go to state 11
    wait-stmt                      shift and go to state 12
    foreach-loop                   shift and go to state 13
    for-loop                       shift and go to state 14
    iterate-loop                   shift and go to state 15
    stmt-chain                     shift and go to state 16
    update-stmt                    shift and go to state 17
    var-decl                       shift and go to state 19
    swift-func-defn                shift and go to state 23
    app-func-defn                  shift and go to state 24
    foreign-func-defn              shift and go to state 25
    annotation-star                shift and go to state 31
    var-name                       shift and go to state 32
    chainable-stmt                 shift and go to state 34
    annotation                     shift and go to state 35
    func-call                      shift and go to state 36
    assignment                     shift and go to state 37
    type-prefix                    shift and go to state 39
    lval-or-paren-lval             shift and go to state 40
    type-name                      shift and go to state 41
    param-type                     shift and go to state 42
    lval-list                      shift and go to state 43
    lval-expr                      shift and go to state 55

state 1

    (0) S' -> translation-unit .



state 2

    (1) translation-unit -> statement-star .

    $end            reduce using rule 1 (translation-unit -> statement-star .)
    RBRACE          reduce using rule 1 (translation-unit -> statement-star .)
    S_CASE          reduce using rule 1 (translation-unit -> statement-star .)
    S_DEFAULT       reduce using rule 1 (translation-unit -> statement-star .)


state 3

    (3) statement-star -> statement . statement-star
    (2) statement-star -> .
    (3) statement-star -> . statement statement-star
    (4) statement -> . SEMICOLON
    (5) statement -> . global-const-defn
    (6) statement -> . import-stmt
    (7) statement -> . pragma-stmt
    (8) statement -> . func-defn
    (9) statement -> . block
    (10) statement -> . if-stmt
    (11) statement -> . switch-stmt
    (12) statement -> . wait-stmt
    (13) statement -> . foreach-loop
    (14) statement -> . for-loop
    (15) statement -> . iterate-loop
    (16) statement -> . stmt-chain
    (17) statement -> . update-stmt
    (18) global-const-defn -> . C_GLOBAL C_CONST var-decl SEMICOLON
    (19) import-stmt -> . D_IMPORT module-path SEMICOLON
    (20) import-stmt -> . D_IMPORT STR_LITERAL SEMICOLON
    (24) pragma-stmt -> . C_PRAGMA ID expr SEMICOLON
    (25) func-defn -> . swift-func-defn
    (26) func-defn -> . app-func-defn
    (27) func-defn -> . foreign-func-defn
    (85) block -> . LBRACE translation-unit RBRACE
    (101) if-stmt -> . S_IF LPAREN expr RPAREN block opt-else-block
    (104) switch-stmt -> . S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE
    (111) wait-stmt -> . E_WAIT opt-deep LPAREN expr-list RPAREN block
    (114) foreach-loop -> . annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block
    (117) for-loop -> . annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
    (128) iterate-loop -> . S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN
    (86) stmt-chain -> . chainable-stmt semicolon-or-arrow statement
    (100) update-stmt -> . var-name LESS ID GREATER UPD expr SEMICOLON
    (46) swift-func-defn -> . annotation-star func-hdr ARROW block
    (49) app-func-defn -> . annotation-star C_APP func-hdr LBRACE app-body RBRACE
    (60) foreign-func-defn -> . annotation-star func-hdr foreign-func-body
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (89) chainable-stmt -> . var-name
    (90) chainable-stmt -> . func-call
    (91) chainable-stmt -> . var-decl
    (92) chainable-stmt -> . assignment
    (223) var-name -> . ID
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (68) var-decl -> . type-prefix var-decl-rest
    (93) assignment -> . lval-or-paren-lval assign-or-plusas expr-list
    (76) type-prefix -> . type-name
    (77) type-prefix -> . param-type
    (98) lval-or-paren-lval -> . lval-list
    (99) lval-or-paren-lval -> . LPAREN lval-list RPAREN
    (210) type-name -> . class_INT
    (211) type-name -> . class_DOUBLE
    (212) type-name -> . class_FLOAT
    (213) type-name -> . class_VOID
    (214) type-name -> . class_UINT
    (215) type-name -> . class_BOOL
    (216) type-name -> . class_CHARACTER
    (217) type-name -> . class_String
    (218) type-name -> . collection_SET
    (219) type-name -> . collection_ARRAY
    (220) type-name -> . collection_DICT
    (221) type-name -> . ID
    (78) param-type -> . type-name LESS standalone-type GREATER
    (225) lval-list -> . lval-expr lval-expr-star
    (228) lval-expr -> . var-name subscript-star

  ! shift/reduce conflict for LPAREN resolved as shift
    $end            reduce using rule 2 (statement-star -> .)
    RBRACE          reduce using rule 2 (statement-star -> .)
    S_CASE          reduce using rule 2 (statement-star -> .)
    S_DEFAULT       reduce using rule 2 (statement-star -> .)
    SEMICOLON       shift and go to state 4
    C_GLOBAL        shift and go to state 18
    D_IMPORT        shift and go to state 20
    C_PRAGMA        shift and go to state 21
    LBRACE          shift and go to state 26
    S_IF            shift and go to state 27
    S_SWITCH        shift and go to state 29
    E_WAIT          shift and go to state 30
    S_ITERATE       shift and go to state 33
    S_FOREACH       reduce using rule 47 (annotation-star -> .)
    S_FOR           reduce using rule 47 (annotation-star -> .)
    C_APP           reduce using rule 47 (annotation-star -> .)
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LESS            reduce using rule 47 (annotation-star -> .)
    ID              shift and go to state 22
    AT              shift and go to state 38
    LPAREN          shift and go to state 28
    class_INT       shift and go to state 44
    class_DOUBLE    shift and go to state 45
    class_FLOAT     shift and go to state 46
    class_VOID      shift and go to state 47
    class_UINT      shift and go to state 48
    class_BOOL      shift and go to state 49
    class_CHARACTER shift and go to state 50
    class_String    shift and go to state 51
    collection_SET  shift and go to state 52
    collection_ARRAY shift and go to state 53
    collection_DICT shift and go to state 54

  ! LPAREN          [ reduce using rule 47 (annotation-star -> .) ]

    statement                      shift and go to state 3
    statement-star                 shift and go to state 56
    global-const-defn              shift and go to state 5
    import-stmt                    shift and go to state 6
    pragma-stmt                    shift and go to state 7
    func-defn                      shift and go to state 8
    block                          shift and go to state 9
    if-stmt                        shift and go to state 10
    switch-stmt                    shift and go to state 11
    wait-stmt                      shift and go to state 12
    foreach-loop                   shift and go to state 13
    for-loop                       shift and go to state 14
    iterate-loop                   shift and go to state 15
    stmt-chain                     shift and go to state 16
    update-stmt                    shift and go to state 17
    var-decl                       shift and go to state 19
    swift-func-defn                shift and go to state 23
    app-func-defn                  shift and go to state 24
    foreign-func-defn              shift and go to state 25
    annotation-star                shift and go to state 31
    var-name                       shift and go to state 32
    chainable-stmt                 shift and go to state 34
    annotation                     shift and go to state 35
    func-call                      shift and go to state 36
    assignment                     shift and go to state 37
    type-prefix                    shift and go to state 39
    lval-or-paren-lval             shift and go to state 40
    type-name                      shift and go to state 41
    param-type                     shift and go to state 42
    lval-list                      shift and go to state 43
    lval-expr                      shift and go to state 55

state 4

    (4) statement -> SEMICOLON .

    SEMICOLON       reduce using rule 4 (statement -> SEMICOLON .)
    C_GLOBAL        reduce using rule 4 (statement -> SEMICOLON .)
    D_IMPORT        reduce using rule 4 (statement -> SEMICOLON .)
    C_PRAGMA        reduce using rule 4 (statement -> SEMICOLON .)
    LBRACE          reduce using rule 4 (statement -> SEMICOLON .)
    S_IF            reduce using rule 4 (statement -> SEMICOLON .)
    S_SWITCH        reduce using rule 4 (statement -> SEMICOLON .)
    E_WAIT          reduce using rule 4 (statement -> SEMICOLON .)
    S_ITERATE       reduce using rule 4 (statement -> SEMICOLON .)
    ID              reduce using rule 4 (statement -> SEMICOLON .)
    AT              reduce using rule 4 (statement -> SEMICOLON .)
    LPAREN          reduce using rule 4 (statement -> SEMICOLON .)
    class_INT       reduce using rule 4 (statement -> SEMICOLON .)
    class_DOUBLE    reduce using rule 4 (statement -> SEMICOLON .)
    class_FLOAT     reduce using rule 4 (statement -> SEMICOLON .)
    class_VOID      reduce using rule 4 (statement -> SEMICOLON .)
    class_UINT      reduce using rule 4 (statement -> SEMICOLON .)
    class_BOOL      reduce using rule 4 (statement -> SEMICOLON .)
    class_CHARACTER reduce using rule 4 (statement -> SEMICOLON .)
    class_String    reduce using rule 4 (statement -> SEMICOLON .)
    collection_SET  reduce using rule 4 (statement -> SEMICOLON .)
    collection_ARRAY reduce using rule 4 (statement -> SEMICOLON .)
    collection_DICT reduce using rule 4 (statement -> SEMICOLON .)
    S_FOREACH       reduce using rule 4 (statement -> SEMICOLON .)
    S_FOR           reduce using rule 4 (statement -> SEMICOLON .)
    C_APP           reduce using rule 4 (statement -> SEMICOLON .)
    D_FUNCTION      reduce using rule 4 (statement -> SEMICOLON .)
    LESS            reduce using rule 4 (statement -> SEMICOLON .)
    $end            reduce using rule 4 (statement -> SEMICOLON .)
    RBRACE          reduce using rule 4 (statement -> SEMICOLON .)
    S_CASE          reduce using rule 4 (statement -> SEMICOLON .)
    S_DEFAULT       reduce using rule 4 (statement -> SEMICOLON .)


state 5

    (5) statement -> global-const-defn .

    SEMICOLON       reduce using rule 5 (statement -> global-const-defn .)
    C_GLOBAL        reduce using rule 5 (statement -> global-const-defn .)
    D_IMPORT        reduce using rule 5 (statement -> global-const-defn .)
    C_PRAGMA        reduce using rule 5 (statement -> global-const-defn .)
    LBRACE          reduce using rule 5 (statement -> global-const-defn .)
    S_IF            reduce using rule 5 (statement -> global-const-defn .)
    S_SWITCH        reduce using rule 5 (statement -> global-const-defn .)
    E_WAIT          reduce using rule 5 (statement -> global-const-defn .)
    S_ITERATE       reduce using rule 5 (statement -> global-const-defn .)
    ID              reduce using rule 5 (statement -> global-const-defn .)
    AT              reduce using rule 5 (statement -> global-const-defn .)
    LPAREN          reduce using rule 5 (statement -> global-const-defn .)
    class_INT       reduce using rule 5 (statement -> global-const-defn .)
    class_DOUBLE    reduce using rule 5 (statement -> global-const-defn .)
    class_FLOAT     reduce using rule 5 (statement -> global-const-defn .)
    class_VOID      reduce using rule 5 (statement -> global-const-defn .)
    class_UINT      reduce using rule 5 (statement -> global-const-defn .)
    class_BOOL      reduce using rule 5 (statement -> global-const-defn .)
    class_CHARACTER reduce using rule 5 (statement -> global-const-defn .)
    class_String    reduce using rule 5 (statement -> global-const-defn .)
    collection_SET  reduce using rule 5 (statement -> global-const-defn .)
    collection_ARRAY reduce using rule 5 (statement -> global-const-defn .)
    collection_DICT reduce using rule 5 (statement -> global-const-defn .)
    S_FOREACH       reduce using rule 5 (statement -> global-const-defn .)
    S_FOR           reduce using rule 5 (statement -> global-const-defn .)
    C_APP           reduce using rule 5 (statement -> global-const-defn .)
    D_FUNCTION      reduce using rule 5 (statement -> global-const-defn .)
    LESS            reduce using rule 5 (statement -> global-const-defn .)
    $end            reduce using rule 5 (statement -> global-const-defn .)
    RBRACE          reduce using rule 5 (statement -> global-const-defn .)
    S_CASE          reduce using rule 5 (statement -> global-const-defn .)
    S_DEFAULT       reduce using rule 5 (statement -> global-const-defn .)


state 6

    (6) statement -> import-stmt .

    SEMICOLON       reduce using rule 6 (statement -> import-stmt .)
    C_GLOBAL        reduce using rule 6 (statement -> import-stmt .)
    D_IMPORT        reduce using rule 6 (statement -> import-stmt .)
    C_PRAGMA        reduce using rule 6 (statement -> import-stmt .)
    LBRACE          reduce using rule 6 (statement -> import-stmt .)
    S_IF            reduce using rule 6 (statement -> import-stmt .)
    S_SWITCH        reduce using rule 6 (statement -> import-stmt .)
    E_WAIT          reduce using rule 6 (statement -> import-stmt .)
    S_ITERATE       reduce using rule 6 (statement -> import-stmt .)
    ID              reduce using rule 6 (statement -> import-stmt .)
    AT              reduce using rule 6 (statement -> import-stmt .)
    LPAREN          reduce using rule 6 (statement -> import-stmt .)
    class_INT       reduce using rule 6 (statement -> import-stmt .)
    class_DOUBLE    reduce using rule 6 (statement -> import-stmt .)
    class_FLOAT     reduce using rule 6 (statement -> import-stmt .)
    class_VOID      reduce using rule 6 (statement -> import-stmt .)
    class_UINT      reduce using rule 6 (statement -> import-stmt .)
    class_BOOL      reduce using rule 6 (statement -> import-stmt .)
    class_CHARACTER reduce using rule 6 (statement -> import-stmt .)
    class_String    reduce using rule 6 (statement -> import-stmt .)
    collection_SET  reduce using rule 6 (statement -> import-stmt .)
    collection_ARRAY reduce using rule 6 (statement -> import-stmt .)
    collection_DICT reduce using rule 6 (statement -> import-stmt .)
    S_FOREACH       reduce using rule 6 (statement -> import-stmt .)
    S_FOR           reduce using rule 6 (statement -> import-stmt .)
    C_APP           reduce using rule 6 (statement -> import-stmt .)
    D_FUNCTION      reduce using rule 6 (statement -> import-stmt .)
    LESS            reduce using rule 6 (statement -> import-stmt .)
    $end            reduce using rule 6 (statement -> import-stmt .)
    RBRACE          reduce using rule 6 (statement -> import-stmt .)
    S_CASE          reduce using rule 6 (statement -> import-stmt .)
    S_DEFAULT       reduce using rule 6 (statement -> import-stmt .)


state 7

    (7) statement -> pragma-stmt .

    SEMICOLON       reduce using rule 7 (statement -> pragma-stmt .)
    C_GLOBAL        reduce using rule 7 (statement -> pragma-stmt .)
    D_IMPORT        reduce using rule 7 (statement -> pragma-stmt .)
    C_PRAGMA        reduce using rule 7 (statement -> pragma-stmt .)
    LBRACE          reduce using rule 7 (statement -> pragma-stmt .)
    S_IF            reduce using rule 7 (statement -> pragma-stmt .)
    S_SWITCH        reduce using rule 7 (statement -> pragma-stmt .)
    E_WAIT          reduce using rule 7 (statement -> pragma-stmt .)
    S_ITERATE       reduce using rule 7 (statement -> pragma-stmt .)
    ID              reduce using rule 7 (statement -> pragma-stmt .)
    AT              reduce using rule 7 (statement -> pragma-stmt .)
    LPAREN          reduce using rule 7 (statement -> pragma-stmt .)
    class_INT       reduce using rule 7 (statement -> pragma-stmt .)
    class_DOUBLE    reduce using rule 7 (statement -> pragma-stmt .)
    class_FLOAT     reduce using rule 7 (statement -> pragma-stmt .)
    class_VOID      reduce using rule 7 (statement -> pragma-stmt .)
    class_UINT      reduce using rule 7 (statement -> pragma-stmt .)
    class_BOOL      reduce using rule 7 (statement -> pragma-stmt .)
    class_CHARACTER reduce using rule 7 (statement -> pragma-stmt .)
    class_String    reduce using rule 7 (statement -> pragma-stmt .)
    collection_SET  reduce using rule 7 (statement -> pragma-stmt .)
    collection_ARRAY reduce using rule 7 (statement -> pragma-stmt .)
    collection_DICT reduce using rule 7 (statement -> pragma-stmt .)
    S_FOREACH       reduce using rule 7 (statement -> pragma-stmt .)
    S_FOR           reduce using rule 7 (statement -> pragma-stmt .)
    C_APP           reduce using rule 7 (statement -> pragma-stmt .)
    D_FUNCTION      reduce using rule 7 (statement -> pragma-stmt .)
    LESS            reduce using rule 7 (statement -> pragma-stmt .)
    $end            reduce using rule 7 (statement -> pragma-stmt .)
    RBRACE          reduce using rule 7 (statement -> pragma-stmt .)
    S_CASE          reduce using rule 7 (statement -> pragma-stmt .)
    S_DEFAULT       reduce using rule 7 (statement -> pragma-stmt .)


state 8

    (8) statement -> func-defn .

    SEMICOLON       reduce using rule 8 (statement -> func-defn .)
    C_GLOBAL        reduce using rule 8 (statement -> func-defn .)
    D_IMPORT        reduce using rule 8 (statement -> func-defn .)
    C_PRAGMA        reduce using rule 8 (statement -> func-defn .)
    LBRACE          reduce using rule 8 (statement -> func-defn .)
    S_IF            reduce using rule 8 (statement -> func-defn .)
    S_SWITCH        reduce using rule 8 (statement -> func-defn .)
    E_WAIT          reduce using rule 8 (statement -> func-defn .)
    S_ITERATE       reduce using rule 8 (statement -> func-defn .)
    ID              reduce using rule 8 (statement -> func-defn .)
    AT              reduce using rule 8 (statement -> func-defn .)
    LPAREN          reduce using rule 8 (statement -> func-defn .)
    class_INT       reduce using rule 8 (statement -> func-defn .)
    class_DOUBLE    reduce using rule 8 (statement -> func-defn .)
    class_FLOAT     reduce using rule 8 (statement -> func-defn .)
    class_VOID      reduce using rule 8 (statement -> func-defn .)
    class_UINT      reduce using rule 8 (statement -> func-defn .)
    class_BOOL      reduce using rule 8 (statement -> func-defn .)
    class_CHARACTER reduce using rule 8 (statement -> func-defn .)
    class_String    reduce using rule 8 (statement -> func-defn .)
    collection_SET  reduce using rule 8 (statement -> func-defn .)
    collection_ARRAY reduce using rule 8 (statement -> func-defn .)
    collection_DICT reduce using rule 8 (statement -> func-defn .)
    S_FOREACH       reduce using rule 8 (statement -> func-defn .)
    S_FOR           reduce using rule 8 (statement -> func-defn .)
    C_APP           reduce using rule 8 (statement -> func-defn .)
    D_FUNCTION      reduce using rule 8 (statement -> func-defn .)
    LESS            reduce using rule 8 (statement -> func-defn .)
    $end            reduce using rule 8 (statement -> func-defn .)
    RBRACE          reduce using rule 8 (statement -> func-defn .)
    S_CASE          reduce using rule 8 (statement -> func-defn .)
    S_DEFAULT       reduce using rule 8 (statement -> func-defn .)


state 9

    (9) statement -> block .

    SEMICOLON       reduce using rule 9 (statement -> block .)
    C_GLOBAL        reduce using rule 9 (statement -> block .)
    D_IMPORT        reduce using rule 9 (statement -> block .)
    C_PRAGMA        reduce using rule 9 (statement -> block .)
    LBRACE          reduce using rule 9 (statement -> block .)
    S_IF            reduce using rule 9 (statement -> block .)
    S_SWITCH        reduce using rule 9 (statement -> block .)
    E_WAIT          reduce using rule 9 (statement -> block .)
    S_ITERATE       reduce using rule 9 (statement -> block .)
    ID              reduce using rule 9 (statement -> block .)
    AT              reduce using rule 9 (statement -> block .)
    LPAREN          reduce using rule 9 (statement -> block .)
    class_INT       reduce using rule 9 (statement -> block .)
    class_DOUBLE    reduce using rule 9 (statement -> block .)
    class_FLOAT     reduce using rule 9 (statement -> block .)
    class_VOID      reduce using rule 9 (statement -> block .)
    class_UINT      reduce using rule 9 (statement -> block .)
    class_BOOL      reduce using rule 9 (statement -> block .)
    class_CHARACTER reduce using rule 9 (statement -> block .)
    class_String    reduce using rule 9 (statement -> block .)
    collection_SET  reduce using rule 9 (statement -> block .)
    collection_ARRAY reduce using rule 9 (statement -> block .)
    collection_DICT reduce using rule 9 (statement -> block .)
    S_FOREACH       reduce using rule 9 (statement -> block .)
    S_FOR           reduce using rule 9 (statement -> block .)
    C_APP           reduce using rule 9 (statement -> block .)
    D_FUNCTION      reduce using rule 9 (statement -> block .)
    LESS            reduce using rule 9 (statement -> block .)
    $end            reduce using rule 9 (statement -> block .)
    RBRACE          reduce using rule 9 (statement -> block .)
    S_CASE          reduce using rule 9 (statement -> block .)
    S_DEFAULT       reduce using rule 9 (statement -> block .)


state 10

    (10) statement -> if-stmt .

    SEMICOLON       reduce using rule 10 (statement -> if-stmt .)
    C_GLOBAL        reduce using rule 10 (statement -> if-stmt .)
    D_IMPORT        reduce using rule 10 (statement -> if-stmt .)
    C_PRAGMA        reduce using rule 10 (statement -> if-stmt .)
    LBRACE          reduce using rule 10 (statement -> if-stmt .)
    S_IF            reduce using rule 10 (statement -> if-stmt .)
    S_SWITCH        reduce using rule 10 (statement -> if-stmt .)
    E_WAIT          reduce using rule 10 (statement -> if-stmt .)
    S_ITERATE       reduce using rule 10 (statement -> if-stmt .)
    ID              reduce using rule 10 (statement -> if-stmt .)
    AT              reduce using rule 10 (statement -> if-stmt .)
    LPAREN          reduce using rule 10 (statement -> if-stmt .)
    class_INT       reduce using rule 10 (statement -> if-stmt .)
    class_DOUBLE    reduce using rule 10 (statement -> if-stmt .)
    class_FLOAT     reduce using rule 10 (statement -> if-stmt .)
    class_VOID      reduce using rule 10 (statement -> if-stmt .)
    class_UINT      reduce using rule 10 (statement -> if-stmt .)
    class_BOOL      reduce using rule 10 (statement -> if-stmt .)
    class_CHARACTER reduce using rule 10 (statement -> if-stmt .)
    class_String    reduce using rule 10 (statement -> if-stmt .)
    collection_SET  reduce using rule 10 (statement -> if-stmt .)
    collection_ARRAY reduce using rule 10 (statement -> if-stmt .)
    collection_DICT reduce using rule 10 (statement -> if-stmt .)
    S_FOREACH       reduce using rule 10 (statement -> if-stmt .)
    S_FOR           reduce using rule 10 (statement -> if-stmt .)
    C_APP           reduce using rule 10 (statement -> if-stmt .)
    D_FUNCTION      reduce using rule 10 (statement -> if-stmt .)
    LESS            reduce using rule 10 (statement -> if-stmt .)
    $end            reduce using rule 10 (statement -> if-stmt .)
    RBRACE          reduce using rule 10 (statement -> if-stmt .)
    S_CASE          reduce using rule 10 (statement -> if-stmt .)
    S_DEFAULT       reduce using rule 10 (statement -> if-stmt .)


state 11

    (11) statement -> switch-stmt .

    SEMICOLON       reduce using rule 11 (statement -> switch-stmt .)
    C_GLOBAL        reduce using rule 11 (statement -> switch-stmt .)
    D_IMPORT        reduce using rule 11 (statement -> switch-stmt .)
    C_PRAGMA        reduce using rule 11 (statement -> switch-stmt .)
    LBRACE          reduce using rule 11 (statement -> switch-stmt .)
    S_IF            reduce using rule 11 (statement -> switch-stmt .)
    S_SWITCH        reduce using rule 11 (statement -> switch-stmt .)
    E_WAIT          reduce using rule 11 (statement -> switch-stmt .)
    S_ITERATE       reduce using rule 11 (statement -> switch-stmt .)
    ID              reduce using rule 11 (statement -> switch-stmt .)
    AT              reduce using rule 11 (statement -> switch-stmt .)
    LPAREN          reduce using rule 11 (statement -> switch-stmt .)
    class_INT       reduce using rule 11 (statement -> switch-stmt .)
    class_DOUBLE    reduce using rule 11 (statement -> switch-stmt .)
    class_FLOAT     reduce using rule 11 (statement -> switch-stmt .)
    class_VOID      reduce using rule 11 (statement -> switch-stmt .)
    class_UINT      reduce using rule 11 (statement -> switch-stmt .)
    class_BOOL      reduce using rule 11 (statement -> switch-stmt .)
    class_CHARACTER reduce using rule 11 (statement -> switch-stmt .)
    class_String    reduce using rule 11 (statement -> switch-stmt .)
    collection_SET  reduce using rule 11 (statement -> switch-stmt .)
    collection_ARRAY reduce using rule 11 (statement -> switch-stmt .)
    collection_DICT reduce using rule 11 (statement -> switch-stmt .)
    S_FOREACH       reduce using rule 11 (statement -> switch-stmt .)
    S_FOR           reduce using rule 11 (statement -> switch-stmt .)
    C_APP           reduce using rule 11 (statement -> switch-stmt .)
    D_FUNCTION      reduce using rule 11 (statement -> switch-stmt .)
    LESS            reduce using rule 11 (statement -> switch-stmt .)
    $end            reduce using rule 11 (statement -> switch-stmt .)
    RBRACE          reduce using rule 11 (statement -> switch-stmt .)
    S_CASE          reduce using rule 11 (statement -> switch-stmt .)
    S_DEFAULT       reduce using rule 11 (statement -> switch-stmt .)


state 12

    (12) statement -> wait-stmt .

    SEMICOLON       reduce using rule 12 (statement -> wait-stmt .)
    C_GLOBAL        reduce using rule 12 (statement -> wait-stmt .)
    D_IMPORT        reduce using rule 12 (statement -> wait-stmt .)
    C_PRAGMA        reduce using rule 12 (statement -> wait-stmt .)
    LBRACE          reduce using rule 12 (statement -> wait-stmt .)
    S_IF            reduce using rule 12 (statement -> wait-stmt .)
    S_SWITCH        reduce using rule 12 (statement -> wait-stmt .)
    E_WAIT          reduce using rule 12 (statement -> wait-stmt .)
    S_ITERATE       reduce using rule 12 (statement -> wait-stmt .)
    ID              reduce using rule 12 (statement -> wait-stmt .)
    AT              reduce using rule 12 (statement -> wait-stmt .)
    LPAREN          reduce using rule 12 (statement -> wait-stmt .)
    class_INT       reduce using rule 12 (statement -> wait-stmt .)
    class_DOUBLE    reduce using rule 12 (statement -> wait-stmt .)
    class_FLOAT     reduce using rule 12 (statement -> wait-stmt .)
    class_VOID      reduce using rule 12 (statement -> wait-stmt .)
    class_UINT      reduce using rule 12 (statement -> wait-stmt .)
    class_BOOL      reduce using rule 12 (statement -> wait-stmt .)
    class_CHARACTER reduce using rule 12 (statement -> wait-stmt .)
    class_String    reduce using rule 12 (statement -> wait-stmt .)
    collection_SET  reduce using rule 12 (statement -> wait-stmt .)
    collection_ARRAY reduce using rule 12 (statement -> wait-stmt .)
    collection_DICT reduce using rule 12 (statement -> wait-stmt .)
    S_FOREACH       reduce using rule 12 (statement -> wait-stmt .)
    S_FOR           reduce using rule 12 (statement -> wait-stmt .)
    C_APP           reduce using rule 12 (statement -> wait-stmt .)
    D_FUNCTION      reduce using rule 12 (statement -> wait-stmt .)
    LESS            reduce using rule 12 (statement -> wait-stmt .)
    $end            reduce using rule 12 (statement -> wait-stmt .)
    RBRACE          reduce using rule 12 (statement -> wait-stmt .)
    S_CASE          reduce using rule 12 (statement -> wait-stmt .)
    S_DEFAULT       reduce using rule 12 (statement -> wait-stmt .)


state 13

    (13) statement -> foreach-loop .

    SEMICOLON       reduce using rule 13 (statement -> foreach-loop .)
    C_GLOBAL        reduce using rule 13 (statement -> foreach-loop .)
    D_IMPORT        reduce using rule 13 (statement -> foreach-loop .)
    C_PRAGMA        reduce using rule 13 (statement -> foreach-loop .)
    LBRACE          reduce using rule 13 (statement -> foreach-loop .)
    S_IF            reduce using rule 13 (statement -> foreach-loop .)
    S_SWITCH        reduce using rule 13 (statement -> foreach-loop .)
    E_WAIT          reduce using rule 13 (statement -> foreach-loop .)
    S_ITERATE       reduce using rule 13 (statement -> foreach-loop .)
    ID              reduce using rule 13 (statement -> foreach-loop .)
    AT              reduce using rule 13 (statement -> foreach-loop .)
    LPAREN          reduce using rule 13 (statement -> foreach-loop .)
    class_INT       reduce using rule 13 (statement -> foreach-loop .)
    class_DOUBLE    reduce using rule 13 (statement -> foreach-loop .)
    class_FLOAT     reduce using rule 13 (statement -> foreach-loop .)
    class_VOID      reduce using rule 13 (statement -> foreach-loop .)
    class_UINT      reduce using rule 13 (statement -> foreach-loop .)
    class_BOOL      reduce using rule 13 (statement -> foreach-loop .)
    class_CHARACTER reduce using rule 13 (statement -> foreach-loop .)
    class_String    reduce using rule 13 (statement -> foreach-loop .)
    collection_SET  reduce using rule 13 (statement -> foreach-loop .)
    collection_ARRAY reduce using rule 13 (statement -> foreach-loop .)
    collection_DICT reduce using rule 13 (statement -> foreach-loop .)
    S_FOREACH       reduce using rule 13 (statement -> foreach-loop .)
    S_FOR           reduce using rule 13 (statement -> foreach-loop .)
    C_APP           reduce using rule 13 (statement -> foreach-loop .)
    D_FUNCTION      reduce using rule 13 (statement -> foreach-loop .)
    LESS            reduce using rule 13 (statement -> foreach-loop .)
    $end            reduce using rule 13 (statement -> foreach-loop .)
    RBRACE          reduce using rule 13 (statement -> foreach-loop .)
    S_CASE          reduce using rule 13 (statement -> foreach-loop .)
    S_DEFAULT       reduce using rule 13 (statement -> foreach-loop .)


state 14

    (14) statement -> for-loop .

    SEMICOLON       reduce using rule 14 (statement -> for-loop .)
    C_GLOBAL        reduce using rule 14 (statement -> for-loop .)
    D_IMPORT        reduce using rule 14 (statement -> for-loop .)
    C_PRAGMA        reduce using rule 14 (statement -> for-loop .)
    LBRACE          reduce using rule 14 (statement -> for-loop .)
    S_IF            reduce using rule 14 (statement -> for-loop .)
    S_SWITCH        reduce using rule 14 (statement -> for-loop .)
    E_WAIT          reduce using rule 14 (statement -> for-loop .)
    S_ITERATE       reduce using rule 14 (statement -> for-loop .)
    ID              reduce using rule 14 (statement -> for-loop .)
    AT              reduce using rule 14 (statement -> for-loop .)
    LPAREN          reduce using rule 14 (statement -> for-loop .)
    class_INT       reduce using rule 14 (statement -> for-loop .)
    class_DOUBLE    reduce using rule 14 (statement -> for-loop .)
    class_FLOAT     reduce using rule 14 (statement -> for-loop .)
    class_VOID      reduce using rule 14 (statement -> for-loop .)
    class_UINT      reduce using rule 14 (statement -> for-loop .)
    class_BOOL      reduce using rule 14 (statement -> for-loop .)
    class_CHARACTER reduce using rule 14 (statement -> for-loop .)
    class_String    reduce using rule 14 (statement -> for-loop .)
    collection_SET  reduce using rule 14 (statement -> for-loop .)
    collection_ARRAY reduce using rule 14 (statement -> for-loop .)
    collection_DICT reduce using rule 14 (statement -> for-loop .)
    S_FOREACH       reduce using rule 14 (statement -> for-loop .)
    S_FOR           reduce using rule 14 (statement -> for-loop .)
    C_APP           reduce using rule 14 (statement -> for-loop .)
    D_FUNCTION      reduce using rule 14 (statement -> for-loop .)
    LESS            reduce using rule 14 (statement -> for-loop .)
    $end            reduce using rule 14 (statement -> for-loop .)
    RBRACE          reduce using rule 14 (statement -> for-loop .)
    S_CASE          reduce using rule 14 (statement -> for-loop .)
    S_DEFAULT       reduce using rule 14 (statement -> for-loop .)


state 15

    (15) statement -> iterate-loop .

    SEMICOLON       reduce using rule 15 (statement -> iterate-loop .)
    C_GLOBAL        reduce using rule 15 (statement -> iterate-loop .)
    D_IMPORT        reduce using rule 15 (statement -> iterate-loop .)
    C_PRAGMA        reduce using rule 15 (statement -> iterate-loop .)
    LBRACE          reduce using rule 15 (statement -> iterate-loop .)
    S_IF            reduce using rule 15 (statement -> iterate-loop .)
    S_SWITCH        reduce using rule 15 (statement -> iterate-loop .)
    E_WAIT          reduce using rule 15 (statement -> iterate-loop .)
    S_ITERATE       reduce using rule 15 (statement -> iterate-loop .)
    ID              reduce using rule 15 (statement -> iterate-loop .)
    AT              reduce using rule 15 (statement -> iterate-loop .)
    LPAREN          reduce using rule 15 (statement -> iterate-loop .)
    class_INT       reduce using rule 15 (statement -> iterate-loop .)
    class_DOUBLE    reduce using rule 15 (statement -> iterate-loop .)
    class_FLOAT     reduce using rule 15 (statement -> iterate-loop .)
    class_VOID      reduce using rule 15 (statement -> iterate-loop .)
    class_UINT      reduce using rule 15 (statement -> iterate-loop .)
    class_BOOL      reduce using rule 15 (statement -> iterate-loop .)
    class_CHARACTER reduce using rule 15 (statement -> iterate-loop .)
    class_String    reduce using rule 15 (statement -> iterate-loop .)
    collection_SET  reduce using rule 15 (statement -> iterate-loop .)
    collection_ARRAY reduce using rule 15 (statement -> iterate-loop .)
    collection_DICT reduce using rule 15 (statement -> iterate-loop .)
    S_FOREACH       reduce using rule 15 (statement -> iterate-loop .)
    S_FOR           reduce using rule 15 (statement -> iterate-loop .)
    C_APP           reduce using rule 15 (statement -> iterate-loop .)
    D_FUNCTION      reduce using rule 15 (statement -> iterate-loop .)
    LESS            reduce using rule 15 (statement -> iterate-loop .)
    $end            reduce using rule 15 (statement -> iterate-loop .)
    RBRACE          reduce using rule 15 (statement -> iterate-loop .)
    S_CASE          reduce using rule 15 (statement -> iterate-loop .)
    S_DEFAULT       reduce using rule 15 (statement -> iterate-loop .)


state 16

    (16) statement -> stmt-chain .

    SEMICOLON       reduce using rule 16 (statement -> stmt-chain .)
    C_GLOBAL        reduce using rule 16 (statement -> stmt-chain .)
    D_IMPORT        reduce using rule 16 (statement -> stmt-chain .)
    C_PRAGMA        reduce using rule 16 (statement -> stmt-chain .)
    LBRACE          reduce using rule 16 (statement -> stmt-chain .)
    S_IF            reduce using rule 16 (statement -> stmt-chain .)
    S_SWITCH        reduce using rule 16 (statement -> stmt-chain .)
    E_WAIT          reduce using rule 16 (statement -> stmt-chain .)
    S_ITERATE       reduce using rule 16 (statement -> stmt-chain .)
    ID              reduce using rule 16 (statement -> stmt-chain .)
    AT              reduce using rule 16 (statement -> stmt-chain .)
    LPAREN          reduce using rule 16 (statement -> stmt-chain .)
    class_INT       reduce using rule 16 (statement -> stmt-chain .)
    class_DOUBLE    reduce using rule 16 (statement -> stmt-chain .)
    class_FLOAT     reduce using rule 16 (statement -> stmt-chain .)
    class_VOID      reduce using rule 16 (statement -> stmt-chain .)
    class_UINT      reduce using rule 16 (statement -> stmt-chain .)
    class_BOOL      reduce using rule 16 (statement -> stmt-chain .)
    class_CHARACTER reduce using rule 16 (statement -> stmt-chain .)
    class_String    reduce using rule 16 (statement -> stmt-chain .)
    collection_SET  reduce using rule 16 (statement -> stmt-chain .)
    collection_ARRAY reduce using rule 16 (statement -> stmt-chain .)
    collection_DICT reduce using rule 16 (statement -> stmt-chain .)
    S_FOREACH       reduce using rule 16 (statement -> stmt-chain .)
    S_FOR           reduce using rule 16 (statement -> stmt-chain .)
    C_APP           reduce using rule 16 (statement -> stmt-chain .)
    D_FUNCTION      reduce using rule 16 (statement -> stmt-chain .)
    LESS            reduce using rule 16 (statement -> stmt-chain .)
    $end            reduce using rule 16 (statement -> stmt-chain .)
    RBRACE          reduce using rule 16 (statement -> stmt-chain .)
    S_CASE          reduce using rule 16 (statement -> stmt-chain .)
    S_DEFAULT       reduce using rule 16 (statement -> stmt-chain .)


state 17

    (17) statement -> update-stmt .

    SEMICOLON       reduce using rule 17 (statement -> update-stmt .)
    C_GLOBAL        reduce using rule 17 (statement -> update-stmt .)
    D_IMPORT        reduce using rule 17 (statement -> update-stmt .)
    C_PRAGMA        reduce using rule 17 (statement -> update-stmt .)
    LBRACE          reduce using rule 17 (statement -> update-stmt .)
    S_IF            reduce using rule 17 (statement -> update-stmt .)
    S_SWITCH        reduce using rule 17 (statement -> update-stmt .)
    E_WAIT          reduce using rule 17 (statement -> update-stmt .)
    S_ITERATE       reduce using rule 17 (statement -> update-stmt .)
    ID              reduce using rule 17 (statement -> update-stmt .)
    AT              reduce using rule 17 (statement -> update-stmt .)
    LPAREN          reduce using rule 17 (statement -> update-stmt .)
    class_INT       reduce using rule 17 (statement -> update-stmt .)
    class_DOUBLE    reduce using rule 17 (statement -> update-stmt .)
    class_FLOAT     reduce using rule 17 (statement -> update-stmt .)
    class_VOID      reduce using rule 17 (statement -> update-stmt .)
    class_UINT      reduce using rule 17 (statement -> update-stmt .)
    class_BOOL      reduce using rule 17 (statement -> update-stmt .)
    class_CHARACTER reduce using rule 17 (statement -> update-stmt .)
    class_String    reduce using rule 17 (statement -> update-stmt .)
    collection_SET  reduce using rule 17 (statement -> update-stmt .)
    collection_ARRAY reduce using rule 17 (statement -> update-stmt .)
    collection_DICT reduce using rule 17 (statement -> update-stmt .)
    S_FOREACH       reduce using rule 17 (statement -> update-stmt .)
    S_FOR           reduce using rule 17 (statement -> update-stmt .)
    C_APP           reduce using rule 17 (statement -> update-stmt .)
    D_FUNCTION      reduce using rule 17 (statement -> update-stmt .)
    LESS            reduce using rule 17 (statement -> update-stmt .)
    $end            reduce using rule 17 (statement -> update-stmt .)
    RBRACE          reduce using rule 17 (statement -> update-stmt .)
    S_CASE          reduce using rule 17 (statement -> update-stmt .)
    S_DEFAULT       reduce using rule 17 (statement -> update-stmt .)


state 18

    (18) global-const-defn -> C_GLOBAL . C_CONST var-decl SEMICOLON

    C_CONST         shift and go to state 57


state 19

    (91) chainable-stmt -> var-decl .

    SEMICOLON       reduce using rule 91 (chainable-stmt -> var-decl .)
    ARROW           reduce using rule 91 (chainable-stmt -> var-decl .)


state 20

    (19) import-stmt -> D_IMPORT . module-path SEMICOLON
    (20) import-stmt -> D_IMPORT . STR_LITERAL SEMICOLON
    (21) module-path -> . ID path-star

    STR_LITERAL     shift and go to state 59
    ID              shift and go to state 60

    module-path                    shift and go to state 58

state 21

    (24) pragma-stmt -> C_PRAGMA . ID expr SEMICOLON

    ID              shift and go to state 61


state 22

    (223) var-name -> ID .
    (221) type-name -> ID .

  ! reduce/reduce conflict for LESS resolved using rule 221 (type-name -> ID .)
    LBRACKET        reduce using rule 223 (var-name -> ID .)
    DOT             reduce using rule 223 (var-name -> ID .)
    SEMICOLON       reduce using rule 223 (var-name -> ID .)
    ARROW           reduce using rule 223 (var-name -> ID .)
    COMMA           reduce using rule 223 (var-name -> ID .)
    ASSIGN          reduce using rule 223 (var-name -> ID .)
    PLUS_AS         reduce using rule 223 (var-name -> ID .)
    LESS            reduce using rule 221 (type-name -> ID .)
    ID              reduce using rule 221 (type-name -> ID .)

  ! LESS            [ reduce using rule 223 (var-name -> ID .) ]


state 23

    (25) func-defn -> swift-func-defn .

    SEMICOLON       reduce using rule 25 (func-defn -> swift-func-defn .)
    C_GLOBAL        reduce using rule 25 (func-defn -> swift-func-defn .)
    D_IMPORT        reduce using rule 25 (func-defn -> swift-func-defn .)
    C_PRAGMA        reduce using rule 25 (func-defn -> swift-func-defn .)
    LBRACE          reduce using rule 25 (func-defn -> swift-func-defn .)
    S_IF            reduce using rule 25 (func-defn -> swift-func-defn .)
    S_SWITCH        reduce using rule 25 (func-defn -> swift-func-defn .)
    E_WAIT          reduce using rule 25 (func-defn -> swift-func-defn .)
    S_ITERATE       reduce using rule 25 (func-defn -> swift-func-defn .)
    ID              reduce using rule 25 (func-defn -> swift-func-defn .)
    AT              reduce using rule 25 (func-defn -> swift-func-defn .)
    LPAREN          reduce using rule 25 (func-defn -> swift-func-defn .)
    class_INT       reduce using rule 25 (func-defn -> swift-func-defn .)
    class_DOUBLE    reduce using rule 25 (func-defn -> swift-func-defn .)
    class_FLOAT     reduce using rule 25 (func-defn -> swift-func-defn .)
    class_VOID      reduce using rule 25 (func-defn -> swift-func-defn .)
    class_UINT      reduce using rule 25 (func-defn -> swift-func-defn .)
    class_BOOL      reduce using rule 25 (func-defn -> swift-func-defn .)
    class_CHARACTER reduce using rule 25 (func-defn -> swift-func-defn .)
    class_String    reduce using rule 25 (func-defn -> swift-func-defn .)
    collection_SET  reduce using rule 25 (func-defn -> swift-func-defn .)
    collection_ARRAY reduce using rule 25 (func-defn -> swift-func-defn .)
    collection_DICT reduce using rule 25 (func-defn -> swift-func-defn .)
    S_FOREACH       reduce using rule 25 (func-defn -> swift-func-defn .)
    S_FOR           reduce using rule 25 (func-defn -> swift-func-defn .)
    C_APP           reduce using rule 25 (func-defn -> swift-func-defn .)
    D_FUNCTION      reduce using rule 25 (func-defn -> swift-func-defn .)
    LESS            reduce using rule 25 (func-defn -> swift-func-defn .)
    $end            reduce using rule 25 (func-defn -> swift-func-defn .)
    RBRACE          reduce using rule 25 (func-defn -> swift-func-defn .)
    S_CASE          reduce using rule 25 (func-defn -> swift-func-defn .)
    S_DEFAULT       reduce using rule 25 (func-defn -> swift-func-defn .)


state 24

    (26) func-defn -> app-func-defn .

    SEMICOLON       reduce using rule 26 (func-defn -> app-func-defn .)
    C_GLOBAL        reduce using rule 26 (func-defn -> app-func-defn .)
    D_IMPORT        reduce using rule 26 (func-defn -> app-func-defn .)
    C_PRAGMA        reduce using rule 26 (func-defn -> app-func-defn .)
    LBRACE          reduce using rule 26 (func-defn -> app-func-defn .)
    S_IF            reduce using rule 26 (func-defn -> app-func-defn .)
    S_SWITCH        reduce using rule 26 (func-defn -> app-func-defn .)
    E_WAIT          reduce using rule 26 (func-defn -> app-func-defn .)
    S_ITERATE       reduce using rule 26 (func-defn -> app-func-defn .)
    ID              reduce using rule 26 (func-defn -> app-func-defn .)
    AT              reduce using rule 26 (func-defn -> app-func-defn .)
    LPAREN          reduce using rule 26 (func-defn -> app-func-defn .)
    class_INT       reduce using rule 26 (func-defn -> app-func-defn .)
    class_DOUBLE    reduce using rule 26 (func-defn -> app-func-defn .)
    class_FLOAT     reduce using rule 26 (func-defn -> app-func-defn .)
    class_VOID      reduce using rule 26 (func-defn -> app-func-defn .)
    class_UINT      reduce using rule 26 (func-defn -> app-func-defn .)
    class_BOOL      reduce using rule 26 (func-defn -> app-func-defn .)
    class_CHARACTER reduce using rule 26 (func-defn -> app-func-defn .)
    class_String    reduce using rule 26 (func-defn -> app-func-defn .)
    collection_SET  reduce using rule 26 (func-defn -> app-func-defn .)
    collection_ARRAY reduce using rule 26 (func-defn -> app-func-defn .)
    collection_DICT reduce using rule 26 (func-defn -> app-func-defn .)
    S_FOREACH       reduce using rule 26 (func-defn -> app-func-defn .)
    S_FOR           reduce using rule 26 (func-defn -> app-func-defn .)
    C_APP           reduce using rule 26 (func-defn -> app-func-defn .)
    D_FUNCTION      reduce using rule 26 (func-defn -> app-func-defn .)
    LESS            reduce using rule 26 (func-defn -> app-func-defn .)
    $end            reduce using rule 26 (func-defn -> app-func-defn .)
    RBRACE          reduce using rule 26 (func-defn -> app-func-defn .)
    S_CASE          reduce using rule 26 (func-defn -> app-func-defn .)
    S_DEFAULT       reduce using rule 26 (func-defn -> app-func-defn .)


state 25

    (27) func-defn -> foreign-func-defn .

    SEMICOLON       reduce using rule 27 (func-defn -> foreign-func-defn .)
    C_GLOBAL        reduce using rule 27 (func-defn -> foreign-func-defn .)
    D_IMPORT        reduce using rule 27 (func-defn -> foreign-func-defn .)
    C_PRAGMA        reduce using rule 27 (func-defn -> foreign-func-defn .)
    LBRACE          reduce using rule 27 (func-defn -> foreign-func-defn .)
    S_IF            reduce using rule 27 (func-defn -> foreign-func-defn .)
    S_SWITCH        reduce using rule 27 (func-defn -> foreign-func-defn .)
    E_WAIT          reduce using rule 27 (func-defn -> foreign-func-defn .)
    S_ITERATE       reduce using rule 27 (func-defn -> foreign-func-defn .)
    ID              reduce using rule 27 (func-defn -> foreign-func-defn .)
    AT              reduce using rule 27 (func-defn -> foreign-func-defn .)
    LPAREN          reduce using rule 27 (func-defn -> foreign-func-defn .)
    class_INT       reduce using rule 27 (func-defn -> foreign-func-defn .)
    class_DOUBLE    reduce using rule 27 (func-defn -> foreign-func-defn .)
    class_FLOAT     reduce using rule 27 (func-defn -> foreign-func-defn .)
    class_VOID      reduce using rule 27 (func-defn -> foreign-func-defn .)
    class_UINT      reduce using rule 27 (func-defn -> foreign-func-defn .)
    class_BOOL      reduce using rule 27 (func-defn -> foreign-func-defn .)
    class_CHARACTER reduce using rule 27 (func-defn -> foreign-func-defn .)
    class_String    reduce using rule 27 (func-defn -> foreign-func-defn .)
    collection_SET  reduce using rule 27 (func-defn -> foreign-func-defn .)
    collection_ARRAY reduce using rule 27 (func-defn -> foreign-func-defn .)
    collection_DICT reduce using rule 27 (func-defn -> foreign-func-defn .)
    S_FOREACH       reduce using rule 27 (func-defn -> foreign-func-defn .)
    S_FOR           reduce using rule 27 (func-defn -> foreign-func-defn .)
    C_APP           reduce using rule 27 (func-defn -> foreign-func-defn .)
    D_FUNCTION      reduce using rule 27 (func-defn -> foreign-func-defn .)
    LESS            reduce using rule 27 (func-defn -> foreign-func-defn .)
    $end            reduce using rule 27 (func-defn -> foreign-func-defn .)
    RBRACE          reduce using rule 27 (func-defn -> foreign-func-defn .)
    S_CASE          reduce using rule 27 (func-defn -> foreign-func-defn .)
    S_DEFAULT       reduce using rule 27 (func-defn -> foreign-func-defn .)


state 26

    (85) block -> LBRACE . translation-unit RBRACE
    (1) translation-unit -> . statement-star
    (2) statement-star -> .
    (3) statement-star -> . statement statement-star
    (4) statement -> . SEMICOLON
    (5) statement -> . global-const-defn
    (6) statement -> . import-stmt
    (7) statement -> . pragma-stmt
    (8) statement -> . func-defn
    (9) statement -> . block
    (10) statement -> . if-stmt
    (11) statement -> . switch-stmt
    (12) statement -> . wait-stmt
    (13) statement -> . foreach-loop
    (14) statement -> . for-loop
    (15) statement -> . iterate-loop
    (16) statement -> . stmt-chain
    (17) statement -> . update-stmt
    (18) global-const-defn -> . C_GLOBAL C_CONST var-decl SEMICOLON
    (19) import-stmt -> . D_IMPORT module-path SEMICOLON
    (20) import-stmt -> . D_IMPORT STR_LITERAL SEMICOLON
    (24) pragma-stmt -> . C_PRAGMA ID expr SEMICOLON
    (25) func-defn -> . swift-func-defn
    (26) func-defn -> . app-func-defn
    (27) func-defn -> . foreign-func-defn
    (85) block -> . LBRACE translation-unit RBRACE
    (101) if-stmt -> . S_IF LPAREN expr RPAREN block opt-else-block
    (104) switch-stmt -> . S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE
    (111) wait-stmt -> . E_WAIT opt-deep LPAREN expr-list RPAREN block
    (114) foreach-loop -> . annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block
    (117) for-loop -> . annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
    (128) iterate-loop -> . S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN
    (86) stmt-chain -> . chainable-stmt semicolon-or-arrow statement
    (100) update-stmt -> . var-name LESS ID GREATER UPD expr SEMICOLON
    (46) swift-func-defn -> . annotation-star func-hdr ARROW block
    (49) app-func-defn -> . annotation-star C_APP func-hdr LBRACE app-body RBRACE
    (60) foreign-func-defn -> . annotation-star func-hdr foreign-func-body
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (89) chainable-stmt -> . var-name
    (90) chainable-stmt -> . func-call
    (91) chainable-stmt -> . var-decl
    (92) chainable-stmt -> . assignment
    (223) var-name -> . ID
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (68) var-decl -> . type-prefix var-decl-rest
    (93) assignment -> . lval-or-paren-lval assign-or-plusas expr-list
    (76) type-prefix -> . type-name
    (77) type-prefix -> . param-type
    (98) lval-or-paren-lval -> . lval-list
    (99) lval-or-paren-lval -> . LPAREN lval-list RPAREN
    (210) type-name -> . class_INT
    (211) type-name -> . class_DOUBLE
    (212) type-name -> . class_FLOAT
    (213) type-name -> . class_VOID
    (214) type-name -> . class_UINT
    (215) type-name -> . class_BOOL
    (216) type-name -> . class_CHARACTER
    (217) type-name -> . class_String
    (218) type-name -> . collection_SET
    (219) type-name -> . collection_ARRAY
    (220) type-name -> . collection_DICT
    (221) type-name -> . ID
    (78) param-type -> . type-name LESS standalone-type GREATER
    (225) lval-list -> . lval-expr lval-expr-star
    (228) lval-expr -> . var-name subscript-star

  ! shift/reduce conflict for LPAREN resolved as shift
    RBRACE          reduce using rule 2 (statement-star -> .)
    SEMICOLON       shift and go to state 4
    C_GLOBAL        shift and go to state 18
    D_IMPORT        shift and go to state 20
    C_PRAGMA        shift and go to state 21
    LBRACE          shift and go to state 26
    S_IF            shift and go to state 27
    S_SWITCH        shift and go to state 29
    E_WAIT          shift and go to state 30
    S_ITERATE       shift and go to state 33
    S_FOREACH       reduce using rule 47 (annotation-star -> .)
    S_FOR           reduce using rule 47 (annotation-star -> .)
    C_APP           reduce using rule 47 (annotation-star -> .)
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LESS            reduce using rule 47 (annotation-star -> .)
    ID              shift and go to state 22
    AT              shift and go to state 38
    LPAREN          shift and go to state 28
    class_INT       shift and go to state 44
    class_DOUBLE    shift and go to state 45
    class_FLOAT     shift and go to state 46
    class_VOID      shift and go to state 47
    class_UINT      shift and go to state 48
    class_BOOL      shift and go to state 49
    class_CHARACTER shift and go to state 50
    class_String    shift and go to state 51
    collection_SET  shift and go to state 52
    collection_ARRAY shift and go to state 53
    collection_DICT shift and go to state 54

  ! LPAREN          [ reduce using rule 47 (annotation-star -> .) ]

    translation-unit               shift and go to state 62
    statement-star                 shift and go to state 2
    statement                      shift and go to state 3
    global-const-defn              shift and go to state 5
    import-stmt                    shift and go to state 6
    pragma-stmt                    shift and go to state 7
    func-defn                      shift and go to state 8
    block                          shift and go to state 9
    if-stmt                        shift and go to state 10
    switch-stmt                    shift and go to state 11
    wait-stmt                      shift and go to state 12
    foreach-loop                   shift and go to state 13
    for-loop                       shift and go to state 14
    iterate-loop                   shift and go to state 15
    stmt-chain                     shift and go to state 16
    update-stmt                    shift and go to state 17
    var-decl                       shift and go to state 19
    swift-func-defn                shift and go to state 23
    app-func-defn                  shift and go to state 24
    foreign-func-defn              shift and go to state 25
    annotation-star                shift and go to state 31
    var-name                       shift and go to state 32
    chainable-stmt                 shift and go to state 34
    annotation                     shift and go to state 35
    func-call                      shift and go to state 36
    assignment                     shift and go to state 37
    type-prefix                    shift and go to state 39
    lval-or-paren-lval             shift and go to state 40
    type-name                      shift and go to state 41
    param-type                     shift and go to state 42
    lval-list                      shift and go to state 43
    lval-expr                      shift and go to state 55

state 27

    (101) if-stmt -> S_IF . LPAREN expr RPAREN block opt-else-block

    LPAREN          shift and go to state 63


state 28

    (99) lval-or-paren-lval -> LPAREN . lval-list RPAREN
    (225) lval-list -> . lval-expr lval-expr-star
    (228) lval-expr -> . var-name subscript-star
    (223) var-name -> . ID

    ID              shift and go to state 66

    lval-list                      shift and go to state 64
    lval-expr                      shift and go to state 55
    var-name                       shift and go to state 65

state 29

    (104) switch-stmt -> S_SWITCH . LPAREN expr RPAREN LBRACE case-star opt-default RBRACE

    LPAREN          shift and go to state 67


state 30

    (111) wait-stmt -> E_WAIT . opt-deep LPAREN expr-list RPAREN block
    (112) opt-deep -> .
    (113) opt-deep -> . E_DEEP

    LPAREN          reduce using rule 112 (opt-deep -> .)
    E_DEEP          shift and go to state 69

    opt-deep                       shift and go to state 68

state 31

    (114) foreach-loop -> annotation-star . S_FOREACH var-name opt-comma-var-name S_IN expr block
    (117) for-loop -> annotation-star . S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
    (46) swift-func-defn -> annotation-star . func-hdr ARROW block
    (49) app-func-defn -> annotation-star . C_APP func-hdr LBRACE app-body RBRACE
    (60) foreign-func-defn -> annotation-star . func-hdr foreign-func-body
    (172) func-call -> annotation-star . func-name LPAREN func-call-arg-list RPAREN
    (28) func-hdr -> . type-params formal-arg-list func-name empty-or-arg-list
    (224) func-name -> . D_FUNCTION ID
    (31) type-params -> .
    (32) type-params -> . LESS var-name comma-name-star GREATER

  ! shift/reduce conflict for D_FUNCTION resolved as shift
    S_FOREACH       shift and go to state 70
    S_FOR           shift and go to state 71
    C_APP           shift and go to state 73
    D_FUNCTION      shift and go to state 76
    LPAREN          reduce using rule 31 (type-params -> .)
    LESS            shift and go to state 77

  ! D_FUNCTION      [ reduce using rule 31 (type-params -> .) ]

    func-hdr                       shift and go to state 72
    func-name                      shift and go to state 74
    type-params                    shift and go to state 75

state 32

    (100) update-stmt -> var-name . LESS ID GREATER UPD expr SEMICOLON
    (89) chainable-stmt -> var-name .
    (228) lval-expr -> var-name . subscript-star
    (229) subscript-star -> .
    (230) subscript-star -> . array-subscript subscript-star
    (231) subscript-star -> . struct-subscript subscript-star
    (164) array-subscript -> . LBRACKET expr RBRACKET
    (165) struct-subscript -> . DOT ID

    LESS            shift and go to state 78
    SEMICOLON       reduce using rule 89 (chainable-stmt -> var-name .)
    ARROW           reduce using rule 89 (chainable-stmt -> var-name .)
    COMMA           reduce using rule 229 (subscript-star -> .)
    ASSIGN          reduce using rule 229 (subscript-star -> .)
    PLUS_AS         reduce using rule 229 (subscript-star -> .)
    LBRACKET        shift and go to state 82
    DOT             shift and go to state 83

    subscript-star                 shift and go to state 79
    array-subscript                shift and go to state 80
    struct-subscript               shift and go to state 81

state 33

    (128) iterate-loop -> S_ITERATE . var-name block S_UNTIL LPAREN expr RPAREN
    (223) var-name -> . ID

    ID              shift and go to state 66

    var-name                       shift and go to state 84

state 34

    (86) stmt-chain -> chainable-stmt . semicolon-or-arrow statement
    (87) semicolon-or-arrow -> . SEMICOLON
    (88) semicolon-or-arrow -> . ARROW

    SEMICOLON       shift and go to state 86
    ARROW           shift and go to state 87

    semicolon-or-arrow             shift and go to state 85

state 35

    (48) annotation-star -> annotation . annotation-star
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    S_FOREACH       reduce using rule 47 (annotation-star -> .)
    S_FOR           reduce using rule 47 (annotation-star -> .)
    C_APP           reduce using rule 47 (annotation-star -> .)
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LESS            reduce using rule 47 (annotation-star -> .)
    LPAREN          reduce using rule 47 (annotation-star -> .)
    AT              shift and go to state 38

    annotation                     shift and go to state 35
    annotation-star                shift and go to state 88

state 36

    (90) chainable-stmt -> func-call .

    SEMICOLON       reduce using rule 90 (chainable-stmt -> func-call .)
    ARROW           reduce using rule 90 (chainable-stmt -> func-call .)


state 37

    (92) chainable-stmt -> assignment .

    SEMICOLON       reduce using rule 92 (chainable-stmt -> assignment .)
    ARROW           reduce using rule 92 (chainable-stmt -> assignment .)


state 38

    (196) annotation -> AT . ID
    (197) annotation -> AT . kw-expr
    (198) kw-expr -> . ID ASSIGN expr

    ID              shift and go to state 89

    kw-expr                        shift and go to state 90

state 39

    (68) var-decl -> type-prefix . var-decl-rest
    (71) var-decl-rest -> . var-name type-suffix empty-or-var-mappign empty-or-assign-expr
    (223) var-name -> . ID

    ID              shift and go to state 66

    var-decl-rest                  shift and go to state 91
    var-name                       shift and go to state 92

state 40

    (93) assignment -> lval-or-paren-lval . assign-or-plusas expr-list
    (96) assign-or-plusas -> . ASSIGN
    (97) assign-or-plusas -> . PLUS_AS

    ASSIGN          shift and go to state 94
    PLUS_AS         shift and go to state 95

    assign-or-plusas               shift and go to state 93

state 41

    (76) type-prefix -> type-name .
    (78) param-type -> type-name . LESS standalone-type GREATER

    ID              reduce using rule 76 (type-prefix -> type-name .)
    LBRACKET        reduce using rule 76 (type-prefix -> type-name .)
    GREATER         reduce using rule 76 (type-prefix -> type-name .)
    RANGE           reduce using rule 76 (type-prefix -> type-name .)
    RBRACKET        reduce using rule 76 (type-prefix -> type-name .)
    LESS            shift and go to state 96


state 42

    (77) type-prefix -> param-type .

    ID              reduce using rule 77 (type-prefix -> param-type .)
    LBRACKET        reduce using rule 77 (type-prefix -> param-type .)
    GREATER         reduce using rule 77 (type-prefix -> param-type .)
    RANGE           reduce using rule 77 (type-prefix -> param-type .)
    RBRACKET        reduce using rule 77 (type-prefix -> param-type .)


state 43

    (98) lval-or-paren-lval -> lval-list .

    ASSIGN          reduce using rule 98 (lval-or-paren-lval -> lval-list .)
    PLUS_AS         reduce using rule 98 (lval-or-paren-lval -> lval-list .)


state 44

    (210) type-name -> class_INT .

    LESS            reduce using rule 210 (type-name -> class_INT .)
    ID              reduce using rule 210 (type-name -> class_INT .)
    LBRACKET        reduce using rule 210 (type-name -> class_INT .)
    GREATER         reduce using rule 210 (type-name -> class_INT .)
    RANGE           reduce using rule 210 (type-name -> class_INT .)
    RBRACKET        reduce using rule 210 (type-name -> class_INT .)


state 45

    (211) type-name -> class_DOUBLE .

    LESS            reduce using rule 211 (type-name -> class_DOUBLE .)
    ID              reduce using rule 211 (type-name -> class_DOUBLE .)
    LBRACKET        reduce using rule 211 (type-name -> class_DOUBLE .)
    GREATER         reduce using rule 211 (type-name -> class_DOUBLE .)
    RANGE           reduce using rule 211 (type-name -> class_DOUBLE .)
    RBRACKET        reduce using rule 211 (type-name -> class_DOUBLE .)


state 46

    (212) type-name -> class_FLOAT .

    LESS            reduce using rule 212 (type-name -> class_FLOAT .)
    ID              reduce using rule 212 (type-name -> class_FLOAT .)
    LBRACKET        reduce using rule 212 (type-name -> class_FLOAT .)
    GREATER         reduce using rule 212 (type-name -> class_FLOAT .)
    RANGE           reduce using rule 212 (type-name -> class_FLOAT .)
    RBRACKET        reduce using rule 212 (type-name -> class_FLOAT .)


state 47

    (213) type-name -> class_VOID .

    LESS            reduce using rule 213 (type-name -> class_VOID .)
    ID              reduce using rule 213 (type-name -> class_VOID .)
    LBRACKET        reduce using rule 213 (type-name -> class_VOID .)
    GREATER         reduce using rule 213 (type-name -> class_VOID .)
    RANGE           reduce using rule 213 (type-name -> class_VOID .)
    RBRACKET        reduce using rule 213 (type-name -> class_VOID .)


state 48

    (214) type-name -> class_UINT .

    LESS            reduce using rule 214 (type-name -> class_UINT .)
    ID              reduce using rule 214 (type-name -> class_UINT .)
    LBRACKET        reduce using rule 214 (type-name -> class_UINT .)
    GREATER         reduce using rule 214 (type-name -> class_UINT .)
    RANGE           reduce using rule 214 (type-name -> class_UINT .)
    RBRACKET        reduce using rule 214 (type-name -> class_UINT .)


state 49

    (215) type-name -> class_BOOL .

    LESS            reduce using rule 215 (type-name -> class_BOOL .)
    ID              reduce using rule 215 (type-name -> class_BOOL .)
    LBRACKET        reduce using rule 215 (type-name -> class_BOOL .)
    GREATER         reduce using rule 215 (type-name -> class_BOOL .)
    RANGE           reduce using rule 215 (type-name -> class_BOOL .)
    RBRACKET        reduce using rule 215 (type-name -> class_BOOL .)


state 50

    (216) type-name -> class_CHARACTER .

    LESS            reduce using rule 216 (type-name -> class_CHARACTER .)
    ID              reduce using rule 216 (type-name -> class_CHARACTER .)
    LBRACKET        reduce using rule 216 (type-name -> class_CHARACTER .)
    GREATER         reduce using rule 216 (type-name -> class_CHARACTER .)
    RANGE           reduce using rule 216 (type-name -> class_CHARACTER .)
    RBRACKET        reduce using rule 216 (type-name -> class_CHARACTER .)


state 51

    (217) type-name -> class_String .

    LESS            reduce using rule 217 (type-name -> class_String .)
    ID              reduce using rule 217 (type-name -> class_String .)
    LBRACKET        reduce using rule 217 (type-name -> class_String .)
    GREATER         reduce using rule 217 (type-name -> class_String .)
    RANGE           reduce using rule 217 (type-name -> class_String .)
    RBRACKET        reduce using rule 217 (type-name -> class_String .)


state 52

    (218) type-name -> collection_SET .

    LESS            reduce using rule 218 (type-name -> collection_SET .)
    ID              reduce using rule 218 (type-name -> collection_SET .)
    LBRACKET        reduce using rule 218 (type-name -> collection_SET .)
    GREATER         reduce using rule 218 (type-name -> collection_SET .)
    RANGE           reduce using rule 218 (type-name -> collection_SET .)
    RBRACKET        reduce using rule 218 (type-name -> collection_SET .)


state 53

    (219) type-name -> collection_ARRAY .

    LESS            reduce using rule 219 (type-name -> collection_ARRAY .)
    ID              reduce using rule 219 (type-name -> collection_ARRAY .)
    LBRACKET        reduce using rule 219 (type-name -> collection_ARRAY .)
    GREATER         reduce using rule 219 (type-name -> collection_ARRAY .)
    RANGE           reduce using rule 219 (type-name -> collection_ARRAY .)
    RBRACKET        reduce using rule 219 (type-name -> collection_ARRAY .)


state 54

    (220) type-name -> collection_DICT .

    LESS            reduce using rule 220 (type-name -> collection_DICT .)
    ID              reduce using rule 220 (type-name -> collection_DICT .)
    LBRACKET        reduce using rule 220 (type-name -> collection_DICT .)
    GREATER         reduce using rule 220 (type-name -> collection_DICT .)
    RANGE           reduce using rule 220 (type-name -> collection_DICT .)
    RBRACKET        reduce using rule 220 (type-name -> collection_DICT .)


state 55

    (225) lval-list -> lval-expr . lval-expr-star
    (226) lval-expr-star -> .
    (227) lval-expr-star -> . COMMA lval-expr lval-expr-star

    ASSIGN          reduce using rule 226 (lval-expr-star -> .)
    PLUS_AS         reduce using rule 226 (lval-expr-star -> .)
    RPAREN          reduce using rule 226 (lval-expr-star -> .)
    COMMA           shift and go to state 98

    lval-expr-star                 shift and go to state 97

state 56

    (3) statement-star -> statement statement-star .

    $end            reduce using rule 3 (statement-star -> statement statement-star .)
    RBRACE          reduce using rule 3 (statement-star -> statement statement-star .)
    S_CASE          reduce using rule 3 (statement-star -> statement statement-star .)
    S_DEFAULT       reduce using rule 3 (statement-star -> statement statement-star .)


state 57

    (18) global-const-defn -> C_GLOBAL C_CONST . var-decl SEMICOLON
    (68) var-decl -> . type-prefix var-decl-rest
    (76) type-prefix -> . type-name
    (77) type-prefix -> . param-type
    (210) type-name -> . class_INT
    (211) type-name -> . class_DOUBLE
    (212) type-name -> . class_FLOAT
    (213) type-name -> . class_VOID
    (214) type-name -> . class_UINT
    (215) type-name -> . class_BOOL
    (216) type-name -> . class_CHARACTER
    (217) type-name -> . class_String
    (218) type-name -> . collection_SET
    (219) type-name -> . collection_ARRAY
    (220) type-name -> . collection_DICT
    (221) type-name -> . ID
    (78) param-type -> . type-name LESS standalone-type GREATER

    class_INT       shift and go to state 44
    class_DOUBLE    shift and go to state 45
    class_FLOAT     shift and go to state 46
    class_VOID      shift and go to state 47
    class_UINT      shift and go to state 48
    class_BOOL      shift and go to state 49
    class_CHARACTER shift and go to state 50
    class_String    shift and go to state 51
    collection_SET  shift and go to state 52
    collection_ARRAY shift and go to state 53
    collection_DICT shift and go to state 54
    ID              shift and go to state 100

    var-decl                       shift and go to state 99
    type-prefix                    shift and go to state 39
    type-name                      shift and go to state 41
    param-type                     shift and go to state 42

state 58

    (19) import-stmt -> D_IMPORT module-path . SEMICOLON

    SEMICOLON       shift and go to state 101


state 59

    (20) import-stmt -> D_IMPORT STR_LITERAL . SEMICOLON

    SEMICOLON       shift and go to state 102


state 60

    (21) module-path -> ID . path-star
    (22) path-star -> .
    (23) path-star -> . DOT ID path-star

    SEMICOLON       reduce using rule 22 (path-star -> .)
    DOT             shift and go to state 104

    path-star                      shift and go to state 103

state 61

    (24) pragma-stmt -> C_PRAGMA ID . expr SEMICOLON
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 105
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 62

    (85) block -> LBRACE translation-unit . RBRACE

    RBRACE          shift and go to state 140


state 63

    (101) if-stmt -> S_IF LPAREN . expr RPAREN block opt-else-block
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 141
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 64

    (99) lval-or-paren-lval -> LPAREN lval-list . RPAREN

    RPAREN          shift and go to state 142


state 65

    (228) lval-expr -> var-name . subscript-star
    (229) subscript-star -> .
    (230) subscript-star -> . array-subscript subscript-star
    (231) subscript-star -> . struct-subscript subscript-star
    (164) array-subscript -> . LBRACKET expr RBRACKET
    (165) struct-subscript -> . DOT ID

    COMMA           reduce using rule 229 (subscript-star -> .)
    RPAREN          reduce using rule 229 (subscript-star -> .)
    ASSIGN          reduce using rule 229 (subscript-star -> .)
    PLUS_AS         reduce using rule 229 (subscript-star -> .)
    LBRACKET        shift and go to state 82
    DOT             shift and go to state 83

    subscript-star                 shift and go to state 79
    array-subscript                shift and go to state 80
    struct-subscript               shift and go to state 81

state 66

    (223) var-name -> ID .

    LBRACKET        reduce using rule 223 (var-name -> ID .)
    DOT             reduce using rule 223 (var-name -> ID .)
    COMMA           reduce using rule 223 (var-name -> ID .)
    RPAREN          reduce using rule 223 (var-name -> ID .)
    LBRACE          reduce using rule 223 (var-name -> ID .)
    LESS            reduce using rule 223 (var-name -> ID .)
    ASSIGN          reduce using rule 223 (var-name -> ID .)
    SEMICOLON       reduce using rule 223 (var-name -> ID .)
    ARROW           reduce using rule 223 (var-name -> ID .)
    MULT            reduce using rule 223 (var-name -> ID .)
    DIV             reduce using rule 223 (var-name -> ID .)
    MULTPER         reduce using rule 223 (var-name -> ID .)
    DOUBLEPER       reduce using rule 223 (var-name -> ID .)
    MOD             reduce using rule 223 (var-name -> ID .)
    PLUS            reduce using rule 223 (var-name -> ID .)
    MINUS           reduce using rule 223 (var-name -> ID .)
    LESS_EQ         reduce using rule 223 (var-name -> ID .)
    EQUAL           reduce using rule 223 (var-name -> ID .)
    GREATER         reduce using rule 223 (var-name -> ID .)
    GREATER_EQ      reduce using rule 223 (var-name -> ID .)
    NOT_EQUAL       reduce using rule 223 (var-name -> ID .)
    LOG_AND         reduce using rule 223 (var-name -> ID .)
    LOG_OR          reduce using rule 223 (var-name -> ID .)
    S_IN            reduce using rule 223 (var-name -> ID .)
    RBRACKET        reduce using rule 223 (var-name -> ID .)
    PLUS_AS         reduce using rule 223 (var-name -> ID .)
    COLON           reduce using rule 223 (var-name -> ID .)
    AT              reduce using rule 223 (var-name -> ID .)
    S_FOREACH       reduce using rule 223 (var-name -> ID .)
    S_FOR           reduce using rule 223 (var-name -> ID .)
    C_APP           reduce using rule 223 (var-name -> ID .)
    D_FUNCTION      reduce using rule 223 (var-name -> ID .)
    LPAREN          reduce using rule 223 (var-name -> ID .)
    RBRACE          reduce using rule 223 (var-name -> ID .)
    E_STDIN         reduce using rule 223 (var-name -> ID .)
    E_STDOUT        reduce using rule 223 (var-name -> ID .)
    E_STDERR        reduce using rule 223 (var-name -> ID .)
    STR_LITERAL     reduce using rule 223 (var-name -> ID .)
    MUL_STR_LITERAL reduce using rule 223 (var-name -> ID .)
    INT             reduce using rule 223 (var-name -> ID .)
    DOUBLE          reduce using rule 223 (var-name -> ID .)
    INF             reduce using rule 223 (var-name -> ID .)
    NAN             reduce using rule 223 (var-name -> ID .)
    E_TRUE          reduce using rule 223 (var-name -> ID .)
    E_FALSE         reduce using rule 223 (var-name -> ID .)
    ID              reduce using rule 223 (var-name -> ID .)


state 67

    (104) switch-stmt -> S_SWITCH LPAREN . expr RPAREN LBRACE case-star opt-default RBRACE
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 143
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 68

    (111) wait-stmt -> E_WAIT opt-deep . LPAREN expr-list RPAREN block

    LPAREN          shift and go to state 144


state 69

    (113) opt-deep -> E_DEEP .

    LPAREN          reduce using rule 113 (opt-deep -> E_DEEP .)


state 70

    (114) foreach-loop -> annotation-star S_FOREACH . var-name opt-comma-var-name S_IN expr block
    (223) var-name -> . ID

    ID              shift and go to state 66

    var-name                       shift and go to state 145

state 71

    (117) for-loop -> annotation-star S_FOR . LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block

    LPAREN          shift and go to state 146


state 72

    (46) swift-func-defn -> annotation-star func-hdr . ARROW block
    (60) foreign-func-defn -> annotation-star func-hdr . foreign-func-body
    (61) foreign-func-body -> . STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals

    ARROW           shift and go to state 147
    STR_LITERAL     shift and go to state 149

    foreign-func-body              shift and go to state 148

state 73

    (49) app-func-defn -> annotation-star C_APP . func-hdr LBRACE app-body RBRACE
    (28) func-hdr -> . type-params formal-arg-list func-name empty-or-arg-list
    (31) type-params -> .
    (32) type-params -> . LESS var-name comma-name-star GREATER

    LPAREN          reduce using rule 31 (type-params -> .)
    D_FUNCTION      reduce using rule 31 (type-params -> .)
    LESS            shift and go to state 77

    func-hdr                       shift and go to state 150
    type-params                    shift and go to state 75

state 74

    (172) func-call -> annotation-star func-name . LPAREN func-call-arg-list RPAREN

    LPAREN          shift and go to state 151


state 75

    (28) func-hdr -> type-params . formal-arg-list func-name empty-or-arg-list
    (35) formal-arg-list -> .
    (36) formal-arg-list -> . LPAREN opt-formal-args RPAREN

    D_FUNCTION      reduce using rule 35 (formal-arg-list -> .)
    LPAREN          shift and go to state 153

    formal-arg-list                shift and go to state 152

state 76

    (224) func-name -> D_FUNCTION . ID

    ID              shift and go to state 154


state 77

    (32) type-params -> LESS . var-name comma-name-star GREATER
    (223) var-name -> . ID

    ID              shift and go to state 66

    var-name                       shift and go to state 155

state 78

    (100) update-stmt -> var-name LESS . ID GREATER UPD expr SEMICOLON

    ID              shift and go to state 156


state 79

    (228) lval-expr -> var-name subscript-star .

    COMMA           reduce using rule 228 (lval-expr -> var-name subscript-star .)
    ASSIGN          reduce using rule 228 (lval-expr -> var-name subscript-star .)
    PLUS_AS         reduce using rule 228 (lval-expr -> var-name subscript-star .)
    RPAREN          reduce using rule 228 (lval-expr -> var-name subscript-star .)


state 80

    (230) subscript-star -> array-subscript . subscript-star
    (229) subscript-star -> .
    (230) subscript-star -> . array-subscript subscript-star
    (231) subscript-star -> . struct-subscript subscript-star
    (164) array-subscript -> . LBRACKET expr RBRACKET
    (165) struct-subscript -> . DOT ID

    COMMA           reduce using rule 229 (subscript-star -> .)
    ASSIGN          reduce using rule 229 (subscript-star -> .)
    PLUS_AS         reduce using rule 229 (subscript-star -> .)
    RPAREN          reduce using rule 229 (subscript-star -> .)
    LBRACKET        shift and go to state 82
    DOT             shift and go to state 83

    array-subscript                shift and go to state 80
    subscript-star                 shift and go to state 157
    struct-subscript               shift and go to state 81

state 81

    (231) subscript-star -> struct-subscript . subscript-star
    (229) subscript-star -> .
    (230) subscript-star -> . array-subscript subscript-star
    (231) subscript-star -> . struct-subscript subscript-star
    (164) array-subscript -> . LBRACKET expr RBRACKET
    (165) struct-subscript -> . DOT ID

    COMMA           reduce using rule 229 (subscript-star -> .)
    ASSIGN          reduce using rule 229 (subscript-star -> .)
    PLUS_AS         reduce using rule 229 (subscript-star -> .)
    RPAREN          reduce using rule 229 (subscript-star -> .)
    LBRACKET        shift and go to state 82
    DOT             shift and go to state 83

    struct-subscript               shift and go to state 81
    subscript-star                 shift and go to state 158
    array-subscript                shift and go to state 80

state 82

    (164) array-subscript -> LBRACKET . expr RBRACKET
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 159
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 83

    (165) struct-subscript -> DOT . ID

    ID              shift and go to state 160


state 84

    (128) iterate-loop -> S_ITERATE var-name . block S_UNTIL LPAREN expr RPAREN
    (85) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 26

    block                          shift and go to state 161

state 85

    (86) stmt-chain -> chainable-stmt semicolon-or-arrow . statement
    (4) statement -> . SEMICOLON
    (5) statement -> . global-const-defn
    (6) statement -> . import-stmt
    (7) statement -> . pragma-stmt
    (8) statement -> . func-defn
    (9) statement -> . block
    (10) statement -> . if-stmt
    (11) statement -> . switch-stmt
    (12) statement -> . wait-stmt
    (13) statement -> . foreach-loop
    (14) statement -> . for-loop
    (15) statement -> . iterate-loop
    (16) statement -> . stmt-chain
    (17) statement -> . update-stmt
    (18) global-const-defn -> . C_GLOBAL C_CONST var-decl SEMICOLON
    (19) import-stmt -> . D_IMPORT module-path SEMICOLON
    (20) import-stmt -> . D_IMPORT STR_LITERAL SEMICOLON
    (24) pragma-stmt -> . C_PRAGMA ID expr SEMICOLON
    (25) func-defn -> . swift-func-defn
    (26) func-defn -> . app-func-defn
    (27) func-defn -> . foreign-func-defn
    (85) block -> . LBRACE translation-unit RBRACE
    (101) if-stmt -> . S_IF LPAREN expr RPAREN block opt-else-block
    (104) switch-stmt -> . S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE
    (111) wait-stmt -> . E_WAIT opt-deep LPAREN expr-list RPAREN block
    (114) foreach-loop -> . annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block
    (117) for-loop -> . annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
    (128) iterate-loop -> . S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN
    (86) stmt-chain -> . chainable-stmt semicolon-or-arrow statement
    (100) update-stmt -> . var-name LESS ID GREATER UPD expr SEMICOLON
    (46) swift-func-defn -> . annotation-star func-hdr ARROW block
    (49) app-func-defn -> . annotation-star C_APP func-hdr LBRACE app-body RBRACE
    (60) foreign-func-defn -> . annotation-star func-hdr foreign-func-body
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (89) chainable-stmt -> . var-name
    (90) chainable-stmt -> . func-call
    (91) chainable-stmt -> . var-decl
    (92) chainable-stmt -> . assignment
    (223) var-name -> . ID
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (68) var-decl -> . type-prefix var-decl-rest
    (93) assignment -> . lval-or-paren-lval assign-or-plusas expr-list
    (76) type-prefix -> . type-name
    (77) type-prefix -> . param-type
    (98) lval-or-paren-lval -> . lval-list
    (99) lval-or-paren-lval -> . LPAREN lval-list RPAREN
    (210) type-name -> . class_INT
    (211) type-name -> . class_DOUBLE
    (212) type-name -> . class_FLOAT
    (213) type-name -> . class_VOID
    (214) type-name -> . class_UINT
    (215) type-name -> . class_BOOL
    (216) type-name -> . class_CHARACTER
    (217) type-name -> . class_String
    (218) type-name -> . collection_SET
    (219) type-name -> . collection_ARRAY
    (220) type-name -> . collection_DICT
    (221) type-name -> . ID
    (78) param-type -> . type-name LESS standalone-type GREATER
    (225) lval-list -> . lval-expr lval-expr-star
    (228) lval-expr -> . var-name subscript-star

  ! shift/reduce conflict for LPAREN resolved as shift
    SEMICOLON       shift and go to state 4
    C_GLOBAL        shift and go to state 18
    D_IMPORT        shift and go to state 20
    C_PRAGMA        shift and go to state 21
    LBRACE          shift and go to state 26
    S_IF            shift and go to state 27
    S_SWITCH        shift and go to state 29
    E_WAIT          shift and go to state 30
    S_ITERATE       shift and go to state 33
    S_FOREACH       reduce using rule 47 (annotation-star -> .)
    S_FOR           reduce using rule 47 (annotation-star -> .)
    C_APP           reduce using rule 47 (annotation-star -> .)
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LESS            reduce using rule 47 (annotation-star -> .)
    ID              shift and go to state 22
    AT              shift and go to state 38
    LPAREN          shift and go to state 28
    class_INT       shift and go to state 44
    class_DOUBLE    shift and go to state 45
    class_FLOAT     shift and go to state 46
    class_VOID      shift and go to state 47
    class_UINT      shift and go to state 48
    class_BOOL      shift and go to state 49
    class_CHARACTER shift and go to state 50
    class_String    shift and go to state 51
    collection_SET  shift and go to state 52
    collection_ARRAY shift and go to state 53
    collection_DICT shift and go to state 54

  ! LPAREN          [ reduce using rule 47 (annotation-star -> .) ]

    chainable-stmt                 shift and go to state 34
    statement                      shift and go to state 162
    global-const-defn              shift and go to state 5
    import-stmt                    shift and go to state 6
    pragma-stmt                    shift and go to state 7
    func-defn                      shift and go to state 8
    block                          shift and go to state 9
    if-stmt                        shift and go to state 10
    switch-stmt                    shift and go to state 11
    wait-stmt                      shift and go to state 12
    foreach-loop                   shift and go to state 13
    for-loop                       shift and go to state 14
    iterate-loop                   shift and go to state 15
    stmt-chain                     shift and go to state 16
    update-stmt                    shift and go to state 17
    var-decl                       shift and go to state 19
    swift-func-defn                shift and go to state 23
    app-func-defn                  shift and go to state 24
    foreign-func-defn              shift and go to state 25
    annotation-star                shift and go to state 31
    var-name                       shift and go to state 32
    annotation                     shift and go to state 35
    func-call                      shift and go to state 36
    assignment                     shift and go to state 37
    type-prefix                    shift and go to state 39
    lval-or-paren-lval             shift and go to state 40
    type-name                      shift and go to state 41
    param-type                     shift and go to state 42
    lval-list                      shift and go to state 43
    lval-expr                      shift and go to state 55

state 86

    (87) semicolon-or-arrow -> SEMICOLON .

    SEMICOLON       reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    C_GLOBAL        reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    D_IMPORT        reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    C_PRAGMA        reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    LBRACE          reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    S_IF            reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    S_SWITCH        reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    E_WAIT          reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    S_ITERATE       reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    ID              reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    AT              reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    LPAREN          reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    class_INT       reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    class_DOUBLE    reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    class_FLOAT     reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    class_VOID      reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    class_UINT      reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    class_BOOL      reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    class_CHARACTER reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    class_String    reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    collection_SET  reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    collection_ARRAY reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    collection_DICT reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    S_FOREACH       reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    S_FOR           reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    C_APP           reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    D_FUNCTION      reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)
    LESS            reduce using rule 87 (semicolon-or-arrow -> SEMICOLON .)


state 87

    (88) semicolon-or-arrow -> ARROW .

    SEMICOLON       reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    C_GLOBAL        reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    D_IMPORT        reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    C_PRAGMA        reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    LBRACE          reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    S_IF            reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    S_SWITCH        reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    E_WAIT          reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    S_ITERATE       reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    ID              reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    AT              reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    LPAREN          reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    class_INT       reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    class_DOUBLE    reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    class_FLOAT     reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    class_VOID      reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    class_UINT      reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    class_BOOL      reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    class_CHARACTER reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    class_String    reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    collection_SET  reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    collection_ARRAY reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    collection_DICT reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    S_FOREACH       reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    S_FOR           reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    C_APP           reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    D_FUNCTION      reduce using rule 88 (semicolon-or-arrow -> ARROW .)
    LESS            reduce using rule 88 (semicolon-or-arrow -> ARROW .)


state 88

    (48) annotation-star -> annotation annotation-star .

    S_FOREACH       reduce using rule 48 (annotation-star -> annotation annotation-star .)
    S_FOR           reduce using rule 48 (annotation-star -> annotation annotation-star .)
    C_APP           reduce using rule 48 (annotation-star -> annotation annotation-star .)
    D_FUNCTION      reduce using rule 48 (annotation-star -> annotation annotation-star .)
    LESS            reduce using rule 48 (annotation-star -> annotation annotation-star .)
    LPAREN          reduce using rule 48 (annotation-star -> annotation annotation-star .)


state 89

    (196) annotation -> AT ID .
    (198) kw-expr -> ID . ASSIGN expr

    AT              reduce using rule 196 (annotation -> AT ID .)
    S_FOREACH       reduce using rule 196 (annotation -> AT ID .)
    S_FOR           reduce using rule 196 (annotation -> AT ID .)
    C_APP           reduce using rule 196 (annotation -> AT ID .)
    D_FUNCTION      reduce using rule 196 (annotation -> AT ID .)
    LESS            reduce using rule 196 (annotation -> AT ID .)
    LPAREN          reduce using rule 196 (annotation -> AT ID .)
    ASSIGN          shift and go to state 163


state 90

    (197) annotation -> AT kw-expr .

    AT              reduce using rule 197 (annotation -> AT kw-expr .)
    S_FOREACH       reduce using rule 197 (annotation -> AT kw-expr .)
    S_FOR           reduce using rule 197 (annotation -> AT kw-expr .)
    C_APP           reduce using rule 197 (annotation -> AT kw-expr .)
    D_FUNCTION      reduce using rule 197 (annotation -> AT kw-expr .)
    LESS            reduce using rule 197 (annotation -> AT kw-expr .)
    LPAREN          reduce using rule 197 (annotation -> AT kw-expr .)


state 91

    (68) var-decl -> type-prefix var-decl-rest .

    SEMICOLON       reduce using rule 68 (var-decl -> type-prefix var-decl-rest .)
    ARROW           reduce using rule 68 (var-decl -> type-prefix var-decl-rest .)


state 92

    (71) var-decl-rest -> var-name . type-suffix empty-or-var-mappign empty-or-assign-expr
    (79) type-suffix -> .
    (80) type-suffix -> . LBRACKET empty-or-standalone-type RBRACKET type-suffix

    LESS            reduce using rule 79 (type-suffix -> .)
    ASSIGN          reduce using rule 79 (type-suffix -> .)
    SEMICOLON       reduce using rule 79 (type-suffix -> .)
    ARROW           reduce using rule 79 (type-suffix -> .)
    LBRACKET        shift and go to state 165

    type-suffix                    shift and go to state 164

state 93

    (93) assignment -> lval-or-paren-lval assign-or-plusas . expr-list
    (209) expr-list -> . expr
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr-list                      shift and go to state 166
    expr                           shift and go to state 167
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 94

    (96) assign-or-plusas -> ASSIGN .

    MINUS           reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    EXCLAMATION     reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    LPAREN          reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    STR_LITERAL     reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    MUL_STR_LITERAL reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    INT             reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    ID              reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    DOUBLE          reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    INF             reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    NAN             reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    E_TRUE          reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    E_FALSE         reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    LBRACKET        reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    LBRACE          reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    AT              reduce using rule 96 (assign-or-plusas -> ASSIGN .)
    D_FUNCTION      reduce using rule 96 (assign-or-plusas -> ASSIGN .)


state 95

    (97) assign-or-plusas -> PLUS_AS .

    MINUS           reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    EXCLAMATION     reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    LPAREN          reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    STR_LITERAL     reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    MUL_STR_LITERAL reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    INT             reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    ID              reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    DOUBLE          reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    INF             reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    NAN             reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    E_TRUE          reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    E_FALSE         reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    LBRACKET        reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    LBRACE          reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    AT              reduce using rule 97 (assign-or-plusas -> PLUS_AS .)
    D_FUNCTION      reduce using rule 97 (assign-or-plusas -> PLUS_AS .)


state 96

    (78) param-type -> type-name LESS . standalone-type GREATER
    (83) standalone-type -> . type-prefix type-suffix
    (76) type-prefix -> . type-name
    (77) type-prefix -> . param-type
    (210) type-name -> . class_INT
    (211) type-name -> . class_DOUBLE
    (212) type-name -> . class_FLOAT
    (213) type-name -> . class_VOID
    (214) type-name -> . class_UINT
    (215) type-name -> . class_BOOL
    (216) type-name -> . class_CHARACTER
    (217) type-name -> . class_String
    (218) type-name -> . collection_SET
    (219) type-name -> . collection_ARRAY
    (220) type-name -> . collection_DICT
    (221) type-name -> . ID
    (78) param-type -> . type-name LESS standalone-type GREATER

    class_INT       shift and go to state 44
    class_DOUBLE    shift and go to state 45
    class_FLOAT     shift and go to state 46
    class_VOID      shift and go to state 47
    class_UINT      shift and go to state 48
    class_BOOL      shift and go to state 49
    class_CHARACTER shift and go to state 50
    class_String    shift and go to state 51
    collection_SET  shift and go to state 52
    collection_ARRAY shift and go to state 53
    collection_DICT shift and go to state 54
    ID              shift and go to state 100

    type-name                      shift and go to state 41
    standalone-type                shift and go to state 168
    type-prefix                    shift and go to state 169
    param-type                     shift and go to state 42

state 97

    (225) lval-list -> lval-expr lval-expr-star .

    ASSIGN          reduce using rule 225 (lval-list -> lval-expr lval-expr-star .)
    PLUS_AS         reduce using rule 225 (lval-list -> lval-expr lval-expr-star .)
    RPAREN          reduce using rule 225 (lval-list -> lval-expr lval-expr-star .)


state 98

    (227) lval-expr-star -> COMMA . lval-expr lval-expr-star
    (228) lval-expr -> . var-name subscript-star
    (223) var-name -> . ID

    ID              shift and go to state 66

    lval-expr                      shift and go to state 170
    var-name                       shift and go to state 65

state 99

    (18) global-const-defn -> C_GLOBAL C_CONST var-decl . SEMICOLON

    SEMICOLON       shift and go to state 171


state 100

    (221) type-name -> ID .

    LESS            reduce using rule 221 (type-name -> ID .)
    ID              reduce using rule 221 (type-name -> ID .)
    LBRACKET        reduce using rule 221 (type-name -> ID .)
    GREATER         reduce using rule 221 (type-name -> ID .)
    RANGE           reduce using rule 221 (type-name -> ID .)
    RBRACKET        reduce using rule 221 (type-name -> ID .)


state 101

    (19) import-stmt -> D_IMPORT module-path SEMICOLON .

    SEMICOLON       reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    C_GLOBAL        reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    D_IMPORT        reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    C_PRAGMA        reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    LBRACE          reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_IF            reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_SWITCH        reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    E_WAIT          reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_ITERATE       reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    ID              reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    AT              reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    LPAREN          reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_INT       reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_DOUBLE    reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_FLOAT     reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_VOID      reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_UINT      reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_BOOL      reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_CHARACTER reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    class_String    reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    collection_SET  reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    collection_ARRAY reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    collection_DICT reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_FOREACH       reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_FOR           reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    C_APP           reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    D_FUNCTION      reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    LESS            reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    $end            reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    RBRACE          reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_CASE          reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)
    S_DEFAULT       reduce using rule 19 (import-stmt -> D_IMPORT module-path SEMICOLON .)


state 102

    (20) import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .

    SEMICOLON       reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    C_GLOBAL        reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    D_IMPORT        reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    C_PRAGMA        reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    LBRACE          reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_IF            reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_SWITCH        reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    E_WAIT          reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_ITERATE       reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    ID              reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    AT              reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    LPAREN          reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_INT       reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_DOUBLE    reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_FLOAT     reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_VOID      reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_UINT      reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_BOOL      reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_CHARACTER reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    class_String    reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    collection_SET  reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    collection_ARRAY reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    collection_DICT reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_FOREACH       reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_FOR           reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    C_APP           reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    D_FUNCTION      reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    LESS            reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    $end            reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    RBRACE          reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_CASE          reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)
    S_DEFAULT       reduce using rule 20 (import-stmt -> D_IMPORT STR_LITERAL SEMICOLON .)


state 103

    (21) module-path -> ID path-star .

    SEMICOLON       reduce using rule 21 (module-path -> ID path-star .)


state 104

    (23) path-star -> DOT . ID path-star

    ID              shift and go to state 172


state 105

    (24) pragma-stmt -> C_PRAGMA ID expr . SEMICOLON

    SEMICOLON       shift and go to state 173


state 106

    (129) expr -> or-expr .
    (131) or-expr -> or-expr . LOG_OR and-expr

    SEMICOLON       reduce using rule 129 (expr -> or-expr .)
    RPAREN          reduce using rule 129 (expr -> or-expr .)
    RBRACKET        reduce using rule 129 (expr -> or-expr .)
    ARROW           reduce using rule 129 (expr -> or-expr .)
    COMMA           reduce using rule 129 (expr -> or-expr .)
    COLON           reduce using rule 129 (expr -> or-expr .)
    AT              reduce using rule 129 (expr -> or-expr .)
    S_FOREACH       reduce using rule 129 (expr -> or-expr .)
    S_FOR           reduce using rule 129 (expr -> or-expr .)
    C_APP           reduce using rule 129 (expr -> or-expr .)
    D_FUNCTION      reduce using rule 129 (expr -> or-expr .)
    LESS            reduce using rule 129 (expr -> or-expr .)
    LPAREN          reduce using rule 129 (expr -> or-expr .)
    GREATER         reduce using rule 129 (expr -> or-expr .)
    RBRACE          reduce using rule 129 (expr -> or-expr .)
    LBRACE          reduce using rule 129 (expr -> or-expr .)
    E_STDIN         reduce using rule 129 (expr -> or-expr .)
    E_STDOUT        reduce using rule 129 (expr -> or-expr .)
    E_STDERR        reduce using rule 129 (expr -> or-expr .)
    LOG_OR          shift and go to state 174


state 107

    (130) or-expr -> and-expr .
    (133) and-expr -> and-expr . LOG_AND eq-expr

    LOG_OR          reduce using rule 130 (or-expr -> and-expr .)
    SEMICOLON       reduce using rule 130 (or-expr -> and-expr .)
    RPAREN          reduce using rule 130 (or-expr -> and-expr .)
    RBRACKET        reduce using rule 130 (or-expr -> and-expr .)
    ARROW           reduce using rule 130 (or-expr -> and-expr .)
    COMMA           reduce using rule 130 (or-expr -> and-expr .)
    COLON           reduce using rule 130 (or-expr -> and-expr .)
    AT              reduce using rule 130 (or-expr -> and-expr .)
    S_FOREACH       reduce using rule 130 (or-expr -> and-expr .)
    S_FOR           reduce using rule 130 (or-expr -> and-expr .)
    C_APP           reduce using rule 130 (or-expr -> and-expr .)
    D_FUNCTION      reduce using rule 130 (or-expr -> and-expr .)
    LESS            reduce using rule 130 (or-expr -> and-expr .)
    LPAREN          reduce using rule 130 (or-expr -> and-expr .)
    GREATER         reduce using rule 130 (or-expr -> and-expr .)
    RBRACE          reduce using rule 130 (or-expr -> and-expr .)
    LBRACE          reduce using rule 130 (or-expr -> and-expr .)
    E_STDIN         reduce using rule 130 (or-expr -> and-expr .)
    E_STDOUT        reduce using rule 130 (or-expr -> and-expr .)
    E_STDERR        reduce using rule 130 (or-expr -> and-expr .)
    LOG_AND         shift and go to state 175


state 108

    (132) and-expr -> eq-expr .
    (135) eq-expr -> eq-expr . eq-or-not-eq eq-expr
    (136) eq-or-not-eq -> . EQUAL
    (137) eq-or-not-eq -> . NOT_EQUAL

    LOG_AND         reduce using rule 132 (and-expr -> eq-expr .)
    LOG_OR          reduce using rule 132 (and-expr -> eq-expr .)
    SEMICOLON       reduce using rule 132 (and-expr -> eq-expr .)
    RPAREN          reduce using rule 132 (and-expr -> eq-expr .)
    RBRACKET        reduce using rule 132 (and-expr -> eq-expr .)
    ARROW           reduce using rule 132 (and-expr -> eq-expr .)
    COMMA           reduce using rule 132 (and-expr -> eq-expr .)
    COLON           reduce using rule 132 (and-expr -> eq-expr .)
    AT              reduce using rule 132 (and-expr -> eq-expr .)
    S_FOREACH       reduce using rule 132 (and-expr -> eq-expr .)
    S_FOR           reduce using rule 132 (and-expr -> eq-expr .)
    C_APP           reduce using rule 132 (and-expr -> eq-expr .)
    D_FUNCTION      reduce using rule 132 (and-expr -> eq-expr .)
    LESS            reduce using rule 132 (and-expr -> eq-expr .)
    LPAREN          reduce using rule 132 (and-expr -> eq-expr .)
    GREATER         reduce using rule 132 (and-expr -> eq-expr .)
    RBRACE          reduce using rule 132 (and-expr -> eq-expr .)
    LBRACE          reduce using rule 132 (and-expr -> eq-expr .)
    E_STDIN         reduce using rule 132 (and-expr -> eq-expr .)
    E_STDOUT        reduce using rule 132 (and-expr -> eq-expr .)
    E_STDERR        reduce using rule 132 (and-expr -> eq-expr .)
    EQUAL           shift and go to state 177
    NOT_EQUAL       shift and go to state 178

    eq-or-not-eq                   shift and go to state 176

state 109

    (134) eq-expr -> cmp-expr .
    (139) cmp-expr -> cmp-expr . cmp-sign add-expr
    (140) cmp-sign -> . LESS
    (141) cmp-sign -> . LESS_EQ
    (142) cmp-sign -> . EQUAL
    (143) cmp-sign -> . GREATER
    (144) cmp-sign -> . GREATER_EQ

  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
    NOT_EQUAL       reduce using rule 134 (eq-expr -> cmp-expr .)
    LOG_AND         reduce using rule 134 (eq-expr -> cmp-expr .)
    LOG_OR          reduce using rule 134 (eq-expr -> cmp-expr .)
    SEMICOLON       reduce using rule 134 (eq-expr -> cmp-expr .)
    RPAREN          reduce using rule 134 (eq-expr -> cmp-expr .)
    RBRACKET        reduce using rule 134 (eq-expr -> cmp-expr .)
    ARROW           reduce using rule 134 (eq-expr -> cmp-expr .)
    COMMA           reduce using rule 134 (eq-expr -> cmp-expr .)
    COLON           reduce using rule 134 (eq-expr -> cmp-expr .)
    AT              reduce using rule 134 (eq-expr -> cmp-expr .)
    S_FOREACH       reduce using rule 134 (eq-expr -> cmp-expr .)
    S_FOR           reduce using rule 134 (eq-expr -> cmp-expr .)
    C_APP           reduce using rule 134 (eq-expr -> cmp-expr .)
    D_FUNCTION      reduce using rule 134 (eq-expr -> cmp-expr .)
    LPAREN          reduce using rule 134 (eq-expr -> cmp-expr .)
    RBRACE          reduce using rule 134 (eq-expr -> cmp-expr .)
    LBRACE          reduce using rule 134 (eq-expr -> cmp-expr .)
    E_STDIN         reduce using rule 134 (eq-expr -> cmp-expr .)
    E_STDOUT        reduce using rule 134 (eq-expr -> cmp-expr .)
    E_STDERR        reduce using rule 134 (eq-expr -> cmp-expr .)
    LESS            shift and go to state 180
    LESS_EQ         shift and go to state 181
    EQUAL           shift and go to state 182
    GREATER         shift and go to state 183
    GREATER_EQ      shift and go to state 184

  ! EQUAL           [ reduce using rule 134 (eq-expr -> cmp-expr .) ]
  ! LESS            [ reduce using rule 134 (eq-expr -> cmp-expr .) ]
  ! GREATER         [ reduce using rule 134 (eq-expr -> cmp-expr .) ]

    cmp-sign                       shift and go to state 179

state 110

    (138) cmp-expr -> add-expr .
    (146) add-expr -> add-expr . add-sign mult-expr
    (147) add-sign -> . PLUS
    (148) add-sign -> . MINUS

    LESS            reduce using rule 138 (cmp-expr -> add-expr .)
    LESS_EQ         reduce using rule 138 (cmp-expr -> add-expr .)
    EQUAL           reduce using rule 138 (cmp-expr -> add-expr .)
    GREATER         reduce using rule 138 (cmp-expr -> add-expr .)
    GREATER_EQ      reduce using rule 138 (cmp-expr -> add-expr .)
    NOT_EQUAL       reduce using rule 138 (cmp-expr -> add-expr .)
    LOG_AND         reduce using rule 138 (cmp-expr -> add-expr .)
    LOG_OR          reduce using rule 138 (cmp-expr -> add-expr .)
    SEMICOLON       reduce using rule 138 (cmp-expr -> add-expr .)
    RPAREN          reduce using rule 138 (cmp-expr -> add-expr .)
    RBRACKET        reduce using rule 138 (cmp-expr -> add-expr .)
    ARROW           reduce using rule 138 (cmp-expr -> add-expr .)
    COMMA           reduce using rule 138 (cmp-expr -> add-expr .)
    COLON           reduce using rule 138 (cmp-expr -> add-expr .)
    AT              reduce using rule 138 (cmp-expr -> add-expr .)
    S_FOREACH       reduce using rule 138 (cmp-expr -> add-expr .)
    S_FOR           reduce using rule 138 (cmp-expr -> add-expr .)
    C_APP           reduce using rule 138 (cmp-expr -> add-expr .)
    D_FUNCTION      reduce using rule 138 (cmp-expr -> add-expr .)
    LPAREN          reduce using rule 138 (cmp-expr -> add-expr .)
    RBRACE          reduce using rule 138 (cmp-expr -> add-expr .)
    LBRACE          reduce using rule 138 (cmp-expr -> add-expr .)
    E_STDIN         reduce using rule 138 (cmp-expr -> add-expr .)
    E_STDOUT        reduce using rule 138 (cmp-expr -> add-expr .)
    E_STDERR        reduce using rule 138 (cmp-expr -> add-expr .)
    PLUS            shift and go to state 186
    MINUS           shift and go to state 187

    add-sign                       shift and go to state 185

state 111

    (145) add-expr -> mult-expr .
    (150) mult-expr -> mult-expr . mult-sign unary-expr
    (151) mult-sign -> . MULT
    (152) mult-sign -> . DIV
    (153) mult-sign -> . MULTPER
    (154) mult-sign -> . DOUBLEPER
    (155) mult-sign -> . MOD

    PLUS            reduce using rule 145 (add-expr -> mult-expr .)
    MINUS           reduce using rule 145 (add-expr -> mult-expr .)
    LESS            reduce using rule 145 (add-expr -> mult-expr .)
    LESS_EQ         reduce using rule 145 (add-expr -> mult-expr .)
    EQUAL           reduce using rule 145 (add-expr -> mult-expr .)
    GREATER         reduce using rule 145 (add-expr -> mult-expr .)
    GREATER_EQ      reduce using rule 145 (add-expr -> mult-expr .)
    NOT_EQUAL       reduce using rule 145 (add-expr -> mult-expr .)
    LOG_AND         reduce using rule 145 (add-expr -> mult-expr .)
    LOG_OR          reduce using rule 145 (add-expr -> mult-expr .)
    SEMICOLON       reduce using rule 145 (add-expr -> mult-expr .)
    RPAREN          reduce using rule 145 (add-expr -> mult-expr .)
    RBRACKET        reduce using rule 145 (add-expr -> mult-expr .)
    ARROW           reduce using rule 145 (add-expr -> mult-expr .)
    COMMA           reduce using rule 145 (add-expr -> mult-expr .)
    COLON           reduce using rule 145 (add-expr -> mult-expr .)
    AT              reduce using rule 145 (add-expr -> mult-expr .)
    S_FOREACH       reduce using rule 145 (add-expr -> mult-expr .)
    S_FOR           reduce using rule 145 (add-expr -> mult-expr .)
    C_APP           reduce using rule 145 (add-expr -> mult-expr .)
    D_FUNCTION      reduce using rule 145 (add-expr -> mult-expr .)
    LPAREN          reduce using rule 145 (add-expr -> mult-expr .)
    RBRACE          reduce using rule 145 (add-expr -> mult-expr .)
    LBRACE          reduce using rule 145 (add-expr -> mult-expr .)
    E_STDIN         reduce using rule 145 (add-expr -> mult-expr .)
    E_STDOUT        reduce using rule 145 (add-expr -> mult-expr .)
    E_STDERR        reduce using rule 145 (add-expr -> mult-expr .)
    MULT            shift and go to state 189
    DIV             shift and go to state 190
    MULTPER         shift and go to state 191
    DOUBLEPER       shift and go to state 192
    MOD             shift and go to state 193

    mult-sign                      shift and go to state 188

state 112

    (149) mult-expr -> unary-expr .

    MULT            reduce using rule 149 (mult-expr -> unary-expr .)
    DIV             reduce using rule 149 (mult-expr -> unary-expr .)
    MULTPER         reduce using rule 149 (mult-expr -> unary-expr .)
    DOUBLEPER       reduce using rule 149 (mult-expr -> unary-expr .)
    MOD             reduce using rule 149 (mult-expr -> unary-expr .)
    PLUS            reduce using rule 149 (mult-expr -> unary-expr .)
    MINUS           reduce using rule 149 (mult-expr -> unary-expr .)
    LESS            reduce using rule 149 (mult-expr -> unary-expr .)
    LESS_EQ         reduce using rule 149 (mult-expr -> unary-expr .)
    EQUAL           reduce using rule 149 (mult-expr -> unary-expr .)
    GREATER         reduce using rule 149 (mult-expr -> unary-expr .)
    GREATER_EQ      reduce using rule 149 (mult-expr -> unary-expr .)
    NOT_EQUAL       reduce using rule 149 (mult-expr -> unary-expr .)
    LOG_AND         reduce using rule 149 (mult-expr -> unary-expr .)
    LOG_OR          reduce using rule 149 (mult-expr -> unary-expr .)
    SEMICOLON       reduce using rule 149 (mult-expr -> unary-expr .)
    RPAREN          reduce using rule 149 (mult-expr -> unary-expr .)
    RBRACKET        reduce using rule 149 (mult-expr -> unary-expr .)
    ARROW           reduce using rule 149 (mult-expr -> unary-expr .)
    COMMA           reduce using rule 149 (mult-expr -> unary-expr .)
    COLON           reduce using rule 149 (mult-expr -> unary-expr .)
    AT              reduce using rule 149 (mult-expr -> unary-expr .)
    S_FOREACH       reduce using rule 149 (mult-expr -> unary-expr .)
    S_FOR           reduce using rule 149 (mult-expr -> unary-expr .)
    C_APP           reduce using rule 149 (mult-expr -> unary-expr .)
    D_FUNCTION      reduce using rule 149 (mult-expr -> unary-expr .)
    LPAREN          reduce using rule 149 (mult-expr -> unary-expr .)
    RBRACE          reduce using rule 149 (mult-expr -> unary-expr .)
    LBRACE          reduce using rule 149 (mult-expr -> unary-expr .)
    E_STDIN         reduce using rule 149 (mult-expr -> unary-expr .)
    E_STDOUT        reduce using rule 149 (mult-expr -> unary-expr .)
    E_STDERR        reduce using rule 149 (mult-expr -> unary-expr .)


state 113

    (156) unary-expr -> postfix-expr .
    (161) postfix-expr -> postfix-expr . array-or-struct
    (162) array-or-struct -> . array-subscript
    (163) array-or-struct -> . struct-subscript
    (164) array-subscript -> . LBRACKET expr RBRACKET
    (165) struct-subscript -> . DOT ID

    MULT            reduce using rule 156 (unary-expr -> postfix-expr .)
    DIV             reduce using rule 156 (unary-expr -> postfix-expr .)
    MULTPER         reduce using rule 156 (unary-expr -> postfix-expr .)
    DOUBLEPER       reduce using rule 156 (unary-expr -> postfix-expr .)
    MOD             reduce using rule 156 (unary-expr -> postfix-expr .)
    PLUS            reduce using rule 156 (unary-expr -> postfix-expr .)
    MINUS           reduce using rule 156 (unary-expr -> postfix-expr .)
    LESS            reduce using rule 156 (unary-expr -> postfix-expr .)
    LESS_EQ         reduce using rule 156 (unary-expr -> postfix-expr .)
    EQUAL           reduce using rule 156 (unary-expr -> postfix-expr .)
    GREATER         reduce using rule 156 (unary-expr -> postfix-expr .)
    GREATER_EQ      reduce using rule 156 (unary-expr -> postfix-expr .)
    NOT_EQUAL       reduce using rule 156 (unary-expr -> postfix-expr .)
    LOG_AND         reduce using rule 156 (unary-expr -> postfix-expr .)
    LOG_OR          reduce using rule 156 (unary-expr -> postfix-expr .)
    SEMICOLON       reduce using rule 156 (unary-expr -> postfix-expr .)
    RPAREN          reduce using rule 156 (unary-expr -> postfix-expr .)
    RBRACKET        reduce using rule 156 (unary-expr -> postfix-expr .)
    ARROW           reduce using rule 156 (unary-expr -> postfix-expr .)
    COMMA           reduce using rule 156 (unary-expr -> postfix-expr .)
    COLON           reduce using rule 156 (unary-expr -> postfix-expr .)
    AT              reduce using rule 156 (unary-expr -> postfix-expr .)
    S_FOREACH       reduce using rule 156 (unary-expr -> postfix-expr .)
    S_FOR           reduce using rule 156 (unary-expr -> postfix-expr .)
    C_APP           reduce using rule 156 (unary-expr -> postfix-expr .)
    D_FUNCTION      reduce using rule 156 (unary-expr -> postfix-expr .)
    LPAREN          reduce using rule 156 (unary-expr -> postfix-expr .)
    RBRACE          reduce using rule 156 (unary-expr -> postfix-expr .)
    LBRACE          reduce using rule 156 (unary-expr -> postfix-expr .)
    E_STDIN         reduce using rule 156 (unary-expr -> postfix-expr .)
    E_STDOUT        reduce using rule 156 (unary-expr -> postfix-expr .)
    E_STDERR        reduce using rule 156 (unary-expr -> postfix-expr .)
    LBRACKET        shift and go to state 82
    DOT             shift and go to state 83

    array-or-struct                shift and go to state 194
    array-subscript                shift and go to state 195
    struct-subscript               shift and go to state 196

state 114

    (157) unary-expr -> minus-or-excl . postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    postfix-expr                   shift and go to state 197
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 115

    (160) postfix-expr -> base-expr .

    LBRACKET        reduce using rule 160 (postfix-expr -> base-expr .)
    DOT             reduce using rule 160 (postfix-expr -> base-expr .)
    MULT            reduce using rule 160 (postfix-expr -> base-expr .)
    DIV             reduce using rule 160 (postfix-expr -> base-expr .)
    MULTPER         reduce using rule 160 (postfix-expr -> base-expr .)
    DOUBLEPER       reduce using rule 160 (postfix-expr -> base-expr .)
    MOD             reduce using rule 160 (postfix-expr -> base-expr .)
    PLUS            reduce using rule 160 (postfix-expr -> base-expr .)
    MINUS           reduce using rule 160 (postfix-expr -> base-expr .)
    LESS            reduce using rule 160 (postfix-expr -> base-expr .)
    LESS_EQ         reduce using rule 160 (postfix-expr -> base-expr .)
    EQUAL           reduce using rule 160 (postfix-expr -> base-expr .)
    GREATER         reduce using rule 160 (postfix-expr -> base-expr .)
    GREATER_EQ      reduce using rule 160 (postfix-expr -> base-expr .)
    NOT_EQUAL       reduce using rule 160 (postfix-expr -> base-expr .)
    LOG_AND         reduce using rule 160 (postfix-expr -> base-expr .)
    LOG_OR          reduce using rule 160 (postfix-expr -> base-expr .)
    SEMICOLON       reduce using rule 160 (postfix-expr -> base-expr .)
    RPAREN          reduce using rule 160 (postfix-expr -> base-expr .)
    RBRACKET        reduce using rule 160 (postfix-expr -> base-expr .)
    ARROW           reduce using rule 160 (postfix-expr -> base-expr .)
    COMMA           reduce using rule 160 (postfix-expr -> base-expr .)
    COLON           reduce using rule 160 (postfix-expr -> base-expr .)
    AT              reduce using rule 160 (postfix-expr -> base-expr .)
    S_FOREACH       reduce using rule 160 (postfix-expr -> base-expr .)
    S_FOR           reduce using rule 160 (postfix-expr -> base-expr .)
    C_APP           reduce using rule 160 (postfix-expr -> base-expr .)
    D_FUNCTION      reduce using rule 160 (postfix-expr -> base-expr .)
    LPAREN          reduce using rule 160 (postfix-expr -> base-expr .)
    RBRACE          reduce using rule 160 (postfix-expr -> base-expr .)
    LBRACE          reduce using rule 160 (postfix-expr -> base-expr .)
    E_STDIN         reduce using rule 160 (postfix-expr -> base-expr .)
    E_STDOUT        reduce using rule 160 (postfix-expr -> base-expr .)
    E_STDERR        reduce using rule 160 (postfix-expr -> base-expr .)


state 116

    (158) minus-or-excl -> MINUS .

    LPAREN          reduce using rule 158 (minus-or-excl -> MINUS .)
    STR_LITERAL     reduce using rule 158 (minus-or-excl -> MINUS .)
    MUL_STR_LITERAL reduce using rule 158 (minus-or-excl -> MINUS .)
    INT             reduce using rule 158 (minus-or-excl -> MINUS .)
    ID              reduce using rule 158 (minus-or-excl -> MINUS .)
    DOUBLE          reduce using rule 158 (minus-or-excl -> MINUS .)
    INF             reduce using rule 158 (minus-or-excl -> MINUS .)
    NAN             reduce using rule 158 (minus-or-excl -> MINUS .)
    E_TRUE          reduce using rule 158 (minus-or-excl -> MINUS .)
    E_FALSE         reduce using rule 158 (minus-or-excl -> MINUS .)
    LBRACKET        reduce using rule 158 (minus-or-excl -> MINUS .)
    LBRACE          reduce using rule 158 (minus-or-excl -> MINUS .)
    AT              reduce using rule 158 (minus-or-excl -> MINUS .)
    D_FUNCTION      reduce using rule 158 (minus-or-excl -> MINUS .)


state 117

    (159) minus-or-excl -> EXCLAMATION .

    LPAREN          reduce using rule 159 (minus-or-excl -> EXCLAMATION .)
    STR_LITERAL     reduce using rule 159 (minus-or-excl -> EXCLAMATION .)
    MUL_STR_LITERAL reduce using rule 159 (minus-or-excl -> EXCLAMATION .)
    INT             reduce using rule 159 (minus-or-excl -> EXCLAMATION .)
    ID              reduce using rule 159 (minus-or-excl -> EXCLAMATION .)
    DOUBLE          reduce using rule 159 (minus-or-excl -> EXCLAMATION .)
    INF             reduce using rule 159 (minus-or-excl -> EXCLAMATION .)
    NAN             reduce using rule 159 (minus-or-excl -> EXCLAMATION .)
    E_TRUE          reduce using rule 159 (minus-or-excl -> EXCLAMATION .)
    E_FALSE         reduce using rule 159 (minus-or-excl -> EXCLAMATION .)
    LBRACKET        reduce using rule 159 (minus-or-excl -> EXCLAMATION .)
    LBRACE          reduce using rule 159 (minus-or-excl -> EXCLAMATION .)
    AT              reduce using rule 159 (minus-or-excl -> EXCLAMATION .)
    D_FUNCTION      reduce using rule 159 (minus-or-excl -> EXCLAMATION .)


state 118

    (166) base-expr -> literal .

    LBRACKET        reduce using rule 166 (base-expr -> literal .)
    DOT             reduce using rule 166 (base-expr -> literal .)
    MULT            reduce using rule 166 (base-expr -> literal .)
    DIV             reduce using rule 166 (base-expr -> literal .)
    MULTPER         reduce using rule 166 (base-expr -> literal .)
    DOUBLEPER       reduce using rule 166 (base-expr -> literal .)
    MOD             reduce using rule 166 (base-expr -> literal .)
    PLUS            reduce using rule 166 (base-expr -> literal .)
    MINUS           reduce using rule 166 (base-expr -> literal .)
    LESS            reduce using rule 166 (base-expr -> literal .)
    LESS_EQ         reduce using rule 166 (base-expr -> literal .)
    EQUAL           reduce using rule 166 (base-expr -> literal .)
    GREATER         reduce using rule 166 (base-expr -> literal .)
    GREATER_EQ      reduce using rule 166 (base-expr -> literal .)
    NOT_EQUAL       reduce using rule 166 (base-expr -> literal .)
    LOG_AND         reduce using rule 166 (base-expr -> literal .)
    LOG_OR          reduce using rule 166 (base-expr -> literal .)
    SEMICOLON       reduce using rule 166 (base-expr -> literal .)
    RPAREN          reduce using rule 166 (base-expr -> literal .)
    RBRACKET        reduce using rule 166 (base-expr -> literal .)
    ARROW           reduce using rule 166 (base-expr -> literal .)
    COMMA           reduce using rule 166 (base-expr -> literal .)
    COLON           reduce using rule 166 (base-expr -> literal .)
    AT              reduce using rule 166 (base-expr -> literal .)
    S_FOREACH       reduce using rule 166 (base-expr -> literal .)
    S_FOR           reduce using rule 166 (base-expr -> literal .)
    C_APP           reduce using rule 166 (base-expr -> literal .)
    D_FUNCTION      reduce using rule 166 (base-expr -> literal .)
    LPAREN          reduce using rule 166 (base-expr -> literal .)
    RBRACE          reduce using rule 166 (base-expr -> literal .)
    LBRACE          reduce using rule 166 (base-expr -> literal .)
    E_STDIN         reduce using rule 166 (base-expr -> literal .)
    E_STDOUT        reduce using rule 166 (base-expr -> literal .)
    E_STDERR        reduce using rule 166 (base-expr -> literal .)


state 119

    (167) base-expr -> func-call .

    LBRACKET        reduce using rule 167 (base-expr -> func-call .)
    DOT             reduce using rule 167 (base-expr -> func-call .)
    MULT            reduce using rule 167 (base-expr -> func-call .)
    DIV             reduce using rule 167 (base-expr -> func-call .)
    MULTPER         reduce using rule 167 (base-expr -> func-call .)
    DOUBLEPER       reduce using rule 167 (base-expr -> func-call .)
    MOD             reduce using rule 167 (base-expr -> func-call .)
    PLUS            reduce using rule 167 (base-expr -> func-call .)
    MINUS           reduce using rule 167 (base-expr -> func-call .)
    LESS            reduce using rule 167 (base-expr -> func-call .)
    LESS_EQ         reduce using rule 167 (base-expr -> func-call .)
    EQUAL           reduce using rule 167 (base-expr -> func-call .)
    GREATER         reduce using rule 167 (base-expr -> func-call .)
    GREATER_EQ      reduce using rule 167 (base-expr -> func-call .)
    NOT_EQUAL       reduce using rule 167 (base-expr -> func-call .)
    LOG_AND         reduce using rule 167 (base-expr -> func-call .)
    LOG_OR          reduce using rule 167 (base-expr -> func-call .)
    SEMICOLON       reduce using rule 167 (base-expr -> func-call .)
    RPAREN          reduce using rule 167 (base-expr -> func-call .)
    RBRACKET        reduce using rule 167 (base-expr -> func-call .)
    ARROW           reduce using rule 167 (base-expr -> func-call .)
    COMMA           reduce using rule 167 (base-expr -> func-call .)
    COLON           reduce using rule 167 (base-expr -> func-call .)
    AT              reduce using rule 167 (base-expr -> func-call .)
    S_FOREACH       reduce using rule 167 (base-expr -> func-call .)
    S_FOR           reduce using rule 167 (base-expr -> func-call .)
    C_APP           reduce using rule 167 (base-expr -> func-call .)
    D_FUNCTION      reduce using rule 167 (base-expr -> func-call .)
    LPAREN          reduce using rule 167 (base-expr -> func-call .)
    RBRACE          reduce using rule 167 (base-expr -> func-call .)
    LBRACE          reduce using rule 167 (base-expr -> func-call .)
    E_STDIN         reduce using rule 167 (base-expr -> func-call .)
    E_STDOUT        reduce using rule 167 (base-expr -> func-call .)
    E_STDERR        reduce using rule 167 (base-expr -> func-call .)


state 120

    (168) base-expr -> var-name .

    LBRACKET        reduce using rule 168 (base-expr -> var-name .)
    DOT             reduce using rule 168 (base-expr -> var-name .)
    MULT            reduce using rule 168 (base-expr -> var-name .)
    DIV             reduce using rule 168 (base-expr -> var-name .)
    MULTPER         reduce using rule 168 (base-expr -> var-name .)
    DOUBLEPER       reduce using rule 168 (base-expr -> var-name .)
    MOD             reduce using rule 168 (base-expr -> var-name .)
    PLUS            reduce using rule 168 (base-expr -> var-name .)
    MINUS           reduce using rule 168 (base-expr -> var-name .)
    LESS            reduce using rule 168 (base-expr -> var-name .)
    LESS_EQ         reduce using rule 168 (base-expr -> var-name .)
    EQUAL           reduce using rule 168 (base-expr -> var-name .)
    GREATER         reduce using rule 168 (base-expr -> var-name .)
    GREATER_EQ      reduce using rule 168 (base-expr -> var-name .)
    NOT_EQUAL       reduce using rule 168 (base-expr -> var-name .)
    LOG_AND         reduce using rule 168 (base-expr -> var-name .)
    LOG_OR          reduce using rule 168 (base-expr -> var-name .)
    SEMICOLON       reduce using rule 168 (base-expr -> var-name .)
    RPAREN          reduce using rule 168 (base-expr -> var-name .)
    RBRACKET        reduce using rule 168 (base-expr -> var-name .)
    ARROW           reduce using rule 168 (base-expr -> var-name .)
    COMMA           reduce using rule 168 (base-expr -> var-name .)
    COLON           reduce using rule 168 (base-expr -> var-name .)
    AT              reduce using rule 168 (base-expr -> var-name .)
    S_FOREACH       reduce using rule 168 (base-expr -> var-name .)
    S_FOR           reduce using rule 168 (base-expr -> var-name .)
    C_APP           reduce using rule 168 (base-expr -> var-name .)
    D_FUNCTION      reduce using rule 168 (base-expr -> var-name .)
    LPAREN          reduce using rule 168 (base-expr -> var-name .)
    RBRACE          reduce using rule 168 (base-expr -> var-name .)
    LBRACE          reduce using rule 168 (base-expr -> var-name .)
    E_STDIN         reduce using rule 168 (base-expr -> var-name .)
    E_STDOUT        reduce using rule 168 (base-expr -> var-name .)
    E_STDERR        reduce using rule 168 (base-expr -> var-name .)


state 121

    (169) base-expr -> LPAREN . expr RPAREN
    (178) tuple-constructor -> LPAREN . expr COMMA expr comma-expr-star RPAREN
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 198
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 122

    (170) base-expr -> tuple-constructor .

    LBRACKET        reduce using rule 170 (base-expr -> tuple-constructor .)
    DOT             reduce using rule 170 (base-expr -> tuple-constructor .)
    MULT            reduce using rule 170 (base-expr -> tuple-constructor .)
    DIV             reduce using rule 170 (base-expr -> tuple-constructor .)
    MULTPER         reduce using rule 170 (base-expr -> tuple-constructor .)
    DOUBLEPER       reduce using rule 170 (base-expr -> tuple-constructor .)
    MOD             reduce using rule 170 (base-expr -> tuple-constructor .)
    PLUS            reduce using rule 170 (base-expr -> tuple-constructor .)
    MINUS           reduce using rule 170 (base-expr -> tuple-constructor .)
    LESS            reduce using rule 170 (base-expr -> tuple-constructor .)
    LESS_EQ         reduce using rule 170 (base-expr -> tuple-constructor .)
    EQUAL           reduce using rule 170 (base-expr -> tuple-constructor .)
    GREATER         reduce using rule 170 (base-expr -> tuple-constructor .)
    GREATER_EQ      reduce using rule 170 (base-expr -> tuple-constructor .)
    NOT_EQUAL       reduce using rule 170 (base-expr -> tuple-constructor .)
    LOG_AND         reduce using rule 170 (base-expr -> tuple-constructor .)
    LOG_OR          reduce using rule 170 (base-expr -> tuple-constructor .)
    SEMICOLON       reduce using rule 170 (base-expr -> tuple-constructor .)
    RPAREN          reduce using rule 170 (base-expr -> tuple-constructor .)
    RBRACKET        reduce using rule 170 (base-expr -> tuple-constructor .)
    ARROW           reduce using rule 170 (base-expr -> tuple-constructor .)
    COMMA           reduce using rule 170 (base-expr -> tuple-constructor .)
    COLON           reduce using rule 170 (base-expr -> tuple-constructor .)
    AT              reduce using rule 170 (base-expr -> tuple-constructor .)
    S_FOREACH       reduce using rule 170 (base-expr -> tuple-constructor .)
    S_FOR           reduce using rule 170 (base-expr -> tuple-constructor .)
    C_APP           reduce using rule 170 (base-expr -> tuple-constructor .)
    D_FUNCTION      reduce using rule 170 (base-expr -> tuple-constructor .)
    LPAREN          reduce using rule 170 (base-expr -> tuple-constructor .)
    RBRACE          reduce using rule 170 (base-expr -> tuple-constructor .)
    LBRACE          reduce using rule 170 (base-expr -> tuple-constructor .)
    E_STDIN         reduce using rule 170 (base-expr -> tuple-constructor .)
    E_STDOUT        reduce using rule 170 (base-expr -> tuple-constructor .)
    E_STDERR        reduce using rule 170 (base-expr -> tuple-constructor .)


state 123

    (171) base-expr -> array-constructor .

    LBRACKET        reduce using rule 171 (base-expr -> array-constructor .)
    DOT             reduce using rule 171 (base-expr -> array-constructor .)
    MULT            reduce using rule 171 (base-expr -> array-constructor .)
    DIV             reduce using rule 171 (base-expr -> array-constructor .)
    MULTPER         reduce using rule 171 (base-expr -> array-constructor .)
    DOUBLEPER       reduce using rule 171 (base-expr -> array-constructor .)
    MOD             reduce using rule 171 (base-expr -> array-constructor .)
    PLUS            reduce using rule 171 (base-expr -> array-constructor .)
    MINUS           reduce using rule 171 (base-expr -> array-constructor .)
    LESS            reduce using rule 171 (base-expr -> array-constructor .)
    LESS_EQ         reduce using rule 171 (base-expr -> array-constructor .)
    EQUAL           reduce using rule 171 (base-expr -> array-constructor .)
    GREATER         reduce using rule 171 (base-expr -> array-constructor .)
    GREATER_EQ      reduce using rule 171 (base-expr -> array-constructor .)
    NOT_EQUAL       reduce using rule 171 (base-expr -> array-constructor .)
    LOG_AND         reduce using rule 171 (base-expr -> array-constructor .)
    LOG_OR          reduce using rule 171 (base-expr -> array-constructor .)
    SEMICOLON       reduce using rule 171 (base-expr -> array-constructor .)
    RPAREN          reduce using rule 171 (base-expr -> array-constructor .)
    RBRACKET        reduce using rule 171 (base-expr -> array-constructor .)
    ARROW           reduce using rule 171 (base-expr -> array-constructor .)
    COMMA           reduce using rule 171 (base-expr -> array-constructor .)
    COLON           reduce using rule 171 (base-expr -> array-constructor .)
    AT              reduce using rule 171 (base-expr -> array-constructor .)
    S_FOREACH       reduce using rule 171 (base-expr -> array-constructor .)
    S_FOR           reduce using rule 171 (base-expr -> array-constructor .)
    C_APP           reduce using rule 171 (base-expr -> array-constructor .)
    D_FUNCTION      reduce using rule 171 (base-expr -> array-constructor .)
    LPAREN          reduce using rule 171 (base-expr -> array-constructor .)
    RBRACE          reduce using rule 171 (base-expr -> array-constructor .)
    LBRACE          reduce using rule 171 (base-expr -> array-constructor .)
    E_STDIN         reduce using rule 171 (base-expr -> array-constructor .)
    E_STDOUT        reduce using rule 171 (base-expr -> array-constructor .)
    E_STDERR        reduce using rule 171 (base-expr -> array-constructor .)


state 124

    (199) literal -> STR_LITERAL .

    LBRACKET        reduce using rule 199 (literal -> STR_LITERAL .)
    DOT             reduce using rule 199 (literal -> STR_LITERAL .)
    MULT            reduce using rule 199 (literal -> STR_LITERAL .)
    DIV             reduce using rule 199 (literal -> STR_LITERAL .)
    MULTPER         reduce using rule 199 (literal -> STR_LITERAL .)
    DOUBLEPER       reduce using rule 199 (literal -> STR_LITERAL .)
    MOD             reduce using rule 199 (literal -> STR_LITERAL .)
    PLUS            reduce using rule 199 (literal -> STR_LITERAL .)
    MINUS           reduce using rule 199 (literal -> STR_LITERAL .)
    LESS            reduce using rule 199 (literal -> STR_LITERAL .)
    LESS_EQ         reduce using rule 199 (literal -> STR_LITERAL .)
    EQUAL           reduce using rule 199 (literal -> STR_LITERAL .)
    GREATER         reduce using rule 199 (literal -> STR_LITERAL .)
    GREATER_EQ      reduce using rule 199 (literal -> STR_LITERAL .)
    NOT_EQUAL       reduce using rule 199 (literal -> STR_LITERAL .)
    LOG_AND         reduce using rule 199 (literal -> STR_LITERAL .)
    LOG_OR          reduce using rule 199 (literal -> STR_LITERAL .)
    SEMICOLON       reduce using rule 199 (literal -> STR_LITERAL .)
    RPAREN          reduce using rule 199 (literal -> STR_LITERAL .)
    RBRACKET        reduce using rule 199 (literal -> STR_LITERAL .)
    ARROW           reduce using rule 199 (literal -> STR_LITERAL .)
    COMMA           reduce using rule 199 (literal -> STR_LITERAL .)
    COLON           reduce using rule 199 (literal -> STR_LITERAL .)
    AT              reduce using rule 199 (literal -> STR_LITERAL .)
    S_FOREACH       reduce using rule 199 (literal -> STR_LITERAL .)
    S_FOR           reduce using rule 199 (literal -> STR_LITERAL .)
    C_APP           reduce using rule 199 (literal -> STR_LITERAL .)
    D_FUNCTION      reduce using rule 199 (literal -> STR_LITERAL .)
    LPAREN          reduce using rule 199 (literal -> STR_LITERAL .)
    RBRACE          reduce using rule 199 (literal -> STR_LITERAL .)
    LBRACE          reduce using rule 199 (literal -> STR_LITERAL .)
    E_STDIN         reduce using rule 199 (literal -> STR_LITERAL .)
    E_STDOUT        reduce using rule 199 (literal -> STR_LITERAL .)
    E_STDERR        reduce using rule 199 (literal -> STR_LITERAL .)
    STR_LITERAL     reduce using rule 199 (literal -> STR_LITERAL .)
    MUL_STR_LITERAL reduce using rule 199 (literal -> STR_LITERAL .)
    INT             reduce using rule 199 (literal -> STR_LITERAL .)
    DOUBLE          reduce using rule 199 (literal -> STR_LITERAL .)
    INF             reduce using rule 199 (literal -> STR_LITERAL .)
    NAN             reduce using rule 199 (literal -> STR_LITERAL .)
    E_TRUE          reduce using rule 199 (literal -> STR_LITERAL .)
    E_FALSE         reduce using rule 199 (literal -> STR_LITERAL .)
    ID              reduce using rule 199 (literal -> STR_LITERAL .)


state 125

    (200) literal -> MUL_STR_LITERAL .

    LBRACKET        reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    DOT             reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    MULT            reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    DIV             reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    MULTPER         reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    DOUBLEPER       reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    MOD             reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    PLUS            reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    MINUS           reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    LESS            reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    LESS_EQ         reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    EQUAL           reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    GREATER         reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    GREATER_EQ      reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    NOT_EQUAL       reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    LOG_AND         reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    LOG_OR          reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    SEMICOLON       reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    RPAREN          reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    RBRACKET        reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    ARROW           reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    COMMA           reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    COLON           reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    AT              reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    S_FOREACH       reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    S_FOR           reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    C_APP           reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    D_FUNCTION      reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    LPAREN          reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    RBRACE          reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    LBRACE          reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    E_STDIN         reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    E_STDOUT        reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    E_STDERR        reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    STR_LITERAL     reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    MUL_STR_LITERAL reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    INT             reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    DOUBLE          reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    INF             reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    NAN             reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    E_TRUE          reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    E_FALSE         reduce using rule 200 (literal -> MUL_STR_LITERAL .)
    ID              reduce using rule 200 (literal -> MUL_STR_LITERAL .)


state 126

    (201) literal -> INT .

    LBRACKET        reduce using rule 201 (literal -> INT .)
    DOT             reduce using rule 201 (literal -> INT .)
    MULT            reduce using rule 201 (literal -> INT .)
    DIV             reduce using rule 201 (literal -> INT .)
    MULTPER         reduce using rule 201 (literal -> INT .)
    DOUBLEPER       reduce using rule 201 (literal -> INT .)
    MOD             reduce using rule 201 (literal -> INT .)
    PLUS            reduce using rule 201 (literal -> INT .)
    MINUS           reduce using rule 201 (literal -> INT .)
    LESS            reduce using rule 201 (literal -> INT .)
    LESS_EQ         reduce using rule 201 (literal -> INT .)
    EQUAL           reduce using rule 201 (literal -> INT .)
    GREATER         reduce using rule 201 (literal -> INT .)
    GREATER_EQ      reduce using rule 201 (literal -> INT .)
    NOT_EQUAL       reduce using rule 201 (literal -> INT .)
    LOG_AND         reduce using rule 201 (literal -> INT .)
    LOG_OR          reduce using rule 201 (literal -> INT .)
    SEMICOLON       reduce using rule 201 (literal -> INT .)
    RPAREN          reduce using rule 201 (literal -> INT .)
    RBRACKET        reduce using rule 201 (literal -> INT .)
    ARROW           reduce using rule 201 (literal -> INT .)
    COMMA           reduce using rule 201 (literal -> INT .)
    COLON           reduce using rule 201 (literal -> INT .)
    AT              reduce using rule 201 (literal -> INT .)
    S_FOREACH       reduce using rule 201 (literal -> INT .)
    S_FOR           reduce using rule 201 (literal -> INT .)
    C_APP           reduce using rule 201 (literal -> INT .)
    D_FUNCTION      reduce using rule 201 (literal -> INT .)
    LPAREN          reduce using rule 201 (literal -> INT .)
    RBRACE          reduce using rule 201 (literal -> INT .)
    LBRACE          reduce using rule 201 (literal -> INT .)
    E_STDIN         reduce using rule 201 (literal -> INT .)
    E_STDOUT        reduce using rule 201 (literal -> INT .)
    E_STDERR        reduce using rule 201 (literal -> INT .)
    STR_LITERAL     reduce using rule 201 (literal -> INT .)
    MUL_STR_LITERAL reduce using rule 201 (literal -> INT .)
    INT             reduce using rule 201 (literal -> INT .)
    DOUBLE          reduce using rule 201 (literal -> INT .)
    INF             reduce using rule 201 (literal -> INT .)
    NAN             reduce using rule 201 (literal -> INT .)
    E_TRUE          reduce using rule 201 (literal -> INT .)
    E_FALSE         reduce using rule 201 (literal -> INT .)
    ID              reduce using rule 201 (literal -> INT .)


state 127

    (202) literal -> float-literal .

    LBRACKET        reduce using rule 202 (literal -> float-literal .)
    DOT             reduce using rule 202 (literal -> float-literal .)
    MULT            reduce using rule 202 (literal -> float-literal .)
    DIV             reduce using rule 202 (literal -> float-literal .)
    MULTPER         reduce using rule 202 (literal -> float-literal .)
    DOUBLEPER       reduce using rule 202 (literal -> float-literal .)
    MOD             reduce using rule 202 (literal -> float-literal .)
    PLUS            reduce using rule 202 (literal -> float-literal .)
    MINUS           reduce using rule 202 (literal -> float-literal .)
    LESS            reduce using rule 202 (literal -> float-literal .)
    LESS_EQ         reduce using rule 202 (literal -> float-literal .)
    EQUAL           reduce using rule 202 (literal -> float-literal .)
    GREATER         reduce using rule 202 (literal -> float-literal .)
    GREATER_EQ      reduce using rule 202 (literal -> float-literal .)
    NOT_EQUAL       reduce using rule 202 (literal -> float-literal .)
    LOG_AND         reduce using rule 202 (literal -> float-literal .)
    LOG_OR          reduce using rule 202 (literal -> float-literal .)
    SEMICOLON       reduce using rule 202 (literal -> float-literal .)
    RPAREN          reduce using rule 202 (literal -> float-literal .)
    RBRACKET        reduce using rule 202 (literal -> float-literal .)
    ARROW           reduce using rule 202 (literal -> float-literal .)
    COMMA           reduce using rule 202 (literal -> float-literal .)
    COLON           reduce using rule 202 (literal -> float-literal .)
    AT              reduce using rule 202 (literal -> float-literal .)
    S_FOREACH       reduce using rule 202 (literal -> float-literal .)
    S_FOR           reduce using rule 202 (literal -> float-literal .)
    C_APP           reduce using rule 202 (literal -> float-literal .)
    D_FUNCTION      reduce using rule 202 (literal -> float-literal .)
    LPAREN          reduce using rule 202 (literal -> float-literal .)
    RBRACE          reduce using rule 202 (literal -> float-literal .)
    LBRACE          reduce using rule 202 (literal -> float-literal .)
    E_STDIN         reduce using rule 202 (literal -> float-literal .)
    E_STDOUT        reduce using rule 202 (literal -> float-literal .)
    E_STDERR        reduce using rule 202 (literal -> float-literal .)
    STR_LITERAL     reduce using rule 202 (literal -> float-literal .)
    MUL_STR_LITERAL reduce using rule 202 (literal -> float-literal .)
    INT             reduce using rule 202 (literal -> float-literal .)
    DOUBLE          reduce using rule 202 (literal -> float-literal .)
    INF             reduce using rule 202 (literal -> float-literal .)
    NAN             reduce using rule 202 (literal -> float-literal .)
    E_TRUE          reduce using rule 202 (literal -> float-literal .)
    E_FALSE         reduce using rule 202 (literal -> float-literal .)
    ID              reduce using rule 202 (literal -> float-literal .)


state 128

    (203) literal -> bool-literal .

    LBRACKET        reduce using rule 203 (literal -> bool-literal .)
    DOT             reduce using rule 203 (literal -> bool-literal .)
    MULT            reduce using rule 203 (literal -> bool-literal .)
    DIV             reduce using rule 203 (literal -> bool-literal .)
    MULTPER         reduce using rule 203 (literal -> bool-literal .)
    DOUBLEPER       reduce using rule 203 (literal -> bool-literal .)
    MOD             reduce using rule 203 (literal -> bool-literal .)
    PLUS            reduce using rule 203 (literal -> bool-literal .)
    MINUS           reduce using rule 203 (literal -> bool-literal .)
    LESS            reduce using rule 203 (literal -> bool-literal .)
    LESS_EQ         reduce using rule 203 (literal -> bool-literal .)
    EQUAL           reduce using rule 203 (literal -> bool-literal .)
    GREATER         reduce using rule 203 (literal -> bool-literal .)
    GREATER_EQ      reduce using rule 203 (literal -> bool-literal .)
    NOT_EQUAL       reduce using rule 203 (literal -> bool-literal .)
    LOG_AND         reduce using rule 203 (literal -> bool-literal .)
    LOG_OR          reduce using rule 203 (literal -> bool-literal .)
    SEMICOLON       reduce using rule 203 (literal -> bool-literal .)
    RPAREN          reduce using rule 203 (literal -> bool-literal .)
    RBRACKET        reduce using rule 203 (literal -> bool-literal .)
    ARROW           reduce using rule 203 (literal -> bool-literal .)
    COMMA           reduce using rule 203 (literal -> bool-literal .)
    COLON           reduce using rule 203 (literal -> bool-literal .)
    AT              reduce using rule 203 (literal -> bool-literal .)
    S_FOREACH       reduce using rule 203 (literal -> bool-literal .)
    S_FOR           reduce using rule 203 (literal -> bool-literal .)
    C_APP           reduce using rule 203 (literal -> bool-literal .)
    D_FUNCTION      reduce using rule 203 (literal -> bool-literal .)
    LPAREN          reduce using rule 203 (literal -> bool-literal .)
    RBRACE          reduce using rule 203 (literal -> bool-literal .)
    LBRACE          reduce using rule 203 (literal -> bool-literal .)
    E_STDIN         reduce using rule 203 (literal -> bool-literal .)
    E_STDOUT        reduce using rule 203 (literal -> bool-literal .)
    E_STDERR        reduce using rule 203 (literal -> bool-literal .)
    STR_LITERAL     reduce using rule 203 (literal -> bool-literal .)
    MUL_STR_LITERAL reduce using rule 203 (literal -> bool-literal .)
    INT             reduce using rule 203 (literal -> bool-literal .)
    DOUBLE          reduce using rule 203 (literal -> bool-literal .)
    INF             reduce using rule 203 (literal -> bool-literal .)
    NAN             reduce using rule 203 (literal -> bool-literal .)
    E_TRUE          reduce using rule 203 (literal -> bool-literal .)
    E_FALSE         reduce using rule 203 (literal -> bool-literal .)
    ID              reduce using rule 203 (literal -> bool-literal .)


state 129

    (172) func-call -> annotation-star . func-name LPAREN func-call-arg-list RPAREN
    (224) func-name -> . D_FUNCTION ID

    D_FUNCTION      shift and go to state 76

    func-name                      shift and go to state 74

state 130

    (181) array-constructor -> array-list-constructor .

    LBRACKET        reduce using rule 181 (array-constructor -> array-list-constructor .)
    DOT             reduce using rule 181 (array-constructor -> array-list-constructor .)
    MULT            reduce using rule 181 (array-constructor -> array-list-constructor .)
    DIV             reduce using rule 181 (array-constructor -> array-list-constructor .)
    MULTPER         reduce using rule 181 (array-constructor -> array-list-constructor .)
    DOUBLEPER       reduce using rule 181 (array-constructor -> array-list-constructor .)
    MOD             reduce using rule 181 (array-constructor -> array-list-constructor .)
    PLUS            reduce using rule 181 (array-constructor -> array-list-constructor .)
    MINUS           reduce using rule 181 (array-constructor -> array-list-constructor .)
    LESS            reduce using rule 181 (array-constructor -> array-list-constructor .)
    LESS_EQ         reduce using rule 181 (array-constructor -> array-list-constructor .)
    EQUAL           reduce using rule 181 (array-constructor -> array-list-constructor .)
    GREATER         reduce using rule 181 (array-constructor -> array-list-constructor .)
    GREATER_EQ      reduce using rule 181 (array-constructor -> array-list-constructor .)
    NOT_EQUAL       reduce using rule 181 (array-constructor -> array-list-constructor .)
    LOG_AND         reduce using rule 181 (array-constructor -> array-list-constructor .)
    LOG_OR          reduce using rule 181 (array-constructor -> array-list-constructor .)
    SEMICOLON       reduce using rule 181 (array-constructor -> array-list-constructor .)
    RPAREN          reduce using rule 181 (array-constructor -> array-list-constructor .)
    RBRACKET        reduce using rule 181 (array-constructor -> array-list-constructor .)
    ARROW           reduce using rule 181 (array-constructor -> array-list-constructor .)
    COMMA           reduce using rule 181 (array-constructor -> array-list-constructor .)
    COLON           reduce using rule 181 (array-constructor -> array-list-constructor .)
    AT              reduce using rule 181 (array-constructor -> array-list-constructor .)
    S_FOREACH       reduce using rule 181 (array-constructor -> array-list-constructor .)
    S_FOR           reduce using rule 181 (array-constructor -> array-list-constructor .)
    C_APP           reduce using rule 181 (array-constructor -> array-list-constructor .)
    D_FUNCTION      reduce using rule 181 (array-constructor -> array-list-constructor .)
    LPAREN          reduce using rule 181 (array-constructor -> array-list-constructor .)
    RBRACE          reduce using rule 181 (array-constructor -> array-list-constructor .)
    LBRACE          reduce using rule 181 (array-constructor -> array-list-constructor .)
    E_STDIN         reduce using rule 181 (array-constructor -> array-list-constructor .)
    E_STDOUT        reduce using rule 181 (array-constructor -> array-list-constructor .)
    E_STDERR        reduce using rule 181 (array-constructor -> array-list-constructor .)
    STR_LITERAL     reduce using rule 181 (array-constructor -> array-list-constructor .)
    MUL_STR_LITERAL reduce using rule 181 (array-constructor -> array-list-constructor .)
    INT             reduce using rule 181 (array-constructor -> array-list-constructor .)
    DOUBLE          reduce using rule 181 (array-constructor -> array-list-constructor .)
    INF             reduce using rule 181 (array-constructor -> array-list-constructor .)
    NAN             reduce using rule 181 (array-constructor -> array-list-constructor .)
    E_TRUE          reduce using rule 181 (array-constructor -> array-list-constructor .)
    E_FALSE         reduce using rule 181 (array-constructor -> array-list-constructor .)
    ID              reduce using rule 181 (array-constructor -> array-list-constructor .)


state 131

    (182) array-constructor -> array-range-constructor .

    LBRACKET        reduce using rule 182 (array-constructor -> array-range-constructor .)
    DOT             reduce using rule 182 (array-constructor -> array-range-constructor .)
    MULT            reduce using rule 182 (array-constructor -> array-range-constructor .)
    DIV             reduce using rule 182 (array-constructor -> array-range-constructor .)
    MULTPER         reduce using rule 182 (array-constructor -> array-range-constructor .)
    DOUBLEPER       reduce using rule 182 (array-constructor -> array-range-constructor .)
    MOD             reduce using rule 182 (array-constructor -> array-range-constructor .)
    PLUS            reduce using rule 182 (array-constructor -> array-range-constructor .)
    MINUS           reduce using rule 182 (array-constructor -> array-range-constructor .)
    LESS            reduce using rule 182 (array-constructor -> array-range-constructor .)
    LESS_EQ         reduce using rule 182 (array-constructor -> array-range-constructor .)
    EQUAL           reduce using rule 182 (array-constructor -> array-range-constructor .)
    GREATER         reduce using rule 182 (array-constructor -> array-range-constructor .)
    GREATER_EQ      reduce using rule 182 (array-constructor -> array-range-constructor .)
    NOT_EQUAL       reduce using rule 182 (array-constructor -> array-range-constructor .)
    LOG_AND         reduce using rule 182 (array-constructor -> array-range-constructor .)
    LOG_OR          reduce using rule 182 (array-constructor -> array-range-constructor .)
    SEMICOLON       reduce using rule 182 (array-constructor -> array-range-constructor .)
    RPAREN          reduce using rule 182 (array-constructor -> array-range-constructor .)
    RBRACKET        reduce using rule 182 (array-constructor -> array-range-constructor .)
    ARROW           reduce using rule 182 (array-constructor -> array-range-constructor .)
    COMMA           reduce using rule 182 (array-constructor -> array-range-constructor .)
    COLON           reduce using rule 182 (array-constructor -> array-range-constructor .)
    AT              reduce using rule 182 (array-constructor -> array-range-constructor .)
    S_FOREACH       reduce using rule 182 (array-constructor -> array-range-constructor .)
    S_FOR           reduce using rule 182 (array-constructor -> array-range-constructor .)
    C_APP           reduce using rule 182 (array-constructor -> array-range-constructor .)
    D_FUNCTION      reduce using rule 182 (array-constructor -> array-range-constructor .)
    LPAREN          reduce using rule 182 (array-constructor -> array-range-constructor .)
    RBRACE          reduce using rule 182 (array-constructor -> array-range-constructor .)
    LBRACE          reduce using rule 182 (array-constructor -> array-range-constructor .)
    E_STDIN         reduce using rule 182 (array-constructor -> array-range-constructor .)
    E_STDOUT        reduce using rule 182 (array-constructor -> array-range-constructor .)
    E_STDERR        reduce using rule 182 (array-constructor -> array-range-constructor .)
    STR_LITERAL     reduce using rule 182 (array-constructor -> array-range-constructor .)
    MUL_STR_LITERAL reduce using rule 182 (array-constructor -> array-range-constructor .)
    INT             reduce using rule 182 (array-constructor -> array-range-constructor .)
    DOUBLE          reduce using rule 182 (array-constructor -> array-range-constructor .)
    INF             reduce using rule 182 (array-constructor -> array-range-constructor .)
    NAN             reduce using rule 182 (array-constructor -> array-range-constructor .)
    E_TRUE          reduce using rule 182 (array-constructor -> array-range-constructor .)
    E_FALSE         reduce using rule 182 (array-constructor -> array-range-constructor .)
    ID              reduce using rule 182 (array-constructor -> array-range-constructor .)


state 132

    (183) array-constructor -> array-kv-constructor .

    LBRACKET        reduce using rule 183 (array-constructor -> array-kv-constructor .)
    DOT             reduce using rule 183 (array-constructor -> array-kv-constructor .)
    MULT            reduce using rule 183 (array-constructor -> array-kv-constructor .)
    DIV             reduce using rule 183 (array-constructor -> array-kv-constructor .)
    MULTPER         reduce using rule 183 (array-constructor -> array-kv-constructor .)
    DOUBLEPER       reduce using rule 183 (array-constructor -> array-kv-constructor .)
    MOD             reduce using rule 183 (array-constructor -> array-kv-constructor .)
    PLUS            reduce using rule 183 (array-constructor -> array-kv-constructor .)
    MINUS           reduce using rule 183 (array-constructor -> array-kv-constructor .)
    LESS            reduce using rule 183 (array-constructor -> array-kv-constructor .)
    LESS_EQ         reduce using rule 183 (array-constructor -> array-kv-constructor .)
    EQUAL           reduce using rule 183 (array-constructor -> array-kv-constructor .)
    GREATER         reduce using rule 183 (array-constructor -> array-kv-constructor .)
    GREATER_EQ      reduce using rule 183 (array-constructor -> array-kv-constructor .)
    NOT_EQUAL       reduce using rule 183 (array-constructor -> array-kv-constructor .)
    LOG_AND         reduce using rule 183 (array-constructor -> array-kv-constructor .)
    LOG_OR          reduce using rule 183 (array-constructor -> array-kv-constructor .)
    SEMICOLON       reduce using rule 183 (array-constructor -> array-kv-constructor .)
    RPAREN          reduce using rule 183 (array-constructor -> array-kv-constructor .)
    RBRACKET        reduce using rule 183 (array-constructor -> array-kv-constructor .)
    ARROW           reduce using rule 183 (array-constructor -> array-kv-constructor .)
    COMMA           reduce using rule 183 (array-constructor -> array-kv-constructor .)
    COLON           reduce using rule 183 (array-constructor -> array-kv-constructor .)
    AT              reduce using rule 183 (array-constructor -> array-kv-constructor .)
    S_FOREACH       reduce using rule 183 (array-constructor -> array-kv-constructor .)
    S_FOR           reduce using rule 183 (array-constructor -> array-kv-constructor .)
    C_APP           reduce using rule 183 (array-constructor -> array-kv-constructor .)
    D_FUNCTION      reduce using rule 183 (array-constructor -> array-kv-constructor .)
    LPAREN          reduce using rule 183 (array-constructor -> array-kv-constructor .)
    RBRACE          reduce using rule 183 (array-constructor -> array-kv-constructor .)
    LBRACE          reduce using rule 183 (array-constructor -> array-kv-constructor .)
    E_STDIN         reduce using rule 183 (array-constructor -> array-kv-constructor .)
    E_STDOUT        reduce using rule 183 (array-constructor -> array-kv-constructor .)
    E_STDERR        reduce using rule 183 (array-constructor -> array-kv-constructor .)
    STR_LITERAL     reduce using rule 183 (array-constructor -> array-kv-constructor .)
    MUL_STR_LITERAL reduce using rule 183 (array-constructor -> array-kv-constructor .)
    INT             reduce using rule 183 (array-constructor -> array-kv-constructor .)
    DOUBLE          reduce using rule 183 (array-constructor -> array-kv-constructor .)
    INF             reduce using rule 183 (array-constructor -> array-kv-constructor .)
    NAN             reduce using rule 183 (array-constructor -> array-kv-constructor .)
    E_TRUE          reduce using rule 183 (array-constructor -> array-kv-constructor .)
    E_FALSE         reduce using rule 183 (array-constructor -> array-kv-constructor .)
    ID              reduce using rule 183 (array-constructor -> array-kv-constructor .)


state 133

    (204) float-literal -> DOUBLE .

    LBRACKET        reduce using rule 204 (float-literal -> DOUBLE .)
    DOT             reduce using rule 204 (float-literal -> DOUBLE .)
    MULT            reduce using rule 204 (float-literal -> DOUBLE .)
    DIV             reduce using rule 204 (float-literal -> DOUBLE .)
    MULTPER         reduce using rule 204 (float-literal -> DOUBLE .)
    DOUBLEPER       reduce using rule 204 (float-literal -> DOUBLE .)
    MOD             reduce using rule 204 (float-literal -> DOUBLE .)
    PLUS            reduce using rule 204 (float-literal -> DOUBLE .)
    MINUS           reduce using rule 204 (float-literal -> DOUBLE .)
    LESS            reduce using rule 204 (float-literal -> DOUBLE .)
    LESS_EQ         reduce using rule 204 (float-literal -> DOUBLE .)
    EQUAL           reduce using rule 204 (float-literal -> DOUBLE .)
    GREATER         reduce using rule 204 (float-literal -> DOUBLE .)
    GREATER_EQ      reduce using rule 204 (float-literal -> DOUBLE .)
    NOT_EQUAL       reduce using rule 204 (float-literal -> DOUBLE .)
    LOG_AND         reduce using rule 204 (float-literal -> DOUBLE .)
    LOG_OR          reduce using rule 204 (float-literal -> DOUBLE .)
    SEMICOLON       reduce using rule 204 (float-literal -> DOUBLE .)
    RPAREN          reduce using rule 204 (float-literal -> DOUBLE .)
    RBRACKET        reduce using rule 204 (float-literal -> DOUBLE .)
    ARROW           reduce using rule 204 (float-literal -> DOUBLE .)
    COMMA           reduce using rule 204 (float-literal -> DOUBLE .)
    COLON           reduce using rule 204 (float-literal -> DOUBLE .)
    AT              reduce using rule 204 (float-literal -> DOUBLE .)
    S_FOREACH       reduce using rule 204 (float-literal -> DOUBLE .)
    S_FOR           reduce using rule 204 (float-literal -> DOUBLE .)
    C_APP           reduce using rule 204 (float-literal -> DOUBLE .)
    D_FUNCTION      reduce using rule 204 (float-literal -> DOUBLE .)
    LPAREN          reduce using rule 204 (float-literal -> DOUBLE .)
    RBRACE          reduce using rule 204 (float-literal -> DOUBLE .)
    LBRACE          reduce using rule 204 (float-literal -> DOUBLE .)
    E_STDIN         reduce using rule 204 (float-literal -> DOUBLE .)
    E_STDOUT        reduce using rule 204 (float-literal -> DOUBLE .)
    E_STDERR        reduce using rule 204 (float-literal -> DOUBLE .)
    STR_LITERAL     reduce using rule 204 (float-literal -> DOUBLE .)
    MUL_STR_LITERAL reduce using rule 204 (float-literal -> DOUBLE .)
    INT             reduce using rule 204 (float-literal -> DOUBLE .)
    DOUBLE          reduce using rule 204 (float-literal -> DOUBLE .)
    INF             reduce using rule 204 (float-literal -> DOUBLE .)
    NAN             reduce using rule 204 (float-literal -> DOUBLE .)
    E_TRUE          reduce using rule 204 (float-literal -> DOUBLE .)
    E_FALSE         reduce using rule 204 (float-literal -> DOUBLE .)
    ID              reduce using rule 204 (float-literal -> DOUBLE .)


state 134

    (205) float-literal -> INF .

    LBRACKET        reduce using rule 205 (float-literal -> INF .)
    DOT             reduce using rule 205 (float-literal -> INF .)
    MULT            reduce using rule 205 (float-literal -> INF .)
    DIV             reduce using rule 205 (float-literal -> INF .)
    MULTPER         reduce using rule 205 (float-literal -> INF .)
    DOUBLEPER       reduce using rule 205 (float-literal -> INF .)
    MOD             reduce using rule 205 (float-literal -> INF .)
    PLUS            reduce using rule 205 (float-literal -> INF .)
    MINUS           reduce using rule 205 (float-literal -> INF .)
    LESS            reduce using rule 205 (float-literal -> INF .)
    LESS_EQ         reduce using rule 205 (float-literal -> INF .)
    EQUAL           reduce using rule 205 (float-literal -> INF .)
    GREATER         reduce using rule 205 (float-literal -> INF .)
    GREATER_EQ      reduce using rule 205 (float-literal -> INF .)
    NOT_EQUAL       reduce using rule 205 (float-literal -> INF .)
    LOG_AND         reduce using rule 205 (float-literal -> INF .)
    LOG_OR          reduce using rule 205 (float-literal -> INF .)
    SEMICOLON       reduce using rule 205 (float-literal -> INF .)
    RPAREN          reduce using rule 205 (float-literal -> INF .)
    RBRACKET        reduce using rule 205 (float-literal -> INF .)
    ARROW           reduce using rule 205 (float-literal -> INF .)
    COMMA           reduce using rule 205 (float-literal -> INF .)
    COLON           reduce using rule 205 (float-literal -> INF .)
    AT              reduce using rule 205 (float-literal -> INF .)
    S_FOREACH       reduce using rule 205 (float-literal -> INF .)
    S_FOR           reduce using rule 205 (float-literal -> INF .)
    C_APP           reduce using rule 205 (float-literal -> INF .)
    D_FUNCTION      reduce using rule 205 (float-literal -> INF .)
    LPAREN          reduce using rule 205 (float-literal -> INF .)
    RBRACE          reduce using rule 205 (float-literal -> INF .)
    LBRACE          reduce using rule 205 (float-literal -> INF .)
    E_STDIN         reduce using rule 205 (float-literal -> INF .)
    E_STDOUT        reduce using rule 205 (float-literal -> INF .)
    E_STDERR        reduce using rule 205 (float-literal -> INF .)
    STR_LITERAL     reduce using rule 205 (float-literal -> INF .)
    MUL_STR_LITERAL reduce using rule 205 (float-literal -> INF .)
    INT             reduce using rule 205 (float-literal -> INF .)
    DOUBLE          reduce using rule 205 (float-literal -> INF .)
    INF             reduce using rule 205 (float-literal -> INF .)
    NAN             reduce using rule 205 (float-literal -> INF .)
    E_TRUE          reduce using rule 205 (float-literal -> INF .)
    E_FALSE         reduce using rule 205 (float-literal -> INF .)
    ID              reduce using rule 205 (float-literal -> INF .)


state 135

    (206) float-literal -> NAN .

    LBRACKET        reduce using rule 206 (float-literal -> NAN .)
    DOT             reduce using rule 206 (float-literal -> NAN .)
    MULT            reduce using rule 206 (float-literal -> NAN .)
    DIV             reduce using rule 206 (float-literal -> NAN .)
    MULTPER         reduce using rule 206 (float-literal -> NAN .)
    DOUBLEPER       reduce using rule 206 (float-literal -> NAN .)
    MOD             reduce using rule 206 (float-literal -> NAN .)
    PLUS            reduce using rule 206 (float-literal -> NAN .)
    MINUS           reduce using rule 206 (float-literal -> NAN .)
    LESS            reduce using rule 206 (float-literal -> NAN .)
    LESS_EQ         reduce using rule 206 (float-literal -> NAN .)
    EQUAL           reduce using rule 206 (float-literal -> NAN .)
    GREATER         reduce using rule 206 (float-literal -> NAN .)
    GREATER_EQ      reduce using rule 206 (float-literal -> NAN .)
    NOT_EQUAL       reduce using rule 206 (float-literal -> NAN .)
    LOG_AND         reduce using rule 206 (float-literal -> NAN .)
    LOG_OR          reduce using rule 206 (float-literal -> NAN .)
    SEMICOLON       reduce using rule 206 (float-literal -> NAN .)
    RPAREN          reduce using rule 206 (float-literal -> NAN .)
    RBRACKET        reduce using rule 206 (float-literal -> NAN .)
    ARROW           reduce using rule 206 (float-literal -> NAN .)
    COMMA           reduce using rule 206 (float-literal -> NAN .)
    COLON           reduce using rule 206 (float-literal -> NAN .)
    AT              reduce using rule 206 (float-literal -> NAN .)
    S_FOREACH       reduce using rule 206 (float-literal -> NAN .)
    S_FOR           reduce using rule 206 (float-literal -> NAN .)
    C_APP           reduce using rule 206 (float-literal -> NAN .)
    D_FUNCTION      reduce using rule 206 (float-literal -> NAN .)
    LPAREN          reduce using rule 206 (float-literal -> NAN .)
    RBRACE          reduce using rule 206 (float-literal -> NAN .)
    LBRACE          reduce using rule 206 (float-literal -> NAN .)
    E_STDIN         reduce using rule 206 (float-literal -> NAN .)
    E_STDOUT        reduce using rule 206 (float-literal -> NAN .)
    E_STDERR        reduce using rule 206 (float-literal -> NAN .)
    STR_LITERAL     reduce using rule 206 (float-literal -> NAN .)
    MUL_STR_LITERAL reduce using rule 206 (float-literal -> NAN .)
    INT             reduce using rule 206 (float-literal -> NAN .)
    DOUBLE          reduce using rule 206 (float-literal -> NAN .)
    INF             reduce using rule 206 (float-literal -> NAN .)
    NAN             reduce using rule 206 (float-literal -> NAN .)
    E_TRUE          reduce using rule 206 (float-literal -> NAN .)
    E_FALSE         reduce using rule 206 (float-literal -> NAN .)
    ID              reduce using rule 206 (float-literal -> NAN .)


state 136

    (207) bool-literal -> E_TRUE .

    LBRACKET        reduce using rule 207 (bool-literal -> E_TRUE .)
    DOT             reduce using rule 207 (bool-literal -> E_TRUE .)
    MULT            reduce using rule 207 (bool-literal -> E_TRUE .)
    DIV             reduce using rule 207 (bool-literal -> E_TRUE .)
    MULTPER         reduce using rule 207 (bool-literal -> E_TRUE .)
    DOUBLEPER       reduce using rule 207 (bool-literal -> E_TRUE .)
    MOD             reduce using rule 207 (bool-literal -> E_TRUE .)
    PLUS            reduce using rule 207 (bool-literal -> E_TRUE .)
    MINUS           reduce using rule 207 (bool-literal -> E_TRUE .)
    LESS            reduce using rule 207 (bool-literal -> E_TRUE .)
    LESS_EQ         reduce using rule 207 (bool-literal -> E_TRUE .)
    EQUAL           reduce using rule 207 (bool-literal -> E_TRUE .)
    GREATER         reduce using rule 207 (bool-literal -> E_TRUE .)
    GREATER_EQ      reduce using rule 207 (bool-literal -> E_TRUE .)
    NOT_EQUAL       reduce using rule 207 (bool-literal -> E_TRUE .)
    LOG_AND         reduce using rule 207 (bool-literal -> E_TRUE .)
    LOG_OR          reduce using rule 207 (bool-literal -> E_TRUE .)
    SEMICOLON       reduce using rule 207 (bool-literal -> E_TRUE .)
    RPAREN          reduce using rule 207 (bool-literal -> E_TRUE .)
    RBRACKET        reduce using rule 207 (bool-literal -> E_TRUE .)
    ARROW           reduce using rule 207 (bool-literal -> E_TRUE .)
    COMMA           reduce using rule 207 (bool-literal -> E_TRUE .)
    COLON           reduce using rule 207 (bool-literal -> E_TRUE .)
    AT              reduce using rule 207 (bool-literal -> E_TRUE .)
    S_FOREACH       reduce using rule 207 (bool-literal -> E_TRUE .)
    S_FOR           reduce using rule 207 (bool-literal -> E_TRUE .)
    C_APP           reduce using rule 207 (bool-literal -> E_TRUE .)
    D_FUNCTION      reduce using rule 207 (bool-literal -> E_TRUE .)
    LPAREN          reduce using rule 207 (bool-literal -> E_TRUE .)
    RBRACE          reduce using rule 207 (bool-literal -> E_TRUE .)
    LBRACE          reduce using rule 207 (bool-literal -> E_TRUE .)
    E_STDIN         reduce using rule 207 (bool-literal -> E_TRUE .)
    E_STDOUT        reduce using rule 207 (bool-literal -> E_TRUE .)
    E_STDERR        reduce using rule 207 (bool-literal -> E_TRUE .)
    STR_LITERAL     reduce using rule 207 (bool-literal -> E_TRUE .)
    MUL_STR_LITERAL reduce using rule 207 (bool-literal -> E_TRUE .)
    INT             reduce using rule 207 (bool-literal -> E_TRUE .)
    DOUBLE          reduce using rule 207 (bool-literal -> E_TRUE .)
    INF             reduce using rule 207 (bool-literal -> E_TRUE .)
    NAN             reduce using rule 207 (bool-literal -> E_TRUE .)
    E_TRUE          reduce using rule 207 (bool-literal -> E_TRUE .)
    E_FALSE         reduce using rule 207 (bool-literal -> E_TRUE .)
    ID              reduce using rule 207 (bool-literal -> E_TRUE .)


state 137

    (208) bool-literal -> E_FALSE .

    LBRACKET        reduce using rule 208 (bool-literal -> E_FALSE .)
    DOT             reduce using rule 208 (bool-literal -> E_FALSE .)
    MULT            reduce using rule 208 (bool-literal -> E_FALSE .)
    DIV             reduce using rule 208 (bool-literal -> E_FALSE .)
    MULTPER         reduce using rule 208 (bool-literal -> E_FALSE .)
    DOUBLEPER       reduce using rule 208 (bool-literal -> E_FALSE .)
    MOD             reduce using rule 208 (bool-literal -> E_FALSE .)
    PLUS            reduce using rule 208 (bool-literal -> E_FALSE .)
    MINUS           reduce using rule 208 (bool-literal -> E_FALSE .)
    LESS            reduce using rule 208 (bool-literal -> E_FALSE .)
    LESS_EQ         reduce using rule 208 (bool-literal -> E_FALSE .)
    EQUAL           reduce using rule 208 (bool-literal -> E_FALSE .)
    GREATER         reduce using rule 208 (bool-literal -> E_FALSE .)
    GREATER_EQ      reduce using rule 208 (bool-literal -> E_FALSE .)
    NOT_EQUAL       reduce using rule 208 (bool-literal -> E_FALSE .)
    LOG_AND         reduce using rule 208 (bool-literal -> E_FALSE .)
    LOG_OR          reduce using rule 208 (bool-literal -> E_FALSE .)
    SEMICOLON       reduce using rule 208 (bool-literal -> E_FALSE .)
    RPAREN          reduce using rule 208 (bool-literal -> E_FALSE .)
    RBRACKET        reduce using rule 208 (bool-literal -> E_FALSE .)
    ARROW           reduce using rule 208 (bool-literal -> E_FALSE .)
    COMMA           reduce using rule 208 (bool-literal -> E_FALSE .)
    COLON           reduce using rule 208 (bool-literal -> E_FALSE .)
    AT              reduce using rule 208 (bool-literal -> E_FALSE .)
    S_FOREACH       reduce using rule 208 (bool-literal -> E_FALSE .)
    S_FOR           reduce using rule 208 (bool-literal -> E_FALSE .)
    C_APP           reduce using rule 208 (bool-literal -> E_FALSE .)
    D_FUNCTION      reduce using rule 208 (bool-literal -> E_FALSE .)
    LPAREN          reduce using rule 208 (bool-literal -> E_FALSE .)
    RBRACE          reduce using rule 208 (bool-literal -> E_FALSE .)
    LBRACE          reduce using rule 208 (bool-literal -> E_FALSE .)
    E_STDIN         reduce using rule 208 (bool-literal -> E_FALSE .)
    E_STDOUT        reduce using rule 208 (bool-literal -> E_FALSE .)
    E_STDERR        reduce using rule 208 (bool-literal -> E_FALSE .)
    STR_LITERAL     reduce using rule 208 (bool-literal -> E_FALSE .)
    MUL_STR_LITERAL reduce using rule 208 (bool-literal -> E_FALSE .)
    INT             reduce using rule 208 (bool-literal -> E_FALSE .)
    DOUBLE          reduce using rule 208 (bool-literal -> E_FALSE .)
    INF             reduce using rule 208 (bool-literal -> E_FALSE .)
    NAN             reduce using rule 208 (bool-literal -> E_FALSE .)
    E_TRUE          reduce using rule 208 (bool-literal -> E_FALSE .)
    E_FALSE         reduce using rule 208 (bool-literal -> E_FALSE .)
    ID              reduce using rule 208 (bool-literal -> E_FALSE .)


state 138

    (184) array-list-constructor -> LBRACKET . opt-expr-list RBRACKET
    (187) array-range-constructor -> LBRACKET . expr COLON expr opt-coloned-expr RBRACKET
    (185) opt-expr-list -> .
    (186) opt-expr-list -> . expr-list
    (129) expr -> . or-expr
    (209) expr-list -> . expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    RBRACKET        reduce using rule 185 (opt-expr-list -> .)
    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    opt-expr-list                  shift and go to state 199
    expr                           shift and go to state 200
    expr-list                      shift and go to state 201
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 139

    (190) array-kv-constructor -> LBRACE . opt-array-constructor RBRACE
    (191) opt-array-constructor -> .
    (192) opt-array-constructor -> . array-kv-elem comma-array-kv-elem-star
    (195) array-kv-elem -> . expr COLON expr
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    RBRACE          reduce using rule 191 (opt-array-constructor -> .)
    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    opt-array-constructor          shift and go to state 202
    array-kv-elem                  shift and go to state 203
    expr                           shift and go to state 204
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 140

    (85) block -> LBRACE translation-unit RBRACE .

    SEMICOLON       reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    C_GLOBAL        reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    D_IMPORT        reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    C_PRAGMA        reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    LBRACE          reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    S_IF            reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    S_SWITCH        reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    E_WAIT          reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    S_ITERATE       reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    ID              reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    AT              reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    LPAREN          reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    class_INT       reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    class_DOUBLE    reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    class_FLOAT     reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    class_VOID      reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    class_UINT      reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    class_BOOL      reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    class_CHARACTER reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    class_String    reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    collection_SET  reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    collection_ARRAY reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    collection_DICT reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    S_FOREACH       reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    S_FOR           reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    C_APP           reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    D_FUNCTION      reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    LESS            reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    $end            reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    RBRACE          reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    S_CASE          reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    S_DEFAULT       reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    S_UNTIL         reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)
    S_ELSE          reduce using rule 85 (block -> LBRACE translation-unit RBRACE .)


state 141

    (101) if-stmt -> S_IF LPAREN expr . RPAREN block opt-else-block

    RPAREN          shift and go to state 205


state 142

    (99) lval-or-paren-lval -> LPAREN lval-list RPAREN .

    ASSIGN          reduce using rule 99 (lval-or-paren-lval -> LPAREN lval-list RPAREN .)
    PLUS_AS         reduce using rule 99 (lval-or-paren-lval -> LPAREN lval-list RPAREN .)


state 143

    (104) switch-stmt -> S_SWITCH LPAREN expr . RPAREN LBRACE case-star opt-default RBRACE

    RPAREN          shift and go to state 206


state 144

    (111) wait-stmt -> E_WAIT opt-deep LPAREN . expr-list RPAREN block
    (209) expr-list -> . expr
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr-list                      shift and go to state 207
    expr                           shift and go to state 167
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 145

    (114) foreach-loop -> annotation-star S_FOREACH var-name . opt-comma-var-name S_IN expr block
    (115) opt-comma-var-name -> .
    (116) opt-comma-var-name -> . COMMA var-name

    S_IN            reduce using rule 115 (opt-comma-var-name -> .)
    COMMA           shift and go to state 209

    opt-comma-var-name             shift and go to state 208

state 146

    (117) for-loop -> annotation-star S_FOR LPAREN . for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
    (119) for-init-list -> . for-init for-init-star
    (122) for-init -> . for-assignment
    (123) for-init -> . type-prefix var-name type-suffix ASSIGN expr
    (127) for-assignment -> . var-name ASSIGN expr
    (76) type-prefix -> . type-name
    (77) type-prefix -> . param-type
    (223) var-name -> . ID
    (210) type-name -> . class_INT
    (211) type-name -> . class_DOUBLE
    (212) type-name -> . class_FLOAT
    (213) type-name -> . class_VOID
    (214) type-name -> . class_UINT
    (215) type-name -> . class_BOOL
    (216) type-name -> . class_CHARACTER
    (217) type-name -> . class_String
    (218) type-name -> . collection_SET
    (219) type-name -> . collection_ARRAY
    (220) type-name -> . collection_DICT
    (221) type-name -> . ID
    (78) param-type -> . type-name LESS standalone-type GREATER

    ID              shift and go to state 22
    class_INT       shift and go to state 44
    class_DOUBLE    shift and go to state 45
    class_FLOAT     shift and go to state 46
    class_VOID      shift and go to state 47
    class_UINT      shift and go to state 48
    class_BOOL      shift and go to state 49
    class_CHARACTER shift and go to state 50
    class_String    shift and go to state 51
    collection_SET  shift and go to state 52
    collection_ARRAY shift and go to state 53
    collection_DICT shift and go to state 54

    for-init-list                  shift and go to state 210
    for-init                       shift and go to state 211
    for-assignment                 shift and go to state 212
    type-prefix                    shift and go to state 213
    var-name                       shift and go to state 214
    type-name                      shift and go to state 41
    param-type                     shift and go to state 42

state 147

    (46) swift-func-defn -> annotation-star func-hdr ARROW . block
    (85) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 26

    block                          shift and go to state 215

state 148

    (60) foreign-func-defn -> annotation-star func-hdr foreign-func-body .

    SEMICOLON       reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    C_GLOBAL        reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    D_IMPORT        reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    C_PRAGMA        reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    LBRACE          reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    S_IF            reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    S_SWITCH        reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    E_WAIT          reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    S_ITERATE       reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    ID              reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    AT              reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    LPAREN          reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    class_INT       reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    class_DOUBLE    reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    class_FLOAT     reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    class_VOID      reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    class_UINT      reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    class_BOOL      reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    class_CHARACTER reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    class_String    reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    collection_SET  reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    collection_ARRAY reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    collection_DICT reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    S_FOREACH       reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    S_FOR           reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    C_APP           reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    D_FUNCTION      reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    LESS            reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    $end            reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    RBRACE          reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    S_CASE          reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)
    S_DEFAULT       reduce using rule 60 (foreign-func-defn -> annotation-star func-hdr foreign-func-body .)


state 149

    (61) foreign-func-body -> STR_LITERAL . STR_LITERAL empty-or-literal empty-or-more-literals

    STR_LITERAL     shift and go to state 216


state 150

    (49) app-func-defn -> annotation-star C_APP func-hdr . LBRACE app-body RBRACE

    LBRACE          shift and go to state 217


state 151

    (172) func-call -> annotation-star func-name LPAREN . func-call-arg-list RPAREN
    (173) func-call-arg-list -> . expr-or-kw func-call-arg-star
    (176) expr-or-kw -> . expr
    (177) expr-or-kw -> . kw-expr
    (129) expr -> . or-expr
    (198) kw-expr -> . ID ASSIGN expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    ID              shift and go to state 222
    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    annotation-star                shift and go to state 129
    func-call-arg-list             shift and go to state 218
    expr-or-kw                     shift and go to state 219
    expr                           shift and go to state 220
    kw-expr                        shift and go to state 221
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 152

    (28) func-hdr -> type-params formal-arg-list . func-name empty-or-arg-list
    (224) func-name -> . D_FUNCTION ID

    D_FUNCTION      shift and go to state 76

    func-name                      shift and go to state 223

state 153

    (36) formal-arg-list -> LPAREN . opt-formal-args RPAREN
    (37) opt-formal-args -> .
    (38) opt-formal-args -> . formal-arg comma-args-star
    (41) formal-arg -> . type-prefix empty-or-range var-name type-suffix empty-or-ass-expr
    (76) type-prefix -> . type-name
    (77) type-prefix -> . param-type
    (210) type-name -> . class_INT
    (211) type-name -> . class_DOUBLE
    (212) type-name -> . class_FLOAT
    (213) type-name -> . class_VOID
    (214) type-name -> . class_UINT
    (215) type-name -> . class_BOOL
    (216) type-name -> . class_CHARACTER
    (217) type-name -> . class_String
    (218) type-name -> . collection_SET
    (219) type-name -> . collection_ARRAY
    (220) type-name -> . collection_DICT
    (221) type-name -> . ID
    (78) param-type -> . type-name LESS standalone-type GREATER

    RPAREN          reduce using rule 37 (opt-formal-args -> .)
    class_INT       shift and go to state 44
    class_DOUBLE    shift and go to state 45
    class_FLOAT     shift and go to state 46
    class_VOID      shift and go to state 47
    class_UINT      shift and go to state 48
    class_BOOL      shift and go to state 49
    class_CHARACTER shift and go to state 50
    class_String    shift and go to state 51
    collection_SET  shift and go to state 52
    collection_ARRAY shift and go to state 53
    collection_DICT shift and go to state 54
    ID              shift and go to state 100

    opt-formal-args                shift and go to state 224
    formal-arg                     shift and go to state 225
    type-prefix                    shift and go to state 226
    type-name                      shift and go to state 41
    param-type                     shift and go to state 42

state 154

    (224) func-name -> D_FUNCTION ID .

    LPAREN          reduce using rule 224 (func-name -> D_FUNCTION ID .)
    ARROW           reduce using rule 224 (func-name -> D_FUNCTION ID .)
    STR_LITERAL     reduce using rule 224 (func-name -> D_FUNCTION ID .)
    LBRACE          reduce using rule 224 (func-name -> D_FUNCTION ID .)


state 155

    (32) type-params -> LESS var-name . comma-name-star GREATER
    (33) comma-name-star -> .
    (34) comma-name-star -> . COMMA var-name comma-name-star

    GREATER         reduce using rule 33 (comma-name-star -> .)
    COMMA           shift and go to state 228

    comma-name-star                shift and go to state 227

state 156

    (100) update-stmt -> var-name LESS ID . GREATER UPD expr SEMICOLON

    GREATER         shift and go to state 229


state 157

    (230) subscript-star -> array-subscript subscript-star .

    COMMA           reduce using rule 230 (subscript-star -> array-subscript subscript-star .)
    ASSIGN          reduce using rule 230 (subscript-star -> array-subscript subscript-star .)
    PLUS_AS         reduce using rule 230 (subscript-star -> array-subscript subscript-star .)
    RPAREN          reduce using rule 230 (subscript-star -> array-subscript subscript-star .)


state 158

    (231) subscript-star -> struct-subscript subscript-star .

    COMMA           reduce using rule 231 (subscript-star -> struct-subscript subscript-star .)
    ASSIGN          reduce using rule 231 (subscript-star -> struct-subscript subscript-star .)
    PLUS_AS         reduce using rule 231 (subscript-star -> struct-subscript subscript-star .)
    RPAREN          reduce using rule 231 (subscript-star -> struct-subscript subscript-star .)


state 159

    (164) array-subscript -> LBRACKET expr . RBRACKET

    RBRACKET        shift and go to state 230


state 160

    (165) struct-subscript -> DOT ID .

    LBRACKET        reduce using rule 165 (struct-subscript -> DOT ID .)
    DOT             reduce using rule 165 (struct-subscript -> DOT ID .)
    COMMA           reduce using rule 165 (struct-subscript -> DOT ID .)
    ASSIGN          reduce using rule 165 (struct-subscript -> DOT ID .)
    PLUS_AS         reduce using rule 165 (struct-subscript -> DOT ID .)
    RPAREN          reduce using rule 165 (struct-subscript -> DOT ID .)
    MULT            reduce using rule 165 (struct-subscript -> DOT ID .)
    DIV             reduce using rule 165 (struct-subscript -> DOT ID .)
    MULTPER         reduce using rule 165 (struct-subscript -> DOT ID .)
    DOUBLEPER       reduce using rule 165 (struct-subscript -> DOT ID .)
    MOD             reduce using rule 165 (struct-subscript -> DOT ID .)
    PLUS            reduce using rule 165 (struct-subscript -> DOT ID .)
    MINUS           reduce using rule 165 (struct-subscript -> DOT ID .)
    LESS            reduce using rule 165 (struct-subscript -> DOT ID .)
    LESS_EQ         reduce using rule 165 (struct-subscript -> DOT ID .)
    EQUAL           reduce using rule 165 (struct-subscript -> DOT ID .)
    GREATER         reduce using rule 165 (struct-subscript -> DOT ID .)
    GREATER_EQ      reduce using rule 165 (struct-subscript -> DOT ID .)
    NOT_EQUAL       reduce using rule 165 (struct-subscript -> DOT ID .)
    LOG_AND         reduce using rule 165 (struct-subscript -> DOT ID .)
    LOG_OR          reduce using rule 165 (struct-subscript -> DOT ID .)
    SEMICOLON       reduce using rule 165 (struct-subscript -> DOT ID .)
    RBRACKET        reduce using rule 165 (struct-subscript -> DOT ID .)
    ARROW           reduce using rule 165 (struct-subscript -> DOT ID .)
    COLON           reduce using rule 165 (struct-subscript -> DOT ID .)
    AT              reduce using rule 165 (struct-subscript -> DOT ID .)
    S_FOREACH       reduce using rule 165 (struct-subscript -> DOT ID .)
    S_FOR           reduce using rule 165 (struct-subscript -> DOT ID .)
    C_APP           reduce using rule 165 (struct-subscript -> DOT ID .)
    D_FUNCTION      reduce using rule 165 (struct-subscript -> DOT ID .)
    LPAREN          reduce using rule 165 (struct-subscript -> DOT ID .)
    RBRACE          reduce using rule 165 (struct-subscript -> DOT ID .)
    LBRACE          reduce using rule 165 (struct-subscript -> DOT ID .)
    E_STDIN         reduce using rule 165 (struct-subscript -> DOT ID .)
    E_STDOUT        reduce using rule 165 (struct-subscript -> DOT ID .)
    E_STDERR        reduce using rule 165 (struct-subscript -> DOT ID .)


state 161

    (128) iterate-loop -> S_ITERATE var-name block . S_UNTIL LPAREN expr RPAREN

    S_UNTIL         shift and go to state 231


state 162

    (86) stmt-chain -> chainable-stmt semicolon-or-arrow statement .

    SEMICOLON       reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    C_GLOBAL        reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    D_IMPORT        reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    C_PRAGMA        reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    LBRACE          reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_IF            reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_SWITCH        reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    E_WAIT          reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_ITERATE       reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    ID              reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    AT              reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    LPAREN          reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_INT       reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_DOUBLE    reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_FLOAT     reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_VOID      reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_UINT      reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_BOOL      reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_CHARACTER reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    class_String    reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    collection_SET  reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    collection_ARRAY reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    collection_DICT reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_FOREACH       reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_FOR           reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    C_APP           reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    D_FUNCTION      reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    LESS            reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    $end            reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    RBRACE          reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_CASE          reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)
    S_DEFAULT       reduce using rule 86 (stmt-chain -> chainable-stmt semicolon-or-arrow statement .)


state 163

    (198) kw-expr -> ID ASSIGN . expr
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 232
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 164

    (71) var-decl-rest -> var-name type-suffix . empty-or-var-mappign empty-or-assign-expr
    (72) empty-or-var-mappign -> .
    (73) empty-or-var-mappign -> . var-mapping
    (84) var-mapping -> . LESS expr GREATER

    ASSIGN          reduce using rule 72 (empty-or-var-mappign -> .)
    SEMICOLON       reduce using rule 72 (empty-or-var-mappign -> .)
    ARROW           reduce using rule 72 (empty-or-var-mappign -> .)
    LESS            shift and go to state 235

    empty-or-var-mappign           shift and go to state 233
    var-mapping                    shift and go to state 234

state 165

    (80) type-suffix -> LBRACKET . empty-or-standalone-type RBRACKET type-suffix
    (81) empty-or-standalone-type -> .
    (82) empty-or-standalone-type -> . standalone-type
    (83) standalone-type -> . type-prefix type-suffix
    (76) type-prefix -> . type-name
    (77) type-prefix -> . param-type
    (210) type-name -> . class_INT
    (211) type-name -> . class_DOUBLE
    (212) type-name -> . class_FLOAT
    (213) type-name -> . class_VOID
    (214) type-name -> . class_UINT
    (215) type-name -> . class_BOOL
    (216) type-name -> . class_CHARACTER
    (217) type-name -> . class_String
    (218) type-name -> . collection_SET
    (219) type-name -> . collection_ARRAY
    (220) type-name -> . collection_DICT
    (221) type-name -> . ID
    (78) param-type -> . type-name LESS standalone-type GREATER

    RBRACKET        reduce using rule 81 (empty-or-standalone-type -> .)
    class_INT       shift and go to state 44
    class_DOUBLE    shift and go to state 45
    class_FLOAT     shift and go to state 46
    class_VOID      shift and go to state 47
    class_UINT      shift and go to state 48
    class_BOOL      shift and go to state 49
    class_CHARACTER shift and go to state 50
    class_String    shift and go to state 51
    collection_SET  shift and go to state 52
    collection_ARRAY shift and go to state 53
    collection_DICT shift and go to state 54
    ID              shift and go to state 100

    empty-or-standalone-type       shift and go to state 236
    standalone-type                shift and go to state 237
    type-prefix                    shift and go to state 169
    type-name                      shift and go to state 41
    param-type                     shift and go to state 42

state 166

    (93) assignment -> lval-or-paren-lval assign-or-plusas expr-list .

    SEMICOLON       reduce using rule 93 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)
    ARROW           reduce using rule 93 (assignment -> lval-or-paren-lval assign-or-plusas expr-list .)


state 167

    (209) expr-list -> expr .

    SEMICOLON       reduce using rule 209 (expr-list -> expr .)
    ARROW           reduce using rule 209 (expr-list -> expr .)
    RPAREN          reduce using rule 209 (expr-list -> expr .)


state 168

    (78) param-type -> type-name LESS standalone-type . GREATER

    GREATER         shift and go to state 238


state 169

    (83) standalone-type -> type-prefix . type-suffix
    (79) type-suffix -> .
    (80) type-suffix -> . LBRACKET empty-or-standalone-type RBRACKET type-suffix

    GREATER         reduce using rule 79 (type-suffix -> .)
    RBRACKET        reduce using rule 79 (type-suffix -> .)
    LBRACKET        shift and go to state 165

    type-suffix                    shift and go to state 239

state 170

    (227) lval-expr-star -> COMMA lval-expr . lval-expr-star
    (226) lval-expr-star -> .
    (227) lval-expr-star -> . COMMA lval-expr lval-expr-star

    ASSIGN          reduce using rule 226 (lval-expr-star -> .)
    PLUS_AS         reduce using rule 226 (lval-expr-star -> .)
    RPAREN          reduce using rule 226 (lval-expr-star -> .)
    COMMA           shift and go to state 98

    lval-expr-star                 shift and go to state 240

state 171

    (18) global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .

    SEMICOLON       reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    C_GLOBAL        reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    D_IMPORT        reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    C_PRAGMA        reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    LBRACE          reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_IF            reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_SWITCH        reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    E_WAIT          reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_ITERATE       reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    ID              reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    AT              reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    LPAREN          reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_INT       reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_DOUBLE    reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_FLOAT     reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_VOID      reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_UINT      reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_BOOL      reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_CHARACTER reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    class_String    reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    collection_SET  reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    collection_ARRAY reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    collection_DICT reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_FOREACH       reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_FOR           reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    C_APP           reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    D_FUNCTION      reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    LESS            reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    $end            reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    RBRACE          reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_CASE          reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)
    S_DEFAULT       reduce using rule 18 (global-const-defn -> C_GLOBAL C_CONST var-decl SEMICOLON .)


state 172

    (23) path-star -> DOT ID . path-star
    (22) path-star -> .
    (23) path-star -> . DOT ID path-star

    SEMICOLON       reduce using rule 22 (path-star -> .)
    DOT             shift and go to state 104

    path-star                      shift and go to state 241

state 173

    (24) pragma-stmt -> C_PRAGMA ID expr SEMICOLON .

    SEMICOLON       reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    C_GLOBAL        reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    D_IMPORT        reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    C_PRAGMA        reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    LBRACE          reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_IF            reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_SWITCH        reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    E_WAIT          reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_ITERATE       reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    ID              reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    AT              reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    LPAREN          reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_INT       reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_DOUBLE    reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_FLOAT     reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_VOID      reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_UINT      reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_BOOL      reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_CHARACTER reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    class_String    reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    collection_SET  reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    collection_ARRAY reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    collection_DICT reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_FOREACH       reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_FOR           reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    C_APP           reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    D_FUNCTION      reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    LESS            reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    $end            reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    RBRACE          reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_CASE          reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)
    S_DEFAULT       reduce using rule 24 (pragma-stmt -> C_PRAGMA ID expr SEMICOLON .)


state 174

    (131) or-expr -> or-expr LOG_OR . and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    and-expr                       shift and go to state 242
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 175

    (133) and-expr -> and-expr LOG_AND . eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    eq-expr                        shift and go to state 243
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 176

    (135) eq-expr -> eq-expr eq-or-not-eq . eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    eq-expr                        shift and go to state 244
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 177

    (136) eq-or-not-eq -> EQUAL .

    MINUS           reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    EXCLAMATION     reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    LPAREN          reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    STR_LITERAL     reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    MUL_STR_LITERAL reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    INT             reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    ID              reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    DOUBLE          reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    INF             reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    NAN             reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    E_TRUE          reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    E_FALSE         reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    LBRACKET        reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    LBRACE          reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    AT              reduce using rule 136 (eq-or-not-eq -> EQUAL .)
    D_FUNCTION      reduce using rule 136 (eq-or-not-eq -> EQUAL .)


state 178

    (137) eq-or-not-eq -> NOT_EQUAL .

    MINUS           reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    EXCLAMATION     reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    LPAREN          reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    STR_LITERAL     reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    MUL_STR_LITERAL reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    INT             reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    ID              reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    DOUBLE          reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    INF             reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    NAN             reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    E_TRUE          reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    E_FALSE         reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    LBRACKET        reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    LBRACE          reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    AT              reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)
    D_FUNCTION      reduce using rule 137 (eq-or-not-eq -> NOT_EQUAL .)


state 179

    (139) cmp-expr -> cmp-expr cmp-sign . add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    add-expr                       shift and go to state 245
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 180

    (140) cmp-sign -> LESS .

    MINUS           reduce using rule 140 (cmp-sign -> LESS .)
    EXCLAMATION     reduce using rule 140 (cmp-sign -> LESS .)
    LPAREN          reduce using rule 140 (cmp-sign -> LESS .)
    STR_LITERAL     reduce using rule 140 (cmp-sign -> LESS .)
    MUL_STR_LITERAL reduce using rule 140 (cmp-sign -> LESS .)
    INT             reduce using rule 140 (cmp-sign -> LESS .)
    ID              reduce using rule 140 (cmp-sign -> LESS .)
    DOUBLE          reduce using rule 140 (cmp-sign -> LESS .)
    INF             reduce using rule 140 (cmp-sign -> LESS .)
    NAN             reduce using rule 140 (cmp-sign -> LESS .)
    E_TRUE          reduce using rule 140 (cmp-sign -> LESS .)
    E_FALSE         reduce using rule 140 (cmp-sign -> LESS .)
    LBRACKET        reduce using rule 140 (cmp-sign -> LESS .)
    LBRACE          reduce using rule 140 (cmp-sign -> LESS .)
    AT              reduce using rule 140 (cmp-sign -> LESS .)
    D_FUNCTION      reduce using rule 140 (cmp-sign -> LESS .)


state 181

    (141) cmp-sign -> LESS_EQ .

    MINUS           reduce using rule 141 (cmp-sign -> LESS_EQ .)
    EXCLAMATION     reduce using rule 141 (cmp-sign -> LESS_EQ .)
    LPAREN          reduce using rule 141 (cmp-sign -> LESS_EQ .)
    STR_LITERAL     reduce using rule 141 (cmp-sign -> LESS_EQ .)
    MUL_STR_LITERAL reduce using rule 141 (cmp-sign -> LESS_EQ .)
    INT             reduce using rule 141 (cmp-sign -> LESS_EQ .)
    ID              reduce using rule 141 (cmp-sign -> LESS_EQ .)
    DOUBLE          reduce using rule 141 (cmp-sign -> LESS_EQ .)
    INF             reduce using rule 141 (cmp-sign -> LESS_EQ .)
    NAN             reduce using rule 141 (cmp-sign -> LESS_EQ .)
    E_TRUE          reduce using rule 141 (cmp-sign -> LESS_EQ .)
    E_FALSE         reduce using rule 141 (cmp-sign -> LESS_EQ .)
    LBRACKET        reduce using rule 141 (cmp-sign -> LESS_EQ .)
    LBRACE          reduce using rule 141 (cmp-sign -> LESS_EQ .)
    AT              reduce using rule 141 (cmp-sign -> LESS_EQ .)
    D_FUNCTION      reduce using rule 141 (cmp-sign -> LESS_EQ .)


state 182

    (142) cmp-sign -> EQUAL .

    MINUS           reduce using rule 142 (cmp-sign -> EQUAL .)
    EXCLAMATION     reduce using rule 142 (cmp-sign -> EQUAL .)
    LPAREN          reduce using rule 142 (cmp-sign -> EQUAL .)
    STR_LITERAL     reduce using rule 142 (cmp-sign -> EQUAL .)
    MUL_STR_LITERAL reduce using rule 142 (cmp-sign -> EQUAL .)
    INT             reduce using rule 142 (cmp-sign -> EQUAL .)
    ID              reduce using rule 142 (cmp-sign -> EQUAL .)
    DOUBLE          reduce using rule 142 (cmp-sign -> EQUAL .)
    INF             reduce using rule 142 (cmp-sign -> EQUAL .)
    NAN             reduce using rule 142 (cmp-sign -> EQUAL .)
    E_TRUE          reduce using rule 142 (cmp-sign -> EQUAL .)
    E_FALSE         reduce using rule 142 (cmp-sign -> EQUAL .)
    LBRACKET        reduce using rule 142 (cmp-sign -> EQUAL .)
    LBRACE          reduce using rule 142 (cmp-sign -> EQUAL .)
    AT              reduce using rule 142 (cmp-sign -> EQUAL .)
    D_FUNCTION      reduce using rule 142 (cmp-sign -> EQUAL .)


state 183

    (143) cmp-sign -> GREATER .

    MINUS           reduce using rule 143 (cmp-sign -> GREATER .)
    EXCLAMATION     reduce using rule 143 (cmp-sign -> GREATER .)
    LPAREN          reduce using rule 143 (cmp-sign -> GREATER .)
    STR_LITERAL     reduce using rule 143 (cmp-sign -> GREATER .)
    MUL_STR_LITERAL reduce using rule 143 (cmp-sign -> GREATER .)
    INT             reduce using rule 143 (cmp-sign -> GREATER .)
    ID              reduce using rule 143 (cmp-sign -> GREATER .)
    DOUBLE          reduce using rule 143 (cmp-sign -> GREATER .)
    INF             reduce using rule 143 (cmp-sign -> GREATER .)
    NAN             reduce using rule 143 (cmp-sign -> GREATER .)
    E_TRUE          reduce using rule 143 (cmp-sign -> GREATER .)
    E_FALSE         reduce using rule 143 (cmp-sign -> GREATER .)
    LBRACKET        reduce using rule 143 (cmp-sign -> GREATER .)
    LBRACE          reduce using rule 143 (cmp-sign -> GREATER .)
    AT              reduce using rule 143 (cmp-sign -> GREATER .)
    D_FUNCTION      reduce using rule 143 (cmp-sign -> GREATER .)


state 184

    (144) cmp-sign -> GREATER_EQ .

    MINUS           reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    EXCLAMATION     reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    LPAREN          reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    STR_LITERAL     reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    MUL_STR_LITERAL reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    INT             reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    ID              reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    DOUBLE          reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    INF             reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    NAN             reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    E_TRUE          reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    E_FALSE         reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    LBRACKET        reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    LBRACE          reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    AT              reduce using rule 144 (cmp-sign -> GREATER_EQ .)
    D_FUNCTION      reduce using rule 144 (cmp-sign -> GREATER_EQ .)


state 185

    (146) add-expr -> add-expr add-sign . mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    mult-expr                      shift and go to state 246
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 186

    (147) add-sign -> PLUS .

    MINUS           reduce using rule 147 (add-sign -> PLUS .)
    EXCLAMATION     reduce using rule 147 (add-sign -> PLUS .)
    LPAREN          reduce using rule 147 (add-sign -> PLUS .)
    STR_LITERAL     reduce using rule 147 (add-sign -> PLUS .)
    MUL_STR_LITERAL reduce using rule 147 (add-sign -> PLUS .)
    INT             reduce using rule 147 (add-sign -> PLUS .)
    ID              reduce using rule 147 (add-sign -> PLUS .)
    DOUBLE          reduce using rule 147 (add-sign -> PLUS .)
    INF             reduce using rule 147 (add-sign -> PLUS .)
    NAN             reduce using rule 147 (add-sign -> PLUS .)
    E_TRUE          reduce using rule 147 (add-sign -> PLUS .)
    E_FALSE         reduce using rule 147 (add-sign -> PLUS .)
    LBRACKET        reduce using rule 147 (add-sign -> PLUS .)
    LBRACE          reduce using rule 147 (add-sign -> PLUS .)
    AT              reduce using rule 147 (add-sign -> PLUS .)
    D_FUNCTION      reduce using rule 147 (add-sign -> PLUS .)


state 187

    (148) add-sign -> MINUS .

    MINUS           reduce using rule 148 (add-sign -> MINUS .)
    EXCLAMATION     reduce using rule 148 (add-sign -> MINUS .)
    LPAREN          reduce using rule 148 (add-sign -> MINUS .)
    STR_LITERAL     reduce using rule 148 (add-sign -> MINUS .)
    MUL_STR_LITERAL reduce using rule 148 (add-sign -> MINUS .)
    INT             reduce using rule 148 (add-sign -> MINUS .)
    ID              reduce using rule 148 (add-sign -> MINUS .)
    DOUBLE          reduce using rule 148 (add-sign -> MINUS .)
    INF             reduce using rule 148 (add-sign -> MINUS .)
    NAN             reduce using rule 148 (add-sign -> MINUS .)
    E_TRUE          reduce using rule 148 (add-sign -> MINUS .)
    E_FALSE         reduce using rule 148 (add-sign -> MINUS .)
    LBRACKET        reduce using rule 148 (add-sign -> MINUS .)
    LBRACE          reduce using rule 148 (add-sign -> MINUS .)
    AT              reduce using rule 148 (add-sign -> MINUS .)
    D_FUNCTION      reduce using rule 148 (add-sign -> MINUS .)


state 188

    (150) mult-expr -> mult-expr mult-sign . unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    unary-expr                     shift and go to state 247
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 189

    (151) mult-sign -> MULT .

    MINUS           reduce using rule 151 (mult-sign -> MULT .)
    EXCLAMATION     reduce using rule 151 (mult-sign -> MULT .)
    LPAREN          reduce using rule 151 (mult-sign -> MULT .)
    STR_LITERAL     reduce using rule 151 (mult-sign -> MULT .)
    MUL_STR_LITERAL reduce using rule 151 (mult-sign -> MULT .)
    INT             reduce using rule 151 (mult-sign -> MULT .)
    ID              reduce using rule 151 (mult-sign -> MULT .)
    DOUBLE          reduce using rule 151 (mult-sign -> MULT .)
    INF             reduce using rule 151 (mult-sign -> MULT .)
    NAN             reduce using rule 151 (mult-sign -> MULT .)
    E_TRUE          reduce using rule 151 (mult-sign -> MULT .)
    E_FALSE         reduce using rule 151 (mult-sign -> MULT .)
    LBRACKET        reduce using rule 151 (mult-sign -> MULT .)
    LBRACE          reduce using rule 151 (mult-sign -> MULT .)
    AT              reduce using rule 151 (mult-sign -> MULT .)
    D_FUNCTION      reduce using rule 151 (mult-sign -> MULT .)


state 190

    (152) mult-sign -> DIV .

    MINUS           reduce using rule 152 (mult-sign -> DIV .)
    EXCLAMATION     reduce using rule 152 (mult-sign -> DIV .)
    LPAREN          reduce using rule 152 (mult-sign -> DIV .)
    STR_LITERAL     reduce using rule 152 (mult-sign -> DIV .)
    MUL_STR_LITERAL reduce using rule 152 (mult-sign -> DIV .)
    INT             reduce using rule 152 (mult-sign -> DIV .)
    ID              reduce using rule 152 (mult-sign -> DIV .)
    DOUBLE          reduce using rule 152 (mult-sign -> DIV .)
    INF             reduce using rule 152 (mult-sign -> DIV .)
    NAN             reduce using rule 152 (mult-sign -> DIV .)
    E_TRUE          reduce using rule 152 (mult-sign -> DIV .)
    E_FALSE         reduce using rule 152 (mult-sign -> DIV .)
    LBRACKET        reduce using rule 152 (mult-sign -> DIV .)
    LBRACE          reduce using rule 152 (mult-sign -> DIV .)
    AT              reduce using rule 152 (mult-sign -> DIV .)
    D_FUNCTION      reduce using rule 152 (mult-sign -> DIV .)


state 191

    (153) mult-sign -> MULTPER .

    MINUS           reduce using rule 153 (mult-sign -> MULTPER .)
    EXCLAMATION     reduce using rule 153 (mult-sign -> MULTPER .)
    LPAREN          reduce using rule 153 (mult-sign -> MULTPER .)
    STR_LITERAL     reduce using rule 153 (mult-sign -> MULTPER .)
    MUL_STR_LITERAL reduce using rule 153 (mult-sign -> MULTPER .)
    INT             reduce using rule 153 (mult-sign -> MULTPER .)
    ID              reduce using rule 153 (mult-sign -> MULTPER .)
    DOUBLE          reduce using rule 153 (mult-sign -> MULTPER .)
    INF             reduce using rule 153 (mult-sign -> MULTPER .)
    NAN             reduce using rule 153 (mult-sign -> MULTPER .)
    E_TRUE          reduce using rule 153 (mult-sign -> MULTPER .)
    E_FALSE         reduce using rule 153 (mult-sign -> MULTPER .)
    LBRACKET        reduce using rule 153 (mult-sign -> MULTPER .)
    LBRACE          reduce using rule 153 (mult-sign -> MULTPER .)
    AT              reduce using rule 153 (mult-sign -> MULTPER .)
    D_FUNCTION      reduce using rule 153 (mult-sign -> MULTPER .)


state 192

    (154) mult-sign -> DOUBLEPER .

    MINUS           reduce using rule 154 (mult-sign -> DOUBLEPER .)
    EXCLAMATION     reduce using rule 154 (mult-sign -> DOUBLEPER .)
    LPAREN          reduce using rule 154 (mult-sign -> DOUBLEPER .)
    STR_LITERAL     reduce using rule 154 (mult-sign -> DOUBLEPER .)
    MUL_STR_LITERAL reduce using rule 154 (mult-sign -> DOUBLEPER .)
    INT             reduce using rule 154 (mult-sign -> DOUBLEPER .)
    ID              reduce using rule 154 (mult-sign -> DOUBLEPER .)
    DOUBLE          reduce using rule 154 (mult-sign -> DOUBLEPER .)
    INF             reduce using rule 154 (mult-sign -> DOUBLEPER .)
    NAN             reduce using rule 154 (mult-sign -> DOUBLEPER .)
    E_TRUE          reduce using rule 154 (mult-sign -> DOUBLEPER .)
    E_FALSE         reduce using rule 154 (mult-sign -> DOUBLEPER .)
    LBRACKET        reduce using rule 154 (mult-sign -> DOUBLEPER .)
    LBRACE          reduce using rule 154 (mult-sign -> DOUBLEPER .)
    AT              reduce using rule 154 (mult-sign -> DOUBLEPER .)
    D_FUNCTION      reduce using rule 154 (mult-sign -> DOUBLEPER .)


state 193

    (155) mult-sign -> MOD .

    MINUS           reduce using rule 155 (mult-sign -> MOD .)
    EXCLAMATION     reduce using rule 155 (mult-sign -> MOD .)
    LPAREN          reduce using rule 155 (mult-sign -> MOD .)
    STR_LITERAL     reduce using rule 155 (mult-sign -> MOD .)
    MUL_STR_LITERAL reduce using rule 155 (mult-sign -> MOD .)
    INT             reduce using rule 155 (mult-sign -> MOD .)
    ID              reduce using rule 155 (mult-sign -> MOD .)
    DOUBLE          reduce using rule 155 (mult-sign -> MOD .)
    INF             reduce using rule 155 (mult-sign -> MOD .)
    NAN             reduce using rule 155 (mult-sign -> MOD .)
    E_TRUE          reduce using rule 155 (mult-sign -> MOD .)
    E_FALSE         reduce using rule 155 (mult-sign -> MOD .)
    LBRACKET        reduce using rule 155 (mult-sign -> MOD .)
    LBRACE          reduce using rule 155 (mult-sign -> MOD .)
    AT              reduce using rule 155 (mult-sign -> MOD .)
    D_FUNCTION      reduce using rule 155 (mult-sign -> MOD .)


state 194

    (161) postfix-expr -> postfix-expr array-or-struct .

    LBRACKET        reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    DOT             reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    MULT            reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    DIV             reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    MULTPER         reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    DOUBLEPER       reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    MOD             reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    PLUS            reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    MINUS           reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    LESS            reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    LESS_EQ         reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    EQUAL           reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    GREATER         reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    GREATER_EQ      reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    NOT_EQUAL       reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    LOG_AND         reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    LOG_OR          reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    SEMICOLON       reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    RPAREN          reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    RBRACKET        reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    ARROW           reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    COMMA           reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    COLON           reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    AT              reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    S_FOREACH       reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    S_FOR           reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    C_APP           reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    D_FUNCTION      reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    LPAREN          reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    RBRACE          reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    LBRACE          reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    E_STDIN         reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    E_STDOUT        reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)
    E_STDERR        reduce using rule 161 (postfix-expr -> postfix-expr array-or-struct .)


state 195

    (162) array-or-struct -> array-subscript .

    LBRACKET        reduce using rule 162 (array-or-struct -> array-subscript .)
    DOT             reduce using rule 162 (array-or-struct -> array-subscript .)
    MULT            reduce using rule 162 (array-or-struct -> array-subscript .)
    DIV             reduce using rule 162 (array-or-struct -> array-subscript .)
    MULTPER         reduce using rule 162 (array-or-struct -> array-subscript .)
    DOUBLEPER       reduce using rule 162 (array-or-struct -> array-subscript .)
    MOD             reduce using rule 162 (array-or-struct -> array-subscript .)
    PLUS            reduce using rule 162 (array-or-struct -> array-subscript .)
    MINUS           reduce using rule 162 (array-or-struct -> array-subscript .)
    LESS            reduce using rule 162 (array-or-struct -> array-subscript .)
    LESS_EQ         reduce using rule 162 (array-or-struct -> array-subscript .)
    EQUAL           reduce using rule 162 (array-or-struct -> array-subscript .)
    GREATER         reduce using rule 162 (array-or-struct -> array-subscript .)
    GREATER_EQ      reduce using rule 162 (array-or-struct -> array-subscript .)
    NOT_EQUAL       reduce using rule 162 (array-or-struct -> array-subscript .)
    LOG_AND         reduce using rule 162 (array-or-struct -> array-subscript .)
    LOG_OR          reduce using rule 162 (array-or-struct -> array-subscript .)
    SEMICOLON       reduce using rule 162 (array-or-struct -> array-subscript .)
    RPAREN          reduce using rule 162 (array-or-struct -> array-subscript .)
    RBRACKET        reduce using rule 162 (array-or-struct -> array-subscript .)
    ARROW           reduce using rule 162 (array-or-struct -> array-subscript .)
    COMMA           reduce using rule 162 (array-or-struct -> array-subscript .)
    COLON           reduce using rule 162 (array-or-struct -> array-subscript .)
    AT              reduce using rule 162 (array-or-struct -> array-subscript .)
    S_FOREACH       reduce using rule 162 (array-or-struct -> array-subscript .)
    S_FOR           reduce using rule 162 (array-or-struct -> array-subscript .)
    C_APP           reduce using rule 162 (array-or-struct -> array-subscript .)
    D_FUNCTION      reduce using rule 162 (array-or-struct -> array-subscript .)
    LPAREN          reduce using rule 162 (array-or-struct -> array-subscript .)
    RBRACE          reduce using rule 162 (array-or-struct -> array-subscript .)
    LBRACE          reduce using rule 162 (array-or-struct -> array-subscript .)
    E_STDIN         reduce using rule 162 (array-or-struct -> array-subscript .)
    E_STDOUT        reduce using rule 162 (array-or-struct -> array-subscript .)
    E_STDERR        reduce using rule 162 (array-or-struct -> array-subscript .)


state 196

    (163) array-or-struct -> struct-subscript .

    LBRACKET        reduce using rule 163 (array-or-struct -> struct-subscript .)
    DOT             reduce using rule 163 (array-or-struct -> struct-subscript .)
    MULT            reduce using rule 163 (array-or-struct -> struct-subscript .)
    DIV             reduce using rule 163 (array-or-struct -> struct-subscript .)
    MULTPER         reduce using rule 163 (array-or-struct -> struct-subscript .)
    DOUBLEPER       reduce using rule 163 (array-or-struct -> struct-subscript .)
    MOD             reduce using rule 163 (array-or-struct -> struct-subscript .)
    PLUS            reduce using rule 163 (array-or-struct -> struct-subscript .)
    MINUS           reduce using rule 163 (array-or-struct -> struct-subscript .)
    LESS            reduce using rule 163 (array-or-struct -> struct-subscript .)
    LESS_EQ         reduce using rule 163 (array-or-struct -> struct-subscript .)
    EQUAL           reduce using rule 163 (array-or-struct -> struct-subscript .)
    GREATER         reduce using rule 163 (array-or-struct -> struct-subscript .)
    GREATER_EQ      reduce using rule 163 (array-or-struct -> struct-subscript .)
    NOT_EQUAL       reduce using rule 163 (array-or-struct -> struct-subscript .)
    LOG_AND         reduce using rule 163 (array-or-struct -> struct-subscript .)
    LOG_OR          reduce using rule 163 (array-or-struct -> struct-subscript .)
    SEMICOLON       reduce using rule 163 (array-or-struct -> struct-subscript .)
    RPAREN          reduce using rule 163 (array-or-struct -> struct-subscript .)
    RBRACKET        reduce using rule 163 (array-or-struct -> struct-subscript .)
    ARROW           reduce using rule 163 (array-or-struct -> struct-subscript .)
    COMMA           reduce using rule 163 (array-or-struct -> struct-subscript .)
    COLON           reduce using rule 163 (array-or-struct -> struct-subscript .)
    AT              reduce using rule 163 (array-or-struct -> struct-subscript .)
    S_FOREACH       reduce using rule 163 (array-or-struct -> struct-subscript .)
    S_FOR           reduce using rule 163 (array-or-struct -> struct-subscript .)
    C_APP           reduce using rule 163 (array-or-struct -> struct-subscript .)
    D_FUNCTION      reduce using rule 163 (array-or-struct -> struct-subscript .)
    LPAREN          reduce using rule 163 (array-or-struct -> struct-subscript .)
    RBRACE          reduce using rule 163 (array-or-struct -> struct-subscript .)
    LBRACE          reduce using rule 163 (array-or-struct -> struct-subscript .)
    E_STDIN         reduce using rule 163 (array-or-struct -> struct-subscript .)
    E_STDOUT        reduce using rule 163 (array-or-struct -> struct-subscript .)
    E_STDERR        reduce using rule 163 (array-or-struct -> struct-subscript .)


state 197

    (157) unary-expr -> minus-or-excl postfix-expr .
    (161) postfix-expr -> postfix-expr . array-or-struct
    (162) array-or-struct -> . array-subscript
    (163) array-or-struct -> . struct-subscript
    (164) array-subscript -> . LBRACKET expr RBRACKET
    (165) struct-subscript -> . DOT ID

    MULT            reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    DIV             reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    MULTPER         reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    DOUBLEPER       reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    MOD             reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    PLUS            reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    MINUS           reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    LESS            reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    LESS_EQ         reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    EQUAL           reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    GREATER         reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    GREATER_EQ      reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    NOT_EQUAL       reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    LOG_AND         reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    LOG_OR          reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    SEMICOLON       reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    RPAREN          reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    RBRACKET        reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    ARROW           reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    COMMA           reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    COLON           reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    AT              reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    S_FOREACH       reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    S_FOR           reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    C_APP           reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    D_FUNCTION      reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    LPAREN          reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    RBRACE          reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    LBRACE          reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    E_STDIN         reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    E_STDOUT        reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    E_STDERR        reduce using rule 157 (unary-expr -> minus-or-excl postfix-expr .)
    LBRACKET        shift and go to state 82
    DOT             shift and go to state 83

    array-or-struct                shift and go to state 194
    array-subscript                shift and go to state 195
    struct-subscript               shift and go to state 196

state 198

    (169) base-expr -> LPAREN expr . RPAREN
    (178) tuple-constructor -> LPAREN expr . COMMA expr comma-expr-star RPAREN

    RPAREN          shift and go to state 248
    COMMA           shift and go to state 249


state 199

    (184) array-list-constructor -> LBRACKET opt-expr-list . RBRACKET

    RBRACKET        shift and go to state 250


state 200

    (187) array-range-constructor -> LBRACKET expr . COLON expr opt-coloned-expr RBRACKET
    (209) expr-list -> expr .

    COLON           shift and go to state 251
    RBRACKET        reduce using rule 209 (expr-list -> expr .)


state 201

    (186) opt-expr-list -> expr-list .

    RBRACKET        reduce using rule 186 (opt-expr-list -> expr-list .)


state 202

    (190) array-kv-constructor -> LBRACE opt-array-constructor . RBRACE

    RBRACE          shift and go to state 252


state 203

    (192) opt-array-constructor -> array-kv-elem . comma-array-kv-elem-star
    (193) comma-array-kv-elem-star -> .
    (194) comma-array-kv-elem-star -> . COMMA array-kv-elem comma-array-kv-elem-star

    RBRACE          reduce using rule 193 (comma-array-kv-elem-star -> .)
    COMMA           shift and go to state 254

    comma-array-kv-elem-star       shift and go to state 253

state 204

    (195) array-kv-elem -> expr . COLON expr

    COLON           shift and go to state 255


state 205

    (101) if-stmt -> S_IF LPAREN expr RPAREN . block opt-else-block
    (85) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 26

    block                          shift and go to state 256

state 206

    (104) switch-stmt -> S_SWITCH LPAREN expr RPAREN . LBRACE case-star opt-default RBRACE

    LBRACE          shift and go to state 257


state 207

    (111) wait-stmt -> E_WAIT opt-deep LPAREN expr-list . RPAREN block

    RPAREN          shift and go to state 258


state 208

    (114) foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name . S_IN expr block

    S_IN            shift and go to state 259


state 209

    (116) opt-comma-var-name -> COMMA . var-name
    (223) var-name -> . ID

    ID              shift and go to state 66

    var-name                       shift and go to state 260

state 210

    (117) for-loop -> annotation-star S_FOR LPAREN for-init-list . SEMICOLON expr SEMICOLON for-update-list RPAREN block

    SEMICOLON       shift and go to state 261


state 211

    (119) for-init-list -> for-init . for-init-star
    (120) for-init-star -> .
    (121) for-init-star -> . COMMA for-init for-init-star

    SEMICOLON       reduce using rule 120 (for-init-star -> .)
    COMMA           shift and go to state 263

    for-init-star                  shift and go to state 262

state 212

    (122) for-init -> for-assignment .

    COMMA           reduce using rule 122 (for-init -> for-assignment .)
    SEMICOLON       reduce using rule 122 (for-init -> for-assignment .)


state 213

    (123) for-init -> type-prefix . var-name type-suffix ASSIGN expr
    (223) var-name -> . ID

    ID              shift and go to state 66

    var-name                       shift and go to state 264

state 214

    (127) for-assignment -> var-name . ASSIGN expr

    ASSIGN          shift and go to state 265


state 215

    (46) swift-func-defn -> annotation-star func-hdr ARROW block .

    SEMICOLON       reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    C_GLOBAL        reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    D_IMPORT        reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    C_PRAGMA        reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    LBRACE          reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    S_IF            reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    S_SWITCH        reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    E_WAIT          reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    S_ITERATE       reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    ID              reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    AT              reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    LPAREN          reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    class_INT       reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    class_DOUBLE    reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    class_FLOAT     reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    class_VOID      reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    class_UINT      reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    class_BOOL      reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    class_CHARACTER reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    class_String    reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    collection_SET  reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    collection_ARRAY reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    collection_DICT reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    S_FOREACH       reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    S_FOR           reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    C_APP           reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    D_FUNCTION      reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    LESS            reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    $end            reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    RBRACE          reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    S_CASE          reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)
    S_DEFAULT       reduce using rule 46 (swift-func-defn -> annotation-star func-hdr ARROW block .)


state 216

    (61) foreign-func-body -> STR_LITERAL STR_LITERAL . empty-or-literal empty-or-more-literals
    (62) empty-or-literal -> .
    (63) empty-or-literal -> . STR_LITERAL

    LBRACKET        reduce using rule 62 (empty-or-literal -> .)
    SEMICOLON       reduce using rule 62 (empty-or-literal -> .)
    C_GLOBAL        reduce using rule 62 (empty-or-literal -> .)
    D_IMPORT        reduce using rule 62 (empty-or-literal -> .)
    C_PRAGMA        reduce using rule 62 (empty-or-literal -> .)
    LBRACE          reduce using rule 62 (empty-or-literal -> .)
    S_IF            reduce using rule 62 (empty-or-literal -> .)
    S_SWITCH        reduce using rule 62 (empty-or-literal -> .)
    E_WAIT          reduce using rule 62 (empty-or-literal -> .)
    S_ITERATE       reduce using rule 62 (empty-or-literal -> .)
    ID              reduce using rule 62 (empty-or-literal -> .)
    AT              reduce using rule 62 (empty-or-literal -> .)
    LPAREN          reduce using rule 62 (empty-or-literal -> .)
    class_INT       reduce using rule 62 (empty-or-literal -> .)
    class_DOUBLE    reduce using rule 62 (empty-or-literal -> .)
    class_FLOAT     reduce using rule 62 (empty-or-literal -> .)
    class_VOID      reduce using rule 62 (empty-or-literal -> .)
    class_UINT      reduce using rule 62 (empty-or-literal -> .)
    class_BOOL      reduce using rule 62 (empty-or-literal -> .)
    class_CHARACTER reduce using rule 62 (empty-or-literal -> .)
    class_String    reduce using rule 62 (empty-or-literal -> .)
    collection_SET  reduce using rule 62 (empty-or-literal -> .)
    collection_ARRAY reduce using rule 62 (empty-or-literal -> .)
    collection_DICT reduce using rule 62 (empty-or-literal -> .)
    S_FOREACH       reduce using rule 62 (empty-or-literal -> .)
    S_FOR           reduce using rule 62 (empty-or-literal -> .)
    C_APP           reduce using rule 62 (empty-or-literal -> .)
    D_FUNCTION      reduce using rule 62 (empty-or-literal -> .)
    LESS            reduce using rule 62 (empty-or-literal -> .)
    $end            reduce using rule 62 (empty-or-literal -> .)
    RBRACE          reduce using rule 62 (empty-or-literal -> .)
    S_CASE          reduce using rule 62 (empty-or-literal -> .)
    S_DEFAULT       reduce using rule 62 (empty-or-literal -> .)
    STR_LITERAL     shift and go to state 266

    empty-or-literal               shift and go to state 267

state 217

    (49) app-func-defn -> annotation-star C_APP func-hdr LBRACE . app-body RBRACE
    (50) app-body -> . app-arg-expr app-arg-expr-star app-out-star empty-or-semicolon
    (232) app-arg-expr -> . opt-at var-name
    (233) app-arg-expr -> . literal
    (234) app-arg-expr -> . array-constructor
    (235) app-arg-expr -> . LPAREN expr RPAREN
    (236) opt-at -> .
    (237) opt-at -> . AT
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    LPAREN          shift and go to state 273
    ID              reduce using rule 236 (opt-at -> .)
    AT              shift and go to state 274
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139

    app-body                       shift and go to state 268
    app-arg-expr                   shift and go to state 269
    opt-at                         shift and go to state 270
    literal                        shift and go to state 271
    array-constructor              shift and go to state 272
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132

state 218

    (172) func-call -> annotation-star func-name LPAREN func-call-arg-list . RPAREN

    RPAREN          shift and go to state 275


state 219

    (173) func-call-arg-list -> expr-or-kw . func-call-arg-star
    (174) func-call-arg-star -> .
    (175) func-call-arg-star -> . COMMA expr-or-kw func-call-arg-star

    RPAREN          reduce using rule 174 (func-call-arg-star -> .)
    COMMA           shift and go to state 277

    func-call-arg-star             shift and go to state 276

state 220

    (176) expr-or-kw -> expr .

    COMMA           reduce using rule 176 (expr-or-kw -> expr .)
    RPAREN          reduce using rule 176 (expr-or-kw -> expr .)


state 221

    (177) expr-or-kw -> kw-expr .

    COMMA           reduce using rule 177 (expr-or-kw -> kw-expr .)
    RPAREN          reduce using rule 177 (expr-or-kw -> kw-expr .)


state 222

    (198) kw-expr -> ID . ASSIGN expr
    (223) var-name -> ID .

    ASSIGN          shift and go to state 163
    LBRACKET        reduce using rule 223 (var-name -> ID .)
    DOT             reduce using rule 223 (var-name -> ID .)
    MULT            reduce using rule 223 (var-name -> ID .)
    DIV             reduce using rule 223 (var-name -> ID .)
    MULTPER         reduce using rule 223 (var-name -> ID .)
    DOUBLEPER       reduce using rule 223 (var-name -> ID .)
    MOD             reduce using rule 223 (var-name -> ID .)
    PLUS            reduce using rule 223 (var-name -> ID .)
    MINUS           reduce using rule 223 (var-name -> ID .)
    LESS            reduce using rule 223 (var-name -> ID .)
    LESS_EQ         reduce using rule 223 (var-name -> ID .)
    EQUAL           reduce using rule 223 (var-name -> ID .)
    GREATER         reduce using rule 223 (var-name -> ID .)
    GREATER_EQ      reduce using rule 223 (var-name -> ID .)
    NOT_EQUAL       reduce using rule 223 (var-name -> ID .)
    LOG_AND         reduce using rule 223 (var-name -> ID .)
    LOG_OR          reduce using rule 223 (var-name -> ID .)
    COMMA           reduce using rule 223 (var-name -> ID .)
    RPAREN          reduce using rule 223 (var-name -> ID .)


state 223

    (28) func-hdr -> type-params formal-arg-list func-name . empty-or-arg-list
    (29) empty-or-arg-list -> .
    (30) empty-or-arg-list -> . formal-arg-list
    (35) formal-arg-list -> .
    (36) formal-arg-list -> . LPAREN opt-formal-args RPAREN

  ! reduce/reduce conflict for ARROW resolved using rule 29 (empty-or-arg-list -> .)
  ! reduce/reduce conflict for STR_LITERAL resolved using rule 29 (empty-or-arg-list -> .)
  ! reduce/reduce conflict for LBRACE resolved using rule 29 (empty-or-arg-list -> .)
    ARROW           reduce using rule 29 (empty-or-arg-list -> .)
    STR_LITERAL     reduce using rule 29 (empty-or-arg-list -> .)
    LBRACE          reduce using rule 29 (empty-or-arg-list -> .)
    LPAREN          shift and go to state 153

  ! ARROW           [ reduce using rule 35 (formal-arg-list -> .) ]
  ! STR_LITERAL     [ reduce using rule 35 (formal-arg-list -> .) ]
  ! LBRACE          [ reduce using rule 35 (formal-arg-list -> .) ]

    formal-arg-list                shift and go to state 278
    empty-or-arg-list              shift and go to state 279

state 224

    (36) formal-arg-list -> LPAREN opt-formal-args . RPAREN

    RPAREN          shift and go to state 280


state 225

    (38) opt-formal-args -> formal-arg . comma-args-star
    (39) comma-args-star -> .
    (40) comma-args-star -> . COMMA formal-arg comma-args-star

    RPAREN          reduce using rule 39 (comma-args-star -> .)
    COMMA           shift and go to state 282

    comma-args-star                shift and go to state 281

state 226

    (41) formal-arg -> type-prefix . empty-or-range var-name type-suffix empty-or-ass-expr
    (42) empty-or-range -> .
    (43) empty-or-range -> . RANGE

    ID              reduce using rule 42 (empty-or-range -> .)
    RANGE           shift and go to state 284

    empty-or-range                 shift and go to state 283

state 227

    (32) type-params -> LESS var-name comma-name-star . GREATER

    GREATER         shift and go to state 285


state 228

    (34) comma-name-star -> COMMA . var-name comma-name-star
    (223) var-name -> . ID

    ID              shift and go to state 66

    var-name                       shift and go to state 286

state 229

    (100) update-stmt -> var-name LESS ID GREATER . UPD expr SEMICOLON

    UPD             shift and go to state 287


state 230

    (164) array-subscript -> LBRACKET expr RBRACKET .

    LBRACKET        reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    DOT             reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    ASSIGN          reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    PLUS_AS         reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    MULT            reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    DIV             reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    MULTPER         reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    DOUBLEPER       reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    MOD             reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    LESS            reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    LESS_EQ         reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    EQUAL           reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    GREATER         reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    GREATER_EQ      reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    NOT_EQUAL       reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    LOG_AND         reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    LOG_OR          reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    SEMICOLON       reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    ARROW           reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    COLON           reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    AT              reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    S_FOREACH       reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    S_FOR           reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    C_APP           reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    D_FUNCTION      reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    LPAREN          reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    RBRACE          reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    LBRACE          reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    E_STDIN         reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    E_STDOUT        reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)
    E_STDERR        reduce using rule 164 (array-subscript -> LBRACKET expr RBRACKET .)


state 231

    (128) iterate-loop -> S_ITERATE var-name block S_UNTIL . LPAREN expr RPAREN

    LPAREN          shift and go to state 288


state 232

    (198) kw-expr -> ID ASSIGN expr .

    AT              reduce using rule 198 (kw-expr -> ID ASSIGN expr .)
    S_FOREACH       reduce using rule 198 (kw-expr -> ID ASSIGN expr .)
    S_FOR           reduce using rule 198 (kw-expr -> ID ASSIGN expr .)
    C_APP           reduce using rule 198 (kw-expr -> ID ASSIGN expr .)
    D_FUNCTION      reduce using rule 198 (kw-expr -> ID ASSIGN expr .)
    LESS            reduce using rule 198 (kw-expr -> ID ASSIGN expr .)
    LPAREN          reduce using rule 198 (kw-expr -> ID ASSIGN expr .)
    COMMA           reduce using rule 198 (kw-expr -> ID ASSIGN expr .)
    RPAREN          reduce using rule 198 (kw-expr -> ID ASSIGN expr .)


state 233

    (71) var-decl-rest -> var-name type-suffix empty-or-var-mappign . empty-or-assign-expr
    (74) empty-or-assign-expr -> .
    (75) empty-or-assign-expr -> . ASSIGN expr

    SEMICOLON       reduce using rule 74 (empty-or-assign-expr -> .)
    ARROW           reduce using rule 74 (empty-or-assign-expr -> .)
    ASSIGN          shift and go to state 290

    empty-or-assign-expr           shift and go to state 289

state 234

    (73) empty-or-var-mappign -> var-mapping .

    ASSIGN          reduce using rule 73 (empty-or-var-mappign -> var-mapping .)
    SEMICOLON       reduce using rule 73 (empty-or-var-mappign -> var-mapping .)
    ARROW           reduce using rule 73 (empty-or-var-mappign -> var-mapping .)


state 235

    (84) var-mapping -> LESS . expr GREATER
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 291
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 236

    (80) type-suffix -> LBRACKET empty-or-standalone-type . RBRACKET type-suffix

    RBRACKET        shift and go to state 292


state 237

    (82) empty-or-standalone-type -> standalone-type .

    RBRACKET        reduce using rule 82 (empty-or-standalone-type -> standalone-type .)


state 238

    (78) param-type -> type-name LESS standalone-type GREATER .

    ID              reduce using rule 78 (param-type -> type-name LESS standalone-type GREATER .)
    LBRACKET        reduce using rule 78 (param-type -> type-name LESS standalone-type GREATER .)
    GREATER         reduce using rule 78 (param-type -> type-name LESS standalone-type GREATER .)
    RANGE           reduce using rule 78 (param-type -> type-name LESS standalone-type GREATER .)
    RBRACKET        reduce using rule 78 (param-type -> type-name LESS standalone-type GREATER .)


state 239

    (83) standalone-type -> type-prefix type-suffix .

    GREATER         reduce using rule 83 (standalone-type -> type-prefix type-suffix .)
    RBRACKET        reduce using rule 83 (standalone-type -> type-prefix type-suffix .)


state 240

    (227) lval-expr-star -> COMMA lval-expr lval-expr-star .

    ASSIGN          reduce using rule 227 (lval-expr-star -> COMMA lval-expr lval-expr-star .)
    PLUS_AS         reduce using rule 227 (lval-expr-star -> COMMA lval-expr lval-expr-star .)
    RPAREN          reduce using rule 227 (lval-expr-star -> COMMA lval-expr lval-expr-star .)


state 241

    (23) path-star -> DOT ID path-star .

    SEMICOLON       reduce using rule 23 (path-star -> DOT ID path-star .)


state 242

    (131) or-expr -> or-expr LOG_OR and-expr .
    (133) and-expr -> and-expr . LOG_AND eq-expr

    LOG_OR          reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    SEMICOLON       reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    RPAREN          reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    RBRACKET        reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    ARROW           reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    COMMA           reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    COLON           reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    AT              reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    S_FOREACH       reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    S_FOR           reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    C_APP           reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    D_FUNCTION      reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    LESS            reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    LPAREN          reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    GREATER         reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    RBRACE          reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    LBRACE          reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    E_STDIN         reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    E_STDOUT        reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    E_STDERR        reduce using rule 131 (or-expr -> or-expr LOG_OR and-expr .)
    LOG_AND         shift and go to state 175


state 243

    (133) and-expr -> and-expr LOG_AND eq-expr .
    (135) eq-expr -> eq-expr . eq-or-not-eq eq-expr
    (136) eq-or-not-eq -> . EQUAL
    (137) eq-or-not-eq -> . NOT_EQUAL

    LOG_AND         reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    LOG_OR          reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    SEMICOLON       reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    RPAREN          reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    RBRACKET        reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    ARROW           reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    COMMA           reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    COLON           reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    AT              reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    S_FOREACH       reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    S_FOR           reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    C_APP           reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    D_FUNCTION      reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    LESS            reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    LPAREN          reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    GREATER         reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    RBRACE          reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    LBRACE          reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    E_STDIN         reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    E_STDOUT        reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    E_STDERR        reduce using rule 133 (and-expr -> and-expr LOG_AND eq-expr .)
    EQUAL           shift and go to state 177
    NOT_EQUAL       shift and go to state 178

    eq-or-not-eq                   shift and go to state 176

state 244

    (135) eq-expr -> eq-expr eq-or-not-eq eq-expr .
    (135) eq-expr -> eq-expr . eq-or-not-eq eq-expr
    (136) eq-or-not-eq -> . EQUAL
    (137) eq-or-not-eq -> . NOT_EQUAL

  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
    LOG_AND         reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    LOG_OR          reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    SEMICOLON       reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    RPAREN          reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    RBRACKET        reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    ARROW           reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    COMMA           reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    COLON           reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    AT              reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    S_FOREACH       reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    S_FOR           reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    C_APP           reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    D_FUNCTION      reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    LESS            reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    LPAREN          reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    GREATER         reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    RBRACE          reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    LBRACE          reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    E_STDIN         reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    E_STDOUT        reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    E_STDERR        reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .)
    EQUAL           shift and go to state 177
    NOT_EQUAL       shift and go to state 178

  ! EQUAL           [ reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .) ]
  ! NOT_EQUAL       [ reduce using rule 135 (eq-expr -> eq-expr eq-or-not-eq eq-expr .) ]

    eq-or-not-eq                   shift and go to state 176

state 245

    (139) cmp-expr -> cmp-expr cmp-sign add-expr .
    (146) add-expr -> add-expr . add-sign mult-expr
    (147) add-sign -> . PLUS
    (148) add-sign -> . MINUS

    LESS            reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    LESS_EQ         reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    EQUAL           reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    GREATER         reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    GREATER_EQ      reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    NOT_EQUAL       reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    LOG_AND         reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    LOG_OR          reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    SEMICOLON       reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    RPAREN          reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    RBRACKET        reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    ARROW           reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    COMMA           reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    COLON           reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    AT              reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    S_FOREACH       reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    S_FOR           reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    C_APP           reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    D_FUNCTION      reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    LPAREN          reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    RBRACE          reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    LBRACE          reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    E_STDIN         reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    E_STDOUT        reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    E_STDERR        reduce using rule 139 (cmp-expr -> cmp-expr cmp-sign add-expr .)
    PLUS            shift and go to state 186
    MINUS           shift and go to state 187

    add-sign                       shift and go to state 185

state 246

    (146) add-expr -> add-expr add-sign mult-expr .
    (150) mult-expr -> mult-expr . mult-sign unary-expr
    (151) mult-sign -> . MULT
    (152) mult-sign -> . DIV
    (153) mult-sign -> . MULTPER
    (154) mult-sign -> . DOUBLEPER
    (155) mult-sign -> . MOD

    PLUS            reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    MINUS           reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    LESS            reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    LESS_EQ         reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    EQUAL           reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    GREATER         reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    GREATER_EQ      reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    NOT_EQUAL       reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    LOG_AND         reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    LOG_OR          reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    SEMICOLON       reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    RPAREN          reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    RBRACKET        reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    ARROW           reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    COMMA           reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    COLON           reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    AT              reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    S_FOREACH       reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    S_FOR           reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    C_APP           reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    D_FUNCTION      reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    LPAREN          reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    RBRACE          reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    LBRACE          reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    E_STDIN         reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    E_STDOUT        reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    E_STDERR        reduce using rule 146 (add-expr -> add-expr add-sign mult-expr .)
    MULT            shift and go to state 189
    DIV             shift and go to state 190
    MULTPER         shift and go to state 191
    DOUBLEPER       shift and go to state 192
    MOD             shift and go to state 193

    mult-sign                      shift and go to state 188

state 247

    (150) mult-expr -> mult-expr mult-sign unary-expr .

    MULT            reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    DIV             reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    MULTPER         reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    DOUBLEPER       reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    MOD             reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    PLUS            reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    MINUS           reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    LESS            reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    LESS_EQ         reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    EQUAL           reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    GREATER         reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    GREATER_EQ      reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    NOT_EQUAL       reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    LOG_AND         reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    LOG_OR          reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    SEMICOLON       reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    RPAREN          reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    RBRACKET        reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    ARROW           reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    COMMA           reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    COLON           reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    AT              reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    S_FOREACH       reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    S_FOR           reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    C_APP           reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    D_FUNCTION      reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    LPAREN          reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    RBRACE          reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    LBRACE          reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    E_STDIN         reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    E_STDOUT        reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)
    E_STDERR        reduce using rule 150 (mult-expr -> mult-expr mult-sign unary-expr .)


state 248

    (169) base-expr -> LPAREN expr RPAREN .

    LBRACKET        reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    DOT             reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    MULT            reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    DIV             reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    MULTPER         reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    DOUBLEPER       reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    MOD             reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    LESS            reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    LESS_EQ         reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    EQUAL           reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    GREATER         reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    NOT_EQUAL       reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    LOG_AND         reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    LOG_OR          reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    ARROW           reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    COLON           reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    AT              reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    S_FOREACH       reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    S_FOR           reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    C_APP           reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    D_FUNCTION      reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    LPAREN          reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    RBRACE          reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    LBRACE          reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    E_STDIN         reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    E_STDOUT        reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)
    E_STDERR        reduce using rule 169 (base-expr -> LPAREN expr RPAREN .)


state 249

    (178) tuple-constructor -> LPAREN expr COMMA . expr comma-expr-star RPAREN
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 293
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 250

    (184) array-list-constructor -> LBRACKET opt-expr-list RBRACKET .

    LBRACKET        reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    DOT             reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    MULT            reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    DIV             reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    MULTPER         reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    DOUBLEPER       reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    MOD             reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    PLUS            reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    MINUS           reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    LESS            reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    LESS_EQ         reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    EQUAL           reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    GREATER         reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    GREATER_EQ      reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    NOT_EQUAL       reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    LOG_AND         reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    LOG_OR          reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    SEMICOLON       reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    RPAREN          reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    RBRACKET        reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    ARROW           reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    COMMA           reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    COLON           reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    AT              reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    S_FOREACH       reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    S_FOR           reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    C_APP           reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    D_FUNCTION      reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    LPAREN          reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    RBRACE          reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    LBRACE          reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    E_STDIN         reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    E_STDOUT        reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    E_STDERR        reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    STR_LITERAL     reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    MUL_STR_LITERAL reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    INT             reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    DOUBLE          reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    INF             reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    NAN             reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    E_TRUE          reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    E_FALSE         reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)
    ID              reduce using rule 184 (array-list-constructor -> LBRACKET opt-expr-list RBRACKET .)


state 251

    (187) array-range-constructor -> LBRACKET expr COLON . expr opt-coloned-expr RBRACKET
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 294
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 252

    (190) array-kv-constructor -> LBRACE opt-array-constructor RBRACE .

    LBRACKET        reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    DOT             reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    MULT            reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    DIV             reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    MULTPER         reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    DOUBLEPER       reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    MOD             reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    PLUS            reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    MINUS           reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    LESS            reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    LESS_EQ         reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    EQUAL           reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    GREATER         reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    GREATER_EQ      reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    NOT_EQUAL       reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    LOG_AND         reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    LOG_OR          reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    SEMICOLON       reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    RPAREN          reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    RBRACKET        reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    ARROW           reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    COMMA           reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    COLON           reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    AT              reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    S_FOREACH       reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    S_FOR           reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    C_APP           reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    D_FUNCTION      reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    LPAREN          reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    RBRACE          reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    LBRACE          reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    E_STDIN         reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    E_STDOUT        reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    E_STDERR        reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    STR_LITERAL     reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    MUL_STR_LITERAL reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    INT             reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    DOUBLE          reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    INF             reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    NAN             reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    E_TRUE          reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    E_FALSE         reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)
    ID              reduce using rule 190 (array-kv-constructor -> LBRACE opt-array-constructor RBRACE .)


state 253

    (192) opt-array-constructor -> array-kv-elem comma-array-kv-elem-star .

    RBRACE          reduce using rule 192 (opt-array-constructor -> array-kv-elem comma-array-kv-elem-star .)


state 254

    (194) comma-array-kv-elem-star -> COMMA . array-kv-elem comma-array-kv-elem-star
    (195) array-kv-elem -> . expr COLON expr
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    array-kv-elem                  shift and go to state 295
    expr                           shift and go to state 204
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 255

    (195) array-kv-elem -> expr COLON . expr
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 296
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 256

    (101) if-stmt -> S_IF LPAREN expr RPAREN block . opt-else-block
    (102) opt-else-block -> .
    (103) opt-else-block -> . S_ELSE block

    SEMICOLON       reduce using rule 102 (opt-else-block -> .)
    C_GLOBAL        reduce using rule 102 (opt-else-block -> .)
    D_IMPORT        reduce using rule 102 (opt-else-block -> .)
    C_PRAGMA        reduce using rule 102 (opt-else-block -> .)
    LBRACE          reduce using rule 102 (opt-else-block -> .)
    S_IF            reduce using rule 102 (opt-else-block -> .)
    S_SWITCH        reduce using rule 102 (opt-else-block -> .)
    E_WAIT          reduce using rule 102 (opt-else-block -> .)
    S_ITERATE       reduce using rule 102 (opt-else-block -> .)
    ID              reduce using rule 102 (opt-else-block -> .)
    AT              reduce using rule 102 (opt-else-block -> .)
    LPAREN          reduce using rule 102 (opt-else-block -> .)
    class_INT       reduce using rule 102 (opt-else-block -> .)
    class_DOUBLE    reduce using rule 102 (opt-else-block -> .)
    class_FLOAT     reduce using rule 102 (opt-else-block -> .)
    class_VOID      reduce using rule 102 (opt-else-block -> .)
    class_UINT      reduce using rule 102 (opt-else-block -> .)
    class_BOOL      reduce using rule 102 (opt-else-block -> .)
    class_CHARACTER reduce using rule 102 (opt-else-block -> .)
    class_String    reduce using rule 102 (opt-else-block -> .)
    collection_SET  reduce using rule 102 (opt-else-block -> .)
    collection_ARRAY reduce using rule 102 (opt-else-block -> .)
    collection_DICT reduce using rule 102 (opt-else-block -> .)
    S_FOREACH       reduce using rule 102 (opt-else-block -> .)
    S_FOR           reduce using rule 102 (opt-else-block -> .)
    C_APP           reduce using rule 102 (opt-else-block -> .)
    D_FUNCTION      reduce using rule 102 (opt-else-block -> .)
    LESS            reduce using rule 102 (opt-else-block -> .)
    $end            reduce using rule 102 (opt-else-block -> .)
    RBRACE          reduce using rule 102 (opt-else-block -> .)
    S_CASE          reduce using rule 102 (opt-else-block -> .)
    S_DEFAULT       reduce using rule 102 (opt-else-block -> .)
    S_ELSE          shift and go to state 298

    opt-else-block                 shift and go to state 297

state 257

    (104) switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE . case-star opt-default RBRACE
    (107) case-star -> .
    (108) case-star -> . case case-star
    (109) case -> . S_CASE INT COLON translation-unit

    S_DEFAULT       reduce using rule 107 (case-star -> .)
    RBRACE          reduce using rule 107 (case-star -> .)
    S_CASE          shift and go to state 301

    case-star                      shift and go to state 299
    case                           shift and go to state 300

state 258

    (111) wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN . block
    (85) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 26

    block                          shift and go to state 302

state 259

    (114) foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN . expr block
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    annotation-star                shift and go to state 129
    var-name                       shift and go to state 120
    expr                           shift and go to state 303
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 260

    (116) opt-comma-var-name -> COMMA var-name .

    S_IN            reduce using rule 116 (opt-comma-var-name -> COMMA var-name .)


state 261

    (117) for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON . expr SEMICOLON for-update-list RPAREN block
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    annotation-star                shift and go to state 129
    expr                           shift and go to state 304
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 262

    (119) for-init-list -> for-init for-init-star .

    SEMICOLON       reduce using rule 119 (for-init-list -> for-init for-init-star .)


state 263

    (121) for-init-star -> COMMA . for-init for-init-star
    (122) for-init -> . for-assignment
    (123) for-init -> . type-prefix var-name type-suffix ASSIGN expr
    (127) for-assignment -> . var-name ASSIGN expr
    (76) type-prefix -> . type-name
    (77) type-prefix -> . param-type
    (223) var-name -> . ID
    (210) type-name -> . class_INT
    (211) type-name -> . class_DOUBLE
    (212) type-name -> . class_FLOAT
    (213) type-name -> . class_VOID
    (214) type-name -> . class_UINT
    (215) type-name -> . class_BOOL
    (216) type-name -> . class_CHARACTER
    (217) type-name -> . class_String
    (218) type-name -> . collection_SET
    (219) type-name -> . collection_ARRAY
    (220) type-name -> . collection_DICT
    (221) type-name -> . ID
    (78) param-type -> . type-name LESS standalone-type GREATER

    ID              shift and go to state 22
    class_INT       shift and go to state 44
    class_DOUBLE    shift and go to state 45
    class_FLOAT     shift and go to state 46
    class_VOID      shift and go to state 47
    class_UINT      shift and go to state 48
    class_BOOL      shift and go to state 49
    class_CHARACTER shift and go to state 50
    class_String    shift and go to state 51
    collection_SET  shift and go to state 52
    collection_ARRAY shift and go to state 53
    collection_DICT shift and go to state 54

    for-init                       shift and go to state 305
    for-assignment                 shift and go to state 212
    type-prefix                    shift and go to state 213
    var-name                       shift and go to state 214
    type-name                      shift and go to state 41
    param-type                     shift and go to state 42

state 264

    (123) for-init -> type-prefix var-name . type-suffix ASSIGN expr
    (79) type-suffix -> .
    (80) type-suffix -> . LBRACKET empty-or-standalone-type RBRACKET type-suffix

    ASSIGN          reduce using rule 79 (type-suffix -> .)
    LBRACKET        shift and go to state 165

    type-suffix                    shift and go to state 306

state 265

    (127) for-assignment -> var-name ASSIGN . expr
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    var-name                       shift and go to state 120
    expr                           shift and go to state 307
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 266

    (63) empty-or-literal -> STR_LITERAL .

    LBRACKET        reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    SEMICOLON       reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    C_GLOBAL        reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    D_IMPORT        reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    C_PRAGMA        reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    LBRACE          reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    S_IF            reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    S_SWITCH        reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    E_WAIT          reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    S_ITERATE       reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    ID              reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    AT              reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    LPAREN          reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    class_INT       reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    class_DOUBLE    reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    class_FLOAT     reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    class_VOID      reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    class_UINT      reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    class_BOOL      reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    class_CHARACTER reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    class_String    reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    collection_SET  reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    collection_ARRAY reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    collection_DICT reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    S_FOREACH       reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    S_FOR           reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    C_APP           reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    D_FUNCTION      reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    LESS            reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    $end            reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    RBRACE          reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    S_CASE          reduce using rule 63 (empty-or-literal -> STR_LITERAL .)
    S_DEFAULT       reduce using rule 63 (empty-or-literal -> STR_LITERAL .)


state 267

    (61) foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal . empty-or-more-literals
    (64) empty-or-more-literals -> .
    (65) empty-or-more-literals -> . LBRACKET single-or-multiple-literal RBRACKET

    SEMICOLON       reduce using rule 64 (empty-or-more-literals -> .)
    C_GLOBAL        reduce using rule 64 (empty-or-more-literals -> .)
    D_IMPORT        reduce using rule 64 (empty-or-more-literals -> .)
    C_PRAGMA        reduce using rule 64 (empty-or-more-literals -> .)
    LBRACE          reduce using rule 64 (empty-or-more-literals -> .)
    S_IF            reduce using rule 64 (empty-or-more-literals -> .)
    S_SWITCH        reduce using rule 64 (empty-or-more-literals -> .)
    E_WAIT          reduce using rule 64 (empty-or-more-literals -> .)
    S_ITERATE       reduce using rule 64 (empty-or-more-literals -> .)
    ID              reduce using rule 64 (empty-or-more-literals -> .)
    AT              reduce using rule 64 (empty-or-more-literals -> .)
    LPAREN          reduce using rule 64 (empty-or-more-literals -> .)
    class_INT       reduce using rule 64 (empty-or-more-literals -> .)
    class_DOUBLE    reduce using rule 64 (empty-or-more-literals -> .)
    class_FLOAT     reduce using rule 64 (empty-or-more-literals -> .)
    class_VOID      reduce using rule 64 (empty-or-more-literals -> .)
    class_UINT      reduce using rule 64 (empty-or-more-literals -> .)
    class_BOOL      reduce using rule 64 (empty-or-more-literals -> .)
    class_CHARACTER reduce using rule 64 (empty-or-more-literals -> .)
    class_String    reduce using rule 64 (empty-or-more-literals -> .)
    collection_SET  reduce using rule 64 (empty-or-more-literals -> .)
    collection_ARRAY reduce using rule 64 (empty-or-more-literals -> .)
    collection_DICT reduce using rule 64 (empty-or-more-literals -> .)
    S_FOREACH       reduce using rule 64 (empty-or-more-literals -> .)
    S_FOR           reduce using rule 64 (empty-or-more-literals -> .)
    C_APP           reduce using rule 64 (empty-or-more-literals -> .)
    D_FUNCTION      reduce using rule 64 (empty-or-more-literals -> .)
    LESS            reduce using rule 64 (empty-or-more-literals -> .)
    $end            reduce using rule 64 (empty-or-more-literals -> .)
    RBRACE          reduce using rule 64 (empty-or-more-literals -> .)
    S_CASE          reduce using rule 64 (empty-or-more-literals -> .)
    S_DEFAULT       reduce using rule 64 (empty-or-more-literals -> .)
    LBRACKET        shift and go to state 309

    empty-or-more-literals         shift and go to state 308

state 268

    (49) app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body . RBRACE

    RBRACE          shift and go to state 310


state 269

    (50) app-body -> app-arg-expr . app-arg-expr-star app-out-star empty-or-semicolon
    (58) app-arg-expr-star -> .
    (59) app-arg-expr-star -> . app-arg-expr app-arg-expr-star
    (232) app-arg-expr -> . opt-at var-name
    (233) app-arg-expr -> . literal
    (234) app-arg-expr -> . array-constructor
    (235) app-arg-expr -> . LPAREN expr RPAREN
    (236) opt-at -> .
    (237) opt-at -> . AT
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    E_STDIN         reduce using rule 58 (app-arg-expr-star -> .)
    E_STDOUT        reduce using rule 58 (app-arg-expr-star -> .)
    E_STDERR        reduce using rule 58 (app-arg-expr-star -> .)
    SEMICOLON       reduce using rule 58 (app-arg-expr-star -> .)
    RBRACE          reduce using rule 58 (app-arg-expr-star -> .)
    LPAREN          shift and go to state 273
    ID              reduce using rule 236 (opt-at -> .)
    AT              shift and go to state 274
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139

    app-arg-expr                   shift and go to state 311
    app-arg-expr-star              shift and go to state 312
    opt-at                         shift and go to state 270
    literal                        shift and go to state 271
    array-constructor              shift and go to state 272
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132

state 270

    (232) app-arg-expr -> opt-at . var-name
    (223) var-name -> . ID

    ID              shift and go to state 66

    var-name                       shift and go to state 313

state 271

    (233) app-arg-expr -> literal .

    LPAREN          reduce using rule 233 (app-arg-expr -> literal .)
    AT              reduce using rule 233 (app-arg-expr -> literal .)
    STR_LITERAL     reduce using rule 233 (app-arg-expr -> literal .)
    MUL_STR_LITERAL reduce using rule 233 (app-arg-expr -> literal .)
    INT             reduce using rule 233 (app-arg-expr -> literal .)
    DOUBLE          reduce using rule 233 (app-arg-expr -> literal .)
    INF             reduce using rule 233 (app-arg-expr -> literal .)
    NAN             reduce using rule 233 (app-arg-expr -> literal .)
    E_TRUE          reduce using rule 233 (app-arg-expr -> literal .)
    E_FALSE         reduce using rule 233 (app-arg-expr -> literal .)
    LBRACKET        reduce using rule 233 (app-arg-expr -> literal .)
    LBRACE          reduce using rule 233 (app-arg-expr -> literal .)
    E_STDIN         reduce using rule 233 (app-arg-expr -> literal .)
    E_STDOUT        reduce using rule 233 (app-arg-expr -> literal .)
    E_STDERR        reduce using rule 233 (app-arg-expr -> literal .)
    SEMICOLON       reduce using rule 233 (app-arg-expr -> literal .)
    ID              reduce using rule 233 (app-arg-expr -> literal .)
    RBRACE          reduce using rule 233 (app-arg-expr -> literal .)


state 272

    (234) app-arg-expr -> array-constructor .

    LPAREN          reduce using rule 234 (app-arg-expr -> array-constructor .)
    AT              reduce using rule 234 (app-arg-expr -> array-constructor .)
    STR_LITERAL     reduce using rule 234 (app-arg-expr -> array-constructor .)
    MUL_STR_LITERAL reduce using rule 234 (app-arg-expr -> array-constructor .)
    INT             reduce using rule 234 (app-arg-expr -> array-constructor .)
    DOUBLE          reduce using rule 234 (app-arg-expr -> array-constructor .)
    INF             reduce using rule 234 (app-arg-expr -> array-constructor .)
    NAN             reduce using rule 234 (app-arg-expr -> array-constructor .)
    E_TRUE          reduce using rule 234 (app-arg-expr -> array-constructor .)
    E_FALSE         reduce using rule 234 (app-arg-expr -> array-constructor .)
    LBRACKET        reduce using rule 234 (app-arg-expr -> array-constructor .)
    LBRACE          reduce using rule 234 (app-arg-expr -> array-constructor .)
    E_STDIN         reduce using rule 234 (app-arg-expr -> array-constructor .)
    E_STDOUT        reduce using rule 234 (app-arg-expr -> array-constructor .)
    E_STDERR        reduce using rule 234 (app-arg-expr -> array-constructor .)
    SEMICOLON       reduce using rule 234 (app-arg-expr -> array-constructor .)
    ID              reduce using rule 234 (app-arg-expr -> array-constructor .)
    RBRACE          reduce using rule 234 (app-arg-expr -> array-constructor .)


state 273

    (235) app-arg-expr -> LPAREN . expr RPAREN
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 314
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 274

    (237) opt-at -> AT .

    ID              reduce using rule 237 (opt-at -> AT .)


state 275

    (172) func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .

    SEMICOLON       reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    ARROW           reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    LBRACKET        reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    DOT             reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    MULT            reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    DIV             reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    MULTPER         reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    DOUBLEPER       reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    MOD             reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    PLUS            reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    MINUS           reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    LESS            reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    LESS_EQ         reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    EQUAL           reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    GREATER         reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    GREATER_EQ      reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    NOT_EQUAL       reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    LOG_AND         reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    LOG_OR          reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    RPAREN          reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    RBRACKET        reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    COMMA           reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    COLON           reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    AT              reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    S_FOREACH       reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    S_FOR           reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    C_APP           reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    D_FUNCTION      reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    LPAREN          reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    RBRACE          reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    LBRACE          reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    E_STDIN         reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    E_STDOUT        reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)
    E_STDERR        reduce using rule 172 (func-call -> annotation-star func-name LPAREN func-call-arg-list RPAREN .)


state 276

    (173) func-call-arg-list -> expr-or-kw func-call-arg-star .

    RPAREN          reduce using rule 173 (func-call-arg-list -> expr-or-kw func-call-arg-star .)


state 277

    (175) func-call-arg-star -> COMMA . expr-or-kw func-call-arg-star
    (176) expr-or-kw -> . expr
    (177) expr-or-kw -> . kw-expr
    (129) expr -> . or-expr
    (198) kw-expr -> . ID ASSIGN expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    ID              shift and go to state 222
    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr-or-kw                     shift and go to state 315
    expr                           shift and go to state 220
    kw-expr                        shift and go to state 221
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 278

    (30) empty-or-arg-list -> formal-arg-list .

    ARROW           reduce using rule 30 (empty-or-arg-list -> formal-arg-list .)
    STR_LITERAL     reduce using rule 30 (empty-or-arg-list -> formal-arg-list .)
    LBRACE          reduce using rule 30 (empty-or-arg-list -> formal-arg-list .)


state 279

    (28) func-hdr -> type-params formal-arg-list func-name empty-or-arg-list .

    ARROW           reduce using rule 28 (func-hdr -> type-params formal-arg-list func-name empty-or-arg-list .)
    STR_LITERAL     reduce using rule 28 (func-hdr -> type-params formal-arg-list func-name empty-or-arg-list .)
    LBRACE          reduce using rule 28 (func-hdr -> type-params formal-arg-list func-name empty-or-arg-list .)


state 280

    (36) formal-arg-list -> LPAREN opt-formal-args RPAREN .

    D_FUNCTION      reduce using rule 36 (formal-arg-list -> LPAREN opt-formal-args RPAREN .)
    ARROW           reduce using rule 36 (formal-arg-list -> LPAREN opt-formal-args RPAREN .)
    STR_LITERAL     reduce using rule 36 (formal-arg-list -> LPAREN opt-formal-args RPAREN .)
    LBRACE          reduce using rule 36 (formal-arg-list -> LPAREN opt-formal-args RPAREN .)
    ASSIGN          reduce using rule 36 (formal-arg-list -> LPAREN opt-formal-args RPAREN .)


state 281

    (38) opt-formal-args -> formal-arg comma-args-star .

    RPAREN          reduce using rule 38 (opt-formal-args -> formal-arg comma-args-star .)


state 282

    (40) comma-args-star -> COMMA . formal-arg comma-args-star
    (41) formal-arg -> . type-prefix empty-or-range var-name type-suffix empty-or-ass-expr
    (76) type-prefix -> . type-name
    (77) type-prefix -> . param-type
    (210) type-name -> . class_INT
    (211) type-name -> . class_DOUBLE
    (212) type-name -> . class_FLOAT
    (213) type-name -> . class_VOID
    (214) type-name -> . class_UINT
    (215) type-name -> . class_BOOL
    (216) type-name -> . class_CHARACTER
    (217) type-name -> . class_String
    (218) type-name -> . collection_SET
    (219) type-name -> . collection_ARRAY
    (220) type-name -> . collection_DICT
    (221) type-name -> . ID
    (78) param-type -> . type-name LESS standalone-type GREATER

    class_INT       shift and go to state 44
    class_DOUBLE    shift and go to state 45
    class_FLOAT     shift and go to state 46
    class_VOID      shift and go to state 47
    class_UINT      shift and go to state 48
    class_BOOL      shift and go to state 49
    class_CHARACTER shift and go to state 50
    class_String    shift and go to state 51
    collection_SET  shift and go to state 52
    collection_ARRAY shift and go to state 53
    collection_DICT shift and go to state 54
    ID              shift and go to state 100

    formal-arg                     shift and go to state 316
    type-prefix                    shift and go to state 226
    type-name                      shift and go to state 41
    param-type                     shift and go to state 42

state 283

    (41) formal-arg -> type-prefix empty-or-range . var-name type-suffix empty-or-ass-expr
    (223) var-name -> . ID

    ID              shift and go to state 66

    var-name                       shift and go to state 317

state 284

    (43) empty-or-range -> RANGE .

    ID              reduce using rule 43 (empty-or-range -> RANGE .)


state 285

    (32) type-params -> LESS var-name comma-name-star GREATER .

    LPAREN          reduce using rule 32 (type-params -> LESS var-name comma-name-star GREATER .)
    D_FUNCTION      reduce using rule 32 (type-params -> LESS var-name comma-name-star GREATER .)


state 286

    (34) comma-name-star -> COMMA var-name . comma-name-star
    (33) comma-name-star -> .
    (34) comma-name-star -> . COMMA var-name comma-name-star

    GREATER         reduce using rule 33 (comma-name-star -> .)
    COMMA           shift and go to state 228

    comma-name-star                shift and go to state 318

state 287

    (100) update-stmt -> var-name LESS ID GREATER UPD . expr SEMICOLON
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    var-name                       shift and go to state 120
    expr                           shift and go to state 319
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 288

    (128) iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN . expr RPAREN
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    var-name                       shift and go to state 120
    expr                           shift and go to state 320
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 289

    (71) var-decl-rest -> var-name type-suffix empty-or-var-mappign empty-or-assign-expr .

    SEMICOLON       reduce using rule 71 (var-decl-rest -> var-name type-suffix empty-or-var-mappign empty-or-assign-expr .)
    ARROW           reduce using rule 71 (var-decl-rest -> var-name type-suffix empty-or-var-mappign empty-or-assign-expr .)


state 290

    (75) empty-or-assign-expr -> ASSIGN . expr
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 321
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 291

    (84) var-mapping -> LESS expr . GREATER

    GREATER         shift and go to state 322


state 292

    (80) type-suffix -> LBRACKET empty-or-standalone-type RBRACKET . type-suffix
    (79) type-suffix -> .
    (80) type-suffix -> . LBRACKET empty-or-standalone-type RBRACKET type-suffix

    LESS            reduce using rule 79 (type-suffix -> .)
    ASSIGN          reduce using rule 79 (type-suffix -> .)
    SEMICOLON       reduce using rule 79 (type-suffix -> .)
    ARROW           reduce using rule 79 (type-suffix -> .)
    GREATER         reduce using rule 79 (type-suffix -> .)
    RBRACKET        reduce using rule 79 (type-suffix -> .)
    LPAREN          reduce using rule 79 (type-suffix -> .)
    COMMA           reduce using rule 79 (type-suffix -> .)
    RPAREN          reduce using rule 79 (type-suffix -> .)
    LBRACKET        shift and go to state 165

    type-suffix                    shift and go to state 323

state 293

    (178) tuple-constructor -> LPAREN expr COMMA expr . comma-expr-star RPAREN
    (179) comma-expr-star -> .
    (180) comma-expr-star -> . COMMA expr comma-expr-star

    RPAREN          reduce using rule 179 (comma-expr-star -> .)
    COMMA           shift and go to state 324

    comma-expr-star                shift and go to state 325

state 294

    (187) array-range-constructor -> LBRACKET expr COLON expr . opt-coloned-expr RBRACKET
    (188) opt-coloned-expr -> .
    (189) opt-coloned-expr -> . COLON expr

    RBRACKET        reduce using rule 188 (opt-coloned-expr -> .)
    COLON           shift and go to state 326

    opt-coloned-expr               shift and go to state 327

state 295

    (194) comma-array-kv-elem-star -> COMMA array-kv-elem . comma-array-kv-elem-star
    (193) comma-array-kv-elem-star -> .
    (194) comma-array-kv-elem-star -> . COMMA array-kv-elem comma-array-kv-elem-star

    RBRACE          reduce using rule 193 (comma-array-kv-elem-star -> .)
    COMMA           shift and go to state 254

    comma-array-kv-elem-star       shift and go to state 328

state 296

    (195) array-kv-elem -> expr COLON expr .

    COMMA           reduce using rule 195 (array-kv-elem -> expr COLON expr .)
    RBRACE          reduce using rule 195 (array-kv-elem -> expr COLON expr .)


state 297

    (101) if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .

    SEMICOLON       reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    C_GLOBAL        reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    D_IMPORT        reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    C_PRAGMA        reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    LBRACE          reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_IF            reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_SWITCH        reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    E_WAIT          reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_ITERATE       reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    ID              reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    AT              reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    LPAREN          reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_INT       reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_DOUBLE    reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_FLOAT     reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_VOID      reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_UINT      reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_BOOL      reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_CHARACTER reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    class_String    reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    collection_SET  reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    collection_ARRAY reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    collection_DICT reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_FOREACH       reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_FOR           reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    C_APP           reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    D_FUNCTION      reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    LESS            reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    $end            reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    RBRACE          reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_CASE          reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)
    S_DEFAULT       reduce using rule 101 (if-stmt -> S_IF LPAREN expr RPAREN block opt-else-block .)


state 298

    (103) opt-else-block -> S_ELSE . block
    (85) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 26

    block                          shift and go to state 329

state 299

    (104) switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star . opt-default RBRACE
    (105) opt-default -> .
    (106) opt-default -> . S_DEFAULT

    RBRACE          reduce using rule 105 (opt-default -> .)
    S_DEFAULT       shift and go to state 331

    opt-default                    shift and go to state 330

state 300

    (108) case-star -> case . case-star
    (107) case-star -> .
    (108) case-star -> . case case-star
    (109) case -> . S_CASE INT COLON translation-unit

    S_DEFAULT       reduce using rule 107 (case-star -> .)
    RBRACE          reduce using rule 107 (case-star -> .)
    S_CASE          shift and go to state 301

    case                           shift and go to state 300
    case-star                      shift and go to state 332

state 301

    (109) case -> S_CASE . INT COLON translation-unit

    INT             shift and go to state 333


state 302

    (111) wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .

    SEMICOLON       reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    C_GLOBAL        reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    D_IMPORT        reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    C_PRAGMA        reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    LBRACE          reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_IF            reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_SWITCH        reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    E_WAIT          reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_ITERATE       reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    ID              reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    AT              reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    LPAREN          reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_INT       reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_DOUBLE    reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_FLOAT     reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_VOID      reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_UINT      reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_BOOL      reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_CHARACTER reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    class_String    reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    collection_SET  reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    collection_ARRAY reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    collection_DICT reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_FOREACH       reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_FOR           reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    C_APP           reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    D_FUNCTION      reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    LESS            reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    $end            reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    RBRACE          reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_CASE          reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)
    S_DEFAULT       reduce using rule 111 (wait-stmt -> E_WAIT opt-deep LPAREN expr-list RPAREN block .)


state 303

    (114) foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr . block
    (85) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 26

    block                          shift and go to state 334

state 304

    (117) for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr . SEMICOLON for-update-list RPAREN block

    SEMICOLON       shift and go to state 335


state 305

    (121) for-init-star -> COMMA for-init . for-init-star
    (120) for-init-star -> .
    (121) for-init-star -> . COMMA for-init for-init-star

    SEMICOLON       reduce using rule 120 (for-init-star -> .)
    COMMA           shift and go to state 263

    for-init-star                  shift and go to state 336

state 306

    (123) for-init -> type-prefix var-name type-suffix . ASSIGN expr

    ASSIGN          shift and go to state 337


state 307

    (127) for-assignment -> var-name ASSIGN expr .

    COMMA           reduce using rule 127 (for-assignment -> var-name ASSIGN expr .)
    SEMICOLON       reduce using rule 127 (for-assignment -> var-name ASSIGN expr .)
    RPAREN          reduce using rule 127 (for-assignment -> var-name ASSIGN expr .)


state 308

    (61) foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .

    SEMICOLON       reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    C_GLOBAL        reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    D_IMPORT        reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    C_PRAGMA        reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    LBRACE          reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_IF            reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_SWITCH        reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    E_WAIT          reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_ITERATE       reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    ID              reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    AT              reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    LPAREN          reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_INT       reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_DOUBLE    reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_FLOAT     reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_VOID      reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_UINT      reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_BOOL      reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_CHARACTER reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    class_String    reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    collection_SET  reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    collection_ARRAY reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    collection_DICT reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_FOREACH       reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_FOR           reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    C_APP           reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    D_FUNCTION      reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    LESS            reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    $end            reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    RBRACE          reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_CASE          reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)
    S_DEFAULT       reduce using rule 61 (foreign-func-body -> STR_LITERAL STR_LITERAL empty-or-literal empty-or-more-literals .)


state 309

    (65) empty-or-more-literals -> LBRACKET . single-or-multiple-literal RBRACKET
    (66) single-or-multiple-literal -> . STR_LITERAL
    (67) single-or-multiple-literal -> . MUL_STR_LITERAL

    STR_LITERAL     shift and go to state 339
    MUL_STR_LITERAL shift and go to state 340

    single-or-multiple-literal     shift and go to state 338

state 310

    (49) app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .

    SEMICOLON       reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    C_GLOBAL        reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    D_IMPORT        reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    C_PRAGMA        reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    LBRACE          reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    S_IF            reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    S_SWITCH        reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    E_WAIT          reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    S_ITERATE       reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    ID              reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    AT              reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    LPAREN          reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    class_INT       reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    class_DOUBLE    reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    class_FLOAT     reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    class_VOID      reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    class_UINT      reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    class_BOOL      reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    class_CHARACTER reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    class_String    reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    collection_SET  reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    collection_ARRAY reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    collection_DICT reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    S_FOREACH       reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    S_FOR           reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    C_APP           reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    D_FUNCTION      reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    LESS            reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    $end            reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    RBRACE          reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    S_CASE          reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)
    S_DEFAULT       reduce using rule 49 (app-func-defn -> annotation-star C_APP func-hdr LBRACE app-body RBRACE .)


state 311

    (59) app-arg-expr-star -> app-arg-expr . app-arg-expr-star
    (58) app-arg-expr-star -> .
    (59) app-arg-expr-star -> . app-arg-expr app-arg-expr-star
    (232) app-arg-expr -> . opt-at var-name
    (233) app-arg-expr -> . literal
    (234) app-arg-expr -> . array-constructor
    (235) app-arg-expr -> . LPAREN expr RPAREN
    (236) opt-at -> .
    (237) opt-at -> . AT
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE

    E_STDIN         reduce using rule 58 (app-arg-expr-star -> .)
    E_STDOUT        reduce using rule 58 (app-arg-expr-star -> .)
    E_STDERR        reduce using rule 58 (app-arg-expr-star -> .)
    SEMICOLON       reduce using rule 58 (app-arg-expr-star -> .)
    RBRACE          reduce using rule 58 (app-arg-expr-star -> .)
    LPAREN          shift and go to state 273
    ID              reduce using rule 236 (opt-at -> .)
    AT              shift and go to state 274
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139

    app-arg-expr                   shift and go to state 311
    app-arg-expr-star              shift and go to state 341
    opt-at                         shift and go to state 270
    literal                        shift and go to state 271
    array-constructor              shift and go to state 272
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132

state 312

    (50) app-body -> app-arg-expr app-arg-expr-star . app-out-star empty-or-semicolon
    (53) app-out-star -> .
    (54) app-out-star -> . std-in-out-err ASSIGN expr app-out-star
    (55) std-in-out-err -> . E_STDIN
    (56) std-in-out-err -> . E_STDOUT
    (57) std-in-out-err -> . E_STDERR

    SEMICOLON       reduce using rule 53 (app-out-star -> .)
    RBRACE          reduce using rule 53 (app-out-star -> .)
    E_STDIN         shift and go to state 344
    E_STDOUT        shift and go to state 345
    E_STDERR        shift and go to state 346

    app-out-star                   shift and go to state 342
    std-in-out-err                 shift and go to state 343

state 313

    (232) app-arg-expr -> opt-at var-name .

    LPAREN          reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    AT              reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    STR_LITERAL     reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    MUL_STR_LITERAL reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    INT             reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    DOUBLE          reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    INF             reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    NAN             reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    E_TRUE          reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    E_FALSE         reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    LBRACKET        reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    LBRACE          reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    E_STDIN         reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    E_STDOUT        reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    E_STDERR        reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    SEMICOLON       reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    ID              reduce using rule 232 (app-arg-expr -> opt-at var-name .)
    RBRACE          reduce using rule 232 (app-arg-expr -> opt-at var-name .)


state 314

    (235) app-arg-expr -> LPAREN expr . RPAREN

    RPAREN          shift and go to state 347


state 315

    (175) func-call-arg-star -> COMMA expr-or-kw . func-call-arg-star
    (174) func-call-arg-star -> .
    (175) func-call-arg-star -> . COMMA expr-or-kw func-call-arg-star

    RPAREN          reduce using rule 174 (func-call-arg-star -> .)
    COMMA           shift and go to state 277

    func-call-arg-star             shift and go to state 348

state 316

    (40) comma-args-star -> COMMA formal-arg . comma-args-star
    (39) comma-args-star -> .
    (40) comma-args-star -> . COMMA formal-arg comma-args-star

    RPAREN          reduce using rule 39 (comma-args-star -> .)
    COMMA           shift and go to state 282

    comma-args-star                shift and go to state 349

state 317

    (41) formal-arg -> type-prefix empty-or-range var-name . type-suffix empty-or-ass-expr
    (79) type-suffix -> .
    (80) type-suffix -> . LBRACKET empty-or-standalone-type RBRACKET type-suffix

    LPAREN          reduce using rule 79 (type-suffix -> .)
    ASSIGN          reduce using rule 79 (type-suffix -> .)
    COMMA           reduce using rule 79 (type-suffix -> .)
    RPAREN          reduce using rule 79 (type-suffix -> .)
    LBRACKET        shift and go to state 165

    type-suffix                    shift and go to state 350

state 318

    (34) comma-name-star -> COMMA var-name comma-name-star .

    GREATER         reduce using rule 34 (comma-name-star -> COMMA var-name comma-name-star .)


state 319

    (100) update-stmt -> var-name LESS ID GREATER UPD expr . SEMICOLON

    SEMICOLON       shift and go to state 351


state 320

    (128) iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr . RPAREN

    RPAREN          shift and go to state 352


state 321

    (75) empty-or-assign-expr -> ASSIGN expr .

    SEMICOLON       reduce using rule 75 (empty-or-assign-expr -> ASSIGN expr .)
    ARROW           reduce using rule 75 (empty-or-assign-expr -> ASSIGN expr .)


state 322

    (84) var-mapping -> LESS expr GREATER .

    ASSIGN          reduce using rule 84 (var-mapping -> LESS expr GREATER .)
    SEMICOLON       reduce using rule 84 (var-mapping -> LESS expr GREATER .)
    ARROW           reduce using rule 84 (var-mapping -> LESS expr GREATER .)


state 323

    (80) type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .

    LESS            reduce using rule 80 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    ASSIGN          reduce using rule 80 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    SEMICOLON       reduce using rule 80 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    ARROW           reduce using rule 80 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    GREATER         reduce using rule 80 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    RBRACKET        reduce using rule 80 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    LPAREN          reduce using rule 80 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    COMMA           reduce using rule 80 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)
    RPAREN          reduce using rule 80 (type-suffix -> LBRACKET empty-or-standalone-type RBRACKET type-suffix .)


state 324

    (180) comma-expr-star -> COMMA . expr comma-expr-star
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 353
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 325

    (178) tuple-constructor -> LPAREN expr COMMA expr comma-expr-star . RPAREN

    RPAREN          shift and go to state 354


state 326

    (189) opt-coloned-expr -> COLON . expr
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 355
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 327

    (187) array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr . RBRACKET

    RBRACKET        shift and go to state 356


state 328

    (194) comma-array-kv-elem-star -> COMMA array-kv-elem comma-array-kv-elem-star .

    RBRACE          reduce using rule 194 (comma-array-kv-elem-star -> COMMA array-kv-elem comma-array-kv-elem-star .)


state 329

    (103) opt-else-block -> S_ELSE block .

    SEMICOLON       reduce using rule 103 (opt-else-block -> S_ELSE block .)
    C_GLOBAL        reduce using rule 103 (opt-else-block -> S_ELSE block .)
    D_IMPORT        reduce using rule 103 (opt-else-block -> S_ELSE block .)
    C_PRAGMA        reduce using rule 103 (opt-else-block -> S_ELSE block .)
    LBRACE          reduce using rule 103 (opt-else-block -> S_ELSE block .)
    S_IF            reduce using rule 103 (opt-else-block -> S_ELSE block .)
    S_SWITCH        reduce using rule 103 (opt-else-block -> S_ELSE block .)
    E_WAIT          reduce using rule 103 (opt-else-block -> S_ELSE block .)
    S_ITERATE       reduce using rule 103 (opt-else-block -> S_ELSE block .)
    ID              reduce using rule 103 (opt-else-block -> S_ELSE block .)
    AT              reduce using rule 103 (opt-else-block -> S_ELSE block .)
    LPAREN          reduce using rule 103 (opt-else-block -> S_ELSE block .)
    class_INT       reduce using rule 103 (opt-else-block -> S_ELSE block .)
    class_DOUBLE    reduce using rule 103 (opt-else-block -> S_ELSE block .)
    class_FLOAT     reduce using rule 103 (opt-else-block -> S_ELSE block .)
    class_VOID      reduce using rule 103 (opt-else-block -> S_ELSE block .)
    class_UINT      reduce using rule 103 (opt-else-block -> S_ELSE block .)
    class_BOOL      reduce using rule 103 (opt-else-block -> S_ELSE block .)
    class_CHARACTER reduce using rule 103 (opt-else-block -> S_ELSE block .)
    class_String    reduce using rule 103 (opt-else-block -> S_ELSE block .)
    collection_SET  reduce using rule 103 (opt-else-block -> S_ELSE block .)
    collection_ARRAY reduce using rule 103 (opt-else-block -> S_ELSE block .)
    collection_DICT reduce using rule 103 (opt-else-block -> S_ELSE block .)
    S_FOREACH       reduce using rule 103 (opt-else-block -> S_ELSE block .)
    S_FOR           reduce using rule 103 (opt-else-block -> S_ELSE block .)
    C_APP           reduce using rule 103 (opt-else-block -> S_ELSE block .)
    D_FUNCTION      reduce using rule 103 (opt-else-block -> S_ELSE block .)
    LESS            reduce using rule 103 (opt-else-block -> S_ELSE block .)
    $end            reduce using rule 103 (opt-else-block -> S_ELSE block .)
    RBRACE          reduce using rule 103 (opt-else-block -> S_ELSE block .)
    S_CASE          reduce using rule 103 (opt-else-block -> S_ELSE block .)
    S_DEFAULT       reduce using rule 103 (opt-else-block -> S_ELSE block .)


state 330

    (104) switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default . RBRACE

    RBRACE          shift and go to state 357


state 331

    (106) opt-default -> S_DEFAULT .

    RBRACE          reduce using rule 106 (opt-default -> S_DEFAULT .)


state 332

    (108) case-star -> case case-star .

    S_DEFAULT       reduce using rule 108 (case-star -> case case-star .)
    RBRACE          reduce using rule 108 (case-star -> case case-star .)


state 333

    (109) case -> S_CASE INT . COLON translation-unit

    COLON           shift and go to state 358


state 334

    (114) foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .

    SEMICOLON       reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    C_GLOBAL        reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    D_IMPORT        reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    C_PRAGMA        reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    LBRACE          reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_IF            reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_SWITCH        reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    E_WAIT          reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_ITERATE       reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    ID              reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    AT              reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    LPAREN          reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_INT       reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_DOUBLE    reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_FLOAT     reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_VOID      reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_UINT      reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_BOOL      reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_CHARACTER reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    class_String    reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    collection_SET  reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    collection_ARRAY reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    collection_DICT reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_FOREACH       reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_FOR           reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    C_APP           reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    D_FUNCTION      reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    LESS            reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    $end            reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    RBRACE          reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_CASE          reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)
    S_DEFAULT       reduce using rule 114 (foreach-loop -> annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block .)


state 335

    (117) for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON . for-update-list RPAREN block
    (124) for-update-list -> . for-assignment for-assignment-star
    (127) for-assignment -> . var-name ASSIGN expr
    (223) var-name -> . ID

    ID              shift and go to state 66

    for-update-list                shift and go to state 359
    for-assignment                 shift and go to state 360
    var-name                       shift and go to state 214

state 336

    (121) for-init-star -> COMMA for-init for-init-star .

    SEMICOLON       reduce using rule 121 (for-init-star -> COMMA for-init for-init-star .)


state 337

    (123) for-init -> type-prefix var-name type-suffix ASSIGN . expr
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    var-name                       shift and go to state 120
    expr                           shift and go to state 361
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 338

    (65) empty-or-more-literals -> LBRACKET single-or-multiple-literal . RBRACKET

    RBRACKET        shift and go to state 362


state 339

    (66) single-or-multiple-literal -> STR_LITERAL .

    RBRACKET        reduce using rule 66 (single-or-multiple-literal -> STR_LITERAL .)


state 340

    (67) single-or-multiple-literal -> MUL_STR_LITERAL .

    RBRACKET        reduce using rule 67 (single-or-multiple-literal -> MUL_STR_LITERAL .)


state 341

    (59) app-arg-expr-star -> app-arg-expr app-arg-expr-star .

    E_STDIN         reduce using rule 59 (app-arg-expr-star -> app-arg-expr app-arg-expr-star .)
    E_STDOUT        reduce using rule 59 (app-arg-expr-star -> app-arg-expr app-arg-expr-star .)
    E_STDERR        reduce using rule 59 (app-arg-expr-star -> app-arg-expr app-arg-expr-star .)
    SEMICOLON       reduce using rule 59 (app-arg-expr-star -> app-arg-expr app-arg-expr-star .)
    RBRACE          reduce using rule 59 (app-arg-expr-star -> app-arg-expr app-arg-expr-star .)


state 342

    (50) app-body -> app-arg-expr app-arg-expr-star app-out-star . empty-or-semicolon
    (51) empty-or-semicolon -> .
    (52) empty-or-semicolon -> . SEMICOLON

    RBRACE          reduce using rule 51 (empty-or-semicolon -> .)
    SEMICOLON       shift and go to state 364

    empty-or-semicolon             shift and go to state 363

state 343

    (54) app-out-star -> std-in-out-err . ASSIGN expr app-out-star

    ASSIGN          shift and go to state 365


state 344

    (55) std-in-out-err -> E_STDIN .

    ASSIGN          reduce using rule 55 (std-in-out-err -> E_STDIN .)


state 345

    (56) std-in-out-err -> E_STDOUT .

    ASSIGN          reduce using rule 56 (std-in-out-err -> E_STDOUT .)


state 346

    (57) std-in-out-err -> E_STDERR .

    ASSIGN          reduce using rule 57 (std-in-out-err -> E_STDERR .)


state 347

    (235) app-arg-expr -> LPAREN expr RPAREN .

    LPAREN          reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    AT              reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    STR_LITERAL     reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    MUL_STR_LITERAL reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    INT             reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    DOUBLE          reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    INF             reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    NAN             reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    E_TRUE          reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    E_FALSE         reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    LBRACKET        reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    LBRACE          reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    E_STDIN         reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    E_STDOUT        reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    E_STDERR        reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    ID              reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)
    RBRACE          reduce using rule 235 (app-arg-expr -> LPAREN expr RPAREN .)


state 348

    (175) func-call-arg-star -> COMMA expr-or-kw func-call-arg-star .

    RPAREN          reduce using rule 175 (func-call-arg-star -> COMMA expr-or-kw func-call-arg-star .)


state 349

    (40) comma-args-star -> COMMA formal-arg comma-args-star .

    RPAREN          reduce using rule 40 (comma-args-star -> COMMA formal-arg comma-args-star .)


state 350

    (41) formal-arg -> type-prefix empty-or-range var-name type-suffix . empty-or-ass-expr
    (44) empty-or-ass-expr -> .
    (45) empty-or-ass-expr -> . formal-arg-list ASSIGN expr
    (35) formal-arg-list -> .
    (36) formal-arg-list -> . LPAREN opt-formal-args RPAREN

    COMMA           reduce using rule 44 (empty-or-ass-expr -> .)
    RPAREN          reduce using rule 44 (empty-or-ass-expr -> .)
    ASSIGN          reduce using rule 35 (formal-arg-list -> .)
    LPAREN          shift and go to state 153

    empty-or-ass-expr              shift and go to state 366
    formal-arg-list                shift and go to state 367

state 351

    (100) update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .

    SEMICOLON       reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    C_GLOBAL        reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    D_IMPORT        reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    C_PRAGMA        reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    LBRACE          reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_IF            reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_SWITCH        reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    E_WAIT          reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_ITERATE       reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    ID              reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    AT              reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    LPAREN          reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_INT       reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_DOUBLE    reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_FLOAT     reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_VOID      reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_UINT      reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_BOOL      reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_CHARACTER reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    class_String    reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    collection_SET  reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    collection_ARRAY reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    collection_DICT reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_FOREACH       reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_FOR           reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    C_APP           reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    D_FUNCTION      reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    LESS            reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    $end            reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    RBRACE          reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_CASE          reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)
    S_DEFAULT       reduce using rule 100 (update-stmt -> var-name LESS ID GREATER UPD expr SEMICOLON .)


state 352

    (128) iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    C_GLOBAL        reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    D_IMPORT        reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    C_PRAGMA        reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    LBRACE          reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_IF            reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_SWITCH        reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    E_WAIT          reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_ITERATE       reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    ID              reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    AT              reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    LPAREN          reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_INT       reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_DOUBLE    reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_FLOAT     reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_VOID      reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_UINT      reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_BOOL      reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_CHARACTER reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    class_String    reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    collection_SET  reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    collection_ARRAY reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    collection_DICT reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_FOREACH       reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_FOR           reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    C_APP           reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    D_FUNCTION      reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    LESS            reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    $end            reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    RBRACE          reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_CASE          reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)
    S_DEFAULT       reduce using rule 128 (iterate-loop -> S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN .)


state 353

    (180) comma-expr-star -> COMMA expr . comma-expr-star
    (179) comma-expr-star -> .
    (180) comma-expr-star -> . COMMA expr comma-expr-star

    RPAREN          reduce using rule 179 (comma-expr-star -> .)
    COMMA           shift and go to state 324

    comma-expr-star                shift and go to state 368

state 354

    (178) tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .

    LBRACKET        reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    DOT             reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    MULT            reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    DIV             reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    MULTPER         reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    DOUBLEPER       reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    MOD             reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    PLUS            reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    MINUS           reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    LESS            reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    LESS_EQ         reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    EQUAL           reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    GREATER         reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    GREATER_EQ      reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    NOT_EQUAL       reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    LOG_AND         reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    LOG_OR          reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    SEMICOLON       reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    RPAREN          reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    RBRACKET        reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    ARROW           reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    COMMA           reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    COLON           reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    AT              reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    S_FOREACH       reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    S_FOR           reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    C_APP           reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    D_FUNCTION      reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    LPAREN          reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    RBRACE          reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    LBRACE          reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    E_STDIN         reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    E_STDOUT        reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)
    E_STDERR        reduce using rule 178 (tuple-constructor -> LPAREN expr COMMA expr comma-expr-star RPAREN .)


state 355

    (189) opt-coloned-expr -> COLON expr .

    RBRACKET        reduce using rule 189 (opt-coloned-expr -> COLON expr .)


state 356

    (187) array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .

    LBRACKET        reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    DOT             reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    MULT            reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    DIV             reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    MULTPER         reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    DOUBLEPER       reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    MOD             reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    PLUS            reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    MINUS           reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    LESS            reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    LESS_EQ         reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    EQUAL           reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    GREATER         reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    GREATER_EQ      reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    NOT_EQUAL       reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    LOG_AND         reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    LOG_OR          reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    SEMICOLON       reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    RPAREN          reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    RBRACKET        reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    ARROW           reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    COMMA           reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    COLON           reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    AT              reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    S_FOREACH       reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    S_FOR           reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    C_APP           reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    D_FUNCTION      reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    LPAREN          reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    RBRACE          reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    LBRACE          reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    E_STDIN         reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    E_STDOUT        reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    E_STDERR        reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    STR_LITERAL     reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    MUL_STR_LITERAL reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    INT             reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    DOUBLE          reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    INF             reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    NAN             reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    E_TRUE          reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    E_FALSE         reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)
    ID              reduce using rule 187 (array-range-constructor -> LBRACKET expr COLON expr opt-coloned-expr RBRACKET .)


state 357

    (104) switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .

    SEMICOLON       reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    C_GLOBAL        reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    D_IMPORT        reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    C_PRAGMA        reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    LBRACE          reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_IF            reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_SWITCH        reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    E_WAIT          reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_ITERATE       reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    ID              reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    AT              reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    LPAREN          reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_INT       reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_DOUBLE    reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_FLOAT     reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_VOID      reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_UINT      reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_BOOL      reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_CHARACTER reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    class_String    reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    collection_SET  reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    collection_ARRAY reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    collection_DICT reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_FOREACH       reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_FOR           reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    C_APP           reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    D_FUNCTION      reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    LESS            reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    $end            reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    RBRACE          reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_CASE          reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)
    S_DEFAULT       reduce using rule 104 (switch-stmt -> S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE .)


state 358

    (109) case -> S_CASE INT COLON . translation-unit
    (1) translation-unit -> . statement-star
    (2) statement-star -> .
    (3) statement-star -> . statement statement-star
    (4) statement -> . SEMICOLON
    (5) statement -> . global-const-defn
    (6) statement -> . import-stmt
    (7) statement -> . pragma-stmt
    (8) statement -> . func-defn
    (9) statement -> . block
    (10) statement -> . if-stmt
    (11) statement -> . switch-stmt
    (12) statement -> . wait-stmt
    (13) statement -> . foreach-loop
    (14) statement -> . for-loop
    (15) statement -> . iterate-loop
    (16) statement -> . stmt-chain
    (17) statement -> . update-stmt
    (18) global-const-defn -> . C_GLOBAL C_CONST var-decl SEMICOLON
    (19) import-stmt -> . D_IMPORT module-path SEMICOLON
    (20) import-stmt -> . D_IMPORT STR_LITERAL SEMICOLON
    (24) pragma-stmt -> . C_PRAGMA ID expr SEMICOLON
    (25) func-defn -> . swift-func-defn
    (26) func-defn -> . app-func-defn
    (27) func-defn -> . foreign-func-defn
    (85) block -> . LBRACE translation-unit RBRACE
    (101) if-stmt -> . S_IF LPAREN expr RPAREN block opt-else-block
    (104) switch-stmt -> . S_SWITCH LPAREN expr RPAREN LBRACE case-star opt-default RBRACE
    (111) wait-stmt -> . E_WAIT opt-deep LPAREN expr-list RPAREN block
    (114) foreach-loop -> . annotation-star S_FOREACH var-name opt-comma-var-name S_IN expr block
    (117) for-loop -> . annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block
    (128) iterate-loop -> . S_ITERATE var-name block S_UNTIL LPAREN expr RPAREN
    (86) stmt-chain -> . chainable-stmt semicolon-or-arrow statement
    (100) update-stmt -> . var-name LESS ID GREATER UPD expr SEMICOLON
    (46) swift-func-defn -> . annotation-star func-hdr ARROW block
    (49) app-func-defn -> . annotation-star C_APP func-hdr LBRACE app-body RBRACE
    (60) foreign-func-defn -> . annotation-star func-hdr foreign-func-body
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (89) chainable-stmt -> . var-name
    (90) chainable-stmt -> . func-call
    (91) chainable-stmt -> . var-decl
    (92) chainable-stmt -> . assignment
    (223) var-name -> . ID
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (68) var-decl -> . type-prefix var-decl-rest
    (93) assignment -> . lval-or-paren-lval assign-or-plusas expr-list
    (76) type-prefix -> . type-name
    (77) type-prefix -> . param-type
    (98) lval-or-paren-lval -> . lval-list
    (99) lval-or-paren-lval -> . LPAREN lval-list RPAREN
    (210) type-name -> . class_INT
    (211) type-name -> . class_DOUBLE
    (212) type-name -> . class_FLOAT
    (213) type-name -> . class_VOID
    (214) type-name -> . class_UINT
    (215) type-name -> . class_BOOL
    (216) type-name -> . class_CHARACTER
    (217) type-name -> . class_String
    (218) type-name -> . collection_SET
    (219) type-name -> . collection_ARRAY
    (220) type-name -> . collection_DICT
    (221) type-name -> . ID
    (78) param-type -> . type-name LESS standalone-type GREATER
    (225) lval-list -> . lval-expr lval-expr-star
    (228) lval-expr -> . var-name subscript-star

  ! shift/reduce conflict for LPAREN resolved as shift
    S_CASE          reduce using rule 2 (statement-star -> .)
    S_DEFAULT       reduce using rule 2 (statement-star -> .)
    RBRACE          reduce using rule 2 (statement-star -> .)
    SEMICOLON       shift and go to state 4
    C_GLOBAL        shift and go to state 18
    D_IMPORT        shift and go to state 20
    C_PRAGMA        shift and go to state 21
    LBRACE          shift and go to state 26
    S_IF            shift and go to state 27
    S_SWITCH        shift and go to state 29
    E_WAIT          shift and go to state 30
    S_ITERATE       shift and go to state 33
    S_FOREACH       reduce using rule 47 (annotation-star -> .)
    S_FOR           reduce using rule 47 (annotation-star -> .)
    C_APP           reduce using rule 47 (annotation-star -> .)
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LESS            reduce using rule 47 (annotation-star -> .)
    ID              shift and go to state 22
    AT              shift and go to state 38
    LPAREN          shift and go to state 28
    class_INT       shift and go to state 44
    class_DOUBLE    shift and go to state 45
    class_FLOAT     shift and go to state 46
    class_VOID      shift and go to state 47
    class_UINT      shift and go to state 48
    class_BOOL      shift and go to state 49
    class_CHARACTER shift and go to state 50
    class_String    shift and go to state 51
    collection_SET  shift and go to state 52
    collection_ARRAY shift and go to state 53
    collection_DICT shift and go to state 54

  ! LPAREN          [ reduce using rule 47 (annotation-star -> .) ]

    translation-unit               shift and go to state 369
    statement-star                 shift and go to state 2
    statement                      shift and go to state 3
    global-const-defn              shift and go to state 5
    import-stmt                    shift and go to state 6
    pragma-stmt                    shift and go to state 7
    func-defn                      shift and go to state 8
    block                          shift and go to state 9
    if-stmt                        shift and go to state 10
    switch-stmt                    shift and go to state 11
    wait-stmt                      shift and go to state 12
    foreach-loop                   shift and go to state 13
    for-loop                       shift and go to state 14
    iterate-loop                   shift and go to state 15
    stmt-chain                     shift and go to state 16
    update-stmt                    shift and go to state 17
    var-decl                       shift and go to state 19
    swift-func-defn                shift and go to state 23
    app-func-defn                  shift and go to state 24
    foreign-func-defn              shift and go to state 25
    annotation-star                shift and go to state 31
    var-name                       shift and go to state 32
    chainable-stmt                 shift and go to state 34
    annotation                     shift and go to state 35
    func-call                      shift and go to state 36
    assignment                     shift and go to state 37
    type-prefix                    shift and go to state 39
    lval-or-paren-lval             shift and go to state 40
    type-name                      shift and go to state 41
    param-type                     shift and go to state 42
    lval-list                      shift and go to state 43
    lval-expr                      shift and go to state 55

state 359

    (117) for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list . RPAREN block

    RPAREN          shift and go to state 370


state 360

    (124) for-update-list -> for-assignment . for-assignment-star
    (125) for-assignment-star -> .
    (126) for-assignment-star -> . COMMA for-assignment for-assignment-star

    RPAREN          reduce using rule 125 (for-assignment-star -> .)
    COMMA           shift and go to state 372

    for-assignment-star            shift and go to state 371

state 361

    (123) for-init -> type-prefix var-name type-suffix ASSIGN expr .

    COMMA           reduce using rule 123 (for-init -> type-prefix var-name type-suffix ASSIGN expr .)
    SEMICOLON       reduce using rule 123 (for-init -> type-prefix var-name type-suffix ASSIGN expr .)


state 362

    (65) empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .

    SEMICOLON       reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    C_GLOBAL        reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    D_IMPORT        reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    C_PRAGMA        reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    LBRACE          reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_IF            reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_SWITCH        reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    E_WAIT          reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_ITERATE       reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    ID              reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    AT              reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    LPAREN          reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_INT       reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_DOUBLE    reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_FLOAT     reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_VOID      reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_UINT      reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_BOOL      reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_CHARACTER reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    class_String    reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    collection_SET  reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    collection_ARRAY reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    collection_DICT reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_FOREACH       reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_FOR           reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    C_APP           reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    D_FUNCTION      reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    LESS            reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    $end            reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    RBRACE          reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_CASE          reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)
    S_DEFAULT       reduce using rule 65 (empty-or-more-literals -> LBRACKET single-or-multiple-literal RBRACKET .)


state 363

    (50) app-body -> app-arg-expr app-arg-expr-star app-out-star empty-or-semicolon .

    RBRACE          reduce using rule 50 (app-body -> app-arg-expr app-arg-expr-star app-out-star empty-or-semicolon .)


state 364

    (52) empty-or-semicolon -> SEMICOLON .

    RBRACE          reduce using rule 52 (empty-or-semicolon -> SEMICOLON .)


state 365

    (54) app-out-star -> std-in-out-err ASSIGN . expr app-out-star
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 373
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 366

    (41) formal-arg -> type-prefix empty-or-range var-name type-suffix empty-or-ass-expr .

    COMMA           reduce using rule 41 (formal-arg -> type-prefix empty-or-range var-name type-suffix empty-or-ass-expr .)
    RPAREN          reduce using rule 41 (formal-arg -> type-prefix empty-or-range var-name type-suffix empty-or-ass-expr .)


state 367

    (45) empty-or-ass-expr -> formal-arg-list . ASSIGN expr

    ASSIGN          shift and go to state 374


state 368

    (180) comma-expr-star -> COMMA expr comma-expr-star .

    RPAREN          reduce using rule 180 (comma-expr-star -> COMMA expr comma-expr-star .)


state 369

    (109) case -> S_CASE INT COLON translation-unit .

    S_CASE          reduce using rule 109 (case -> S_CASE INT COLON translation-unit .)
    S_DEFAULT       reduce using rule 109 (case -> S_CASE INT COLON translation-unit .)
    RBRACE          reduce using rule 109 (case -> S_CASE INT COLON translation-unit .)


state 370

    (117) for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN . block
    (85) block -> . LBRACE translation-unit RBRACE

    LBRACE          shift and go to state 26

    block                          shift and go to state 375

state 371

    (124) for-update-list -> for-assignment for-assignment-star .

    RPAREN          reduce using rule 124 (for-update-list -> for-assignment for-assignment-star .)


state 372

    (126) for-assignment-star -> COMMA . for-assignment for-assignment-star
    (127) for-assignment -> . var-name ASSIGN expr
    (223) var-name -> . ID

    ID              shift and go to state 66

    for-assignment                 shift and go to state 376
    var-name                       shift and go to state 214

state 373

    (54) app-out-star -> std-in-out-err ASSIGN expr . app-out-star
    (53) app-out-star -> .
    (54) app-out-star -> . std-in-out-err ASSIGN expr app-out-star
    (55) std-in-out-err -> . E_STDIN
    (56) std-in-out-err -> . E_STDOUT
    (57) std-in-out-err -> . E_STDERR

    SEMICOLON       reduce using rule 53 (app-out-star -> .)
    RBRACE          reduce using rule 53 (app-out-star -> .)
    E_STDIN         shift and go to state 344
    E_STDOUT        shift and go to state 345
    E_STDERR        shift and go to state 346

    std-in-out-err                 shift and go to state 343
    app-out-star                   shift and go to state 377

state 374

    (45) empty-or-ass-expr -> formal-arg-list ASSIGN . expr
    (129) expr -> . or-expr
    (130) or-expr -> . and-expr
    (131) or-expr -> . or-expr LOG_OR and-expr
    (132) and-expr -> . eq-expr
    (133) and-expr -> . and-expr LOG_AND eq-expr
    (134) eq-expr -> . cmp-expr
    (135) eq-expr -> . eq-expr eq-or-not-eq eq-expr
    (138) cmp-expr -> . add-expr
    (139) cmp-expr -> . cmp-expr cmp-sign add-expr
    (145) add-expr -> . mult-expr
    (146) add-expr -> . add-expr add-sign mult-expr
    (149) mult-expr -> . unary-expr
    (150) mult-expr -> . mult-expr mult-sign unary-expr
    (156) unary-expr -> . postfix-expr
    (157) unary-expr -> . minus-or-excl postfix-expr
    (160) postfix-expr -> . base-expr
    (161) postfix-expr -> . postfix-expr array-or-struct
    (158) minus-or-excl -> . MINUS
    (159) minus-or-excl -> . EXCLAMATION
    (166) base-expr -> . literal
    (167) base-expr -> . func-call
    (168) base-expr -> . var-name
    (169) base-expr -> . LPAREN expr RPAREN
    (170) base-expr -> . tuple-constructor
    (171) base-expr -> . array-constructor
    (199) literal -> . STR_LITERAL
    (200) literal -> . MUL_STR_LITERAL
    (201) literal -> . INT
    (202) literal -> . float-literal
    (203) literal -> . bool-literal
    (172) func-call -> . annotation-star func-name LPAREN func-call-arg-list RPAREN
    (223) var-name -> . ID
    (178) tuple-constructor -> . LPAREN expr COMMA expr comma-expr-star RPAREN
    (181) array-constructor -> . array-list-constructor
    (182) array-constructor -> . array-range-constructor
    (183) array-constructor -> . array-kv-constructor
    (204) float-literal -> . DOUBLE
    (205) float-literal -> . INF
    (206) float-literal -> . NAN
    (207) bool-literal -> . E_TRUE
    (208) bool-literal -> . E_FALSE
    (47) annotation-star -> .
    (48) annotation-star -> . annotation annotation-star
    (184) array-list-constructor -> . LBRACKET opt-expr-list RBRACKET
    (187) array-range-constructor -> . LBRACKET expr COLON expr opt-coloned-expr RBRACKET
    (190) array-kv-constructor -> . LBRACE opt-array-constructor RBRACE
    (196) annotation -> . AT ID
    (197) annotation -> . AT kw-expr

    MINUS           shift and go to state 116
    EXCLAMATION     shift and go to state 117
    LPAREN          shift and go to state 121
    STR_LITERAL     shift and go to state 124
    MUL_STR_LITERAL shift and go to state 125
    INT             shift and go to state 126
    ID              shift and go to state 66
    DOUBLE          shift and go to state 133
    INF             shift and go to state 134
    NAN             shift and go to state 135
    E_TRUE          shift and go to state 136
    E_FALSE         shift and go to state 137
    D_FUNCTION      reduce using rule 47 (annotation-star -> .)
    LBRACKET        shift and go to state 138
    LBRACE          shift and go to state 139
    AT              shift and go to state 38

    expr                           shift and go to state 378
    or-expr                        shift and go to state 106
    and-expr                       shift and go to state 107
    eq-expr                        shift and go to state 108
    cmp-expr                       shift and go to state 109
    add-expr                       shift and go to state 110
    mult-expr                      shift and go to state 111
    unary-expr                     shift and go to state 112
    postfix-expr                   shift and go to state 113
    minus-or-excl                  shift and go to state 114
    base-expr                      shift and go to state 115
    literal                        shift and go to state 118
    func-call                      shift and go to state 119
    var-name                       shift and go to state 120
    tuple-constructor              shift and go to state 122
    array-constructor              shift and go to state 123
    float-literal                  shift and go to state 127
    bool-literal                   shift and go to state 128
    annotation-star                shift and go to state 129
    array-list-constructor         shift and go to state 130
    array-range-constructor        shift and go to state 131
    array-kv-constructor           shift and go to state 132
    annotation                     shift and go to state 35

state 375

    (117) for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .

    SEMICOLON       reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    C_GLOBAL        reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    D_IMPORT        reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    C_PRAGMA        reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    LBRACE          reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_IF            reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_SWITCH        reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    E_WAIT          reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_ITERATE       reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    ID              reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    AT              reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    LPAREN          reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_INT       reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_DOUBLE    reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_FLOAT     reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_VOID      reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_UINT      reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_BOOL      reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_CHARACTER reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    class_String    reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    collection_SET  reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    collection_ARRAY reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    collection_DICT reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_FOREACH       reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_FOR           reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    C_APP           reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    D_FUNCTION      reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    LESS            reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    $end            reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    RBRACE          reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_CASE          reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)
    S_DEFAULT       reduce using rule 117 (for-loop -> annotation-star S_FOR LPAREN for-init-list SEMICOLON expr SEMICOLON for-update-list RPAREN block .)


state 376

    (126) for-assignment-star -> COMMA for-assignment . for-assignment-star
    (125) for-assignment-star -> .
    (126) for-assignment-star -> . COMMA for-assignment for-assignment-star

    RPAREN          reduce using rule 125 (for-assignment-star -> .)
    COMMA           shift and go to state 372

    for-assignment-star            shift and go to state 379

state 377

    (54) app-out-star -> std-in-out-err ASSIGN expr app-out-star .

    SEMICOLON       reduce using rule 54 (app-out-star -> std-in-out-err ASSIGN expr app-out-star .)
    RBRACE          reduce using rule 54 (app-out-star -> std-in-out-err ASSIGN expr app-out-star .)


state 378

    (45) empty-or-ass-expr -> formal-arg-list ASSIGN expr .

    COMMA           reduce using rule 45 (empty-or-ass-expr -> formal-arg-list ASSIGN expr .)
    RPAREN          reduce using rule 45 (empty-or-ass-expr -> formal-arg-list ASSIGN expr .)


state 379

    (126) for-assignment-star -> COMMA for-assignment for-assignment-star .

    RPAREN          reduce using rule 126 (for-assignment-star -> COMMA for-assignment for-assignment-star .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 3 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 26 resolved as shift
WARNING: shift/reduce conflict for D_FUNCTION in state 31 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 85 resolved as shift
WARNING: shift/reduce conflict for LESS in state 109 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 109 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 244 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 244 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 358 resolved as shift
WARNING: reduce/reduce conflict in state 22 resolved using rule (type-name -> ID)
WARNING: rejected rule (var-name -> ID) in state 22
WARNING: reduce/reduce conflict in state 223 resolved using rule (empty-or-arg-list -> <empty>)
WARNING: rejected rule (formal-arg-list -> <empty>) in state 223
